<?xml version="1.0"?>

<holism>
	<parameter name='N' type='index' comment='number of processes in the system' />
	
	<variable name='x' type='integer' update_type='Discrete' comment='lock' />
	
	<assumption equn='N &gt;= 2' comment='' />

	<automaton name='mux-sem'>
		<initial equn='x = 1' />

		<mode id='0' name='idle' initial='True'>
		</mode>

		<mode id='1' name='start' initial='False'>
		</mode>
		
		<mode id='2' name='cs' initial='False'>
		</mode>
		
		<!--
		<mode id='3' name='E' initial='False'>
		</mode>
		-->
		
		<transition source='idle' destination='start'>
		</transition>
		
		<transition source='start' destination='cs'>
			<guard equn='x == 1' />
			<action equn='x&apos; = 0'/>
		</transition>
		
		<transition source='cs' destination='idle'>
			<action equn='x&apos; = 1'/>
		</transition>
		
		<!--<transition source='E' destination='I'>
			<action equn='x&apos; = 1'/>
		</transition>
		-->
	</automaton>


	<property equn='true' type='safety' />
	
	<!-- <property equn='forall i j ((i != j) implies ( (q[i] == C or q[i] == E) implies ((x == 0) and (q[j] == I or q[j] == T)) ) and ( (q[j] == C or q[j] == E) implies ((x == 0) and (q[i] == I or q[i] == T) )) )' type='safety' comment='inductive invariant that implies mutual exclusion' /> -->

	<!-- <property equn='forall i ((q[i] == C or q[i] == E) iff (x == 0))' type='safety' comment='not inductive' /> -->
	
	<!-- generated by invisible invariants -->
	<!-- <property equn='forall i j ((i != j) implies ( ((x == 1) implies ((q[i] == I or q[i] == T)) and (q[j] != C and q[j] != E)) and ((x == 0) implies ((q[i] == C or q[i] == E) implies (q[j] != C and q[j] != E))) ))' type='safety' comment='inductive invariant that implies mutual exclusion' /> -->
	
	<!-- generated by split invariants (not inductive, from N = 2) -->
<!-- 
	<property equn='forall i j ((i != j) implies 
               ((q[j] == cs and x == 0 and start == q[i]) or
                (q[j] == idle and x == 1 and start == q[i]) or
                (q[i] == idle and x == 1 and idle == q[j]) or
                (q[i] == start and idle == q[j] and x == 1) or
                (q[i] == cs and x == 0 and start == q[j]) or
                (q[i] == start and cs == q[j] and x == 0) or
                (q[i] == idle and x == 1 and start == q[j]) or
                (q[j] == idle and x == 1 and idle == q[i]) or
                (q[j] == start and idle == q[i] and x == 1) or
                (q[i] == cs and x == 0 and idle == q[j]) or
                (q[j] == start and start == q[i] and x == 1) or
                (q[i] == start and start == q[j] and x == 1) or
                (q[j] == cs and x == 0 and idle == q[i]) or
                (q[j] == start and cs == q[i] and x == 0)))' type='safety' />
-->


<!-- generated by split invariants from N = 3 -->
	<property format='smt' type='safety' equn='(forall ((i Int))
  (let ((a!1 (or (and (= (q i) start) (= x 1))
                 (and (= (q i) cs) (= x 0))
                 (and (= (q i) idle) (= x 1))
                 (and (= (q i) start) (= x 0))
                 (and (= idle (q i)) (= x 1))
                 (and (= idle (q i)) (= x 0))
                 (and (= start (q i)) (= x 1))
                 (and (= start (q i)) (= x 0))
                 (and (= cs (q i)) (= x 0))
                 (and (= cs (q i)) (= x 1)))))
    (=&gt; (and (&gt;= i 1) (&lt;= i N)) a!1)))' />

<!-- generated by split invariants (is inductive, from N = 3) -->
	<property format='smt' type='safety' equn='(forall ((i Int) (j Int))
  (let ((a!1 (or (and (= (q i) start) (= idle (q j)) (= x 1))
                 (and (= (q i) cs) (= idle (q j)) (= x 0))
                 (and (= (q i) start) (= start (q j)) (= x 1))
                 (and (= (q i) idle) (= idle (q j)) (= x 1))
                 (and (= (q i) cs) (= start (q j)) (= x 0))
                 (and (= (q i) start) (= cs (q j)) (= x 0))
                 (and (= (q i) start) (= idle (q j)) (= x 0))
                 (and (= (q i) idle) (= start (q j)) (= x 1))
                 (and (= (q i) start) (= start (q j)) (= x 0))
                 (and (= (q j) start) (= idle (q i)) (= x 1))
                 (and (= (q j) start) (= start (q i)) (= x 1))
                 (and (= (q j) cs) (= idle (q i)) (= x 0))
                 (and (= (q j) start) (= cs (q i)) (= x 0))
                 (and (= (q j) cs) (= start (q i)) (= x 0))
                 (and (= (q j) start) (= idle (q i)) (= x 0))
                 (and (= (q j) idle) (= start (q i)) (= x 1))
                 (and (= (q j) start) (= start (q i)) (= x 0))
                 (and (= idle (q i)) (= idle (q j)) (= x 1))
                 (and (= idle (q i)) (= idle (q j)) (= x 0))
                 (and (= start (q i)) (= idle (q j)) (= x 1))
                 (and (= start (q i)) (= idle (q j)) (= x 0))
                 (and (= idle (q i)) (= start (q j)) (= x 1))
                 (and (= idle (q i)) (= start (q j)) (= x 0))
                 (and (= cs (q i)) (= idle (q j)) (= x 0))
                 (and (= start (q i)) (= start (q j)) (= x 1))
                 (and (= start (q i)) (= start (q j)) (= x 0))
                 (and (= idle (q i)) (= cs (q j)) (= x 0))
                 (and (= cs (q i)) (= start (q j)) (= x 0))
                 (and (= start (q i)) (= cs (q j)) (= x 0)))))
    (=&gt; (and (&gt;= i 1) (&lt;= i N) (&gt;= j 1) (&lt;= j N) (distinct i j)) a!1)))' />

	
	
	<property equn='forall i j ((i != j) implies (q[i] != cs or q[j] != cs))' type='safety' />
<!--
	<property equn='forall i j ((i != j) implies (q[i] != C or q[j] != C))' type='safety' />
	
	<property equn='forall i j ((i != j and q[i] == C) implies (q[j] != C))' type='safety' />
-->
	
	<property equn='false' type='safety' />



</holism>
