<?xml version="1.0"?>

<holism>
	<parameter name='N' type='index' comment='number of processes in the system' />
	
	<variable name='x' initially='x == 1' type='integer' update_type='Discrete' comment='lock' />
	
	<assumption equn='N &gt;= 2' comment='' />

	<automaton name='mux-sem'>
<!--		<initial equn='forall i ( x == 1 )' />
-->

		<mode id='0' name='idle' initial='True'>
		</mode>

		<mode id='1' name='start' initial='False'>
		</mode>
		
		<mode id='2' name='cs' initial='False'>
		</mode>
		
		<!--
		<mode id='3' name='rem' initial='False'>
		</mode>
		-->
		
		<transition source='idle' destination='start'>
		</transition>
		
		<transition source='start' destination='cs'>
			<guard equn='x == 1' />
			<action equn='x&apos; = 0'/>
		</transition>
		
		<transition source='cs' destination='idle'>
			<action equn='x&apos; = 1'/>
		</transition>
		
		<!--<transition source='rem' destination='idle'>
			<action equn='x&apos; = 1'/>
		</transition>
		-->
	</automaton>


	<property equn='true' type='safety' />
	
	<!-- <property equn='forall i j ((i != j) implies ( (q[i] == C or q[i] == E) implies ((x == 0) and (q[j] == I or q[j] == T)) ) and ( (q[j] == C or q[j] == E) implies ((x == 0) and (q[i] == I or q[i] == T) )) )' type='safety' comment='inductive invariant that implies mutual exclusion' /> -->

	<!-- <property equn='forall i ((q[i] == C or q[i] == E) iff (x == 0))' type='safety' comment='not inductive' /> -->
	
	<!-- generated by invisible invariants -->
	<!-- <property equn='forall i j ((i != j) implies ( ((x == 1) implies ((q[i] == I or q[i] == T)) and (q[j] != C and q[j] != E)) and ((x == 0) implies ((q[i] == C or q[i] == E) implies (q[j] != C and q[j] != E))) ))' type='safety' comment='inductive invariant that implies mutual exclusion' /> -->
	
	
	<property equn='forall i j ((i != j) implies (q[i] != cs or q[j] != cs))' type='safety' />
<!--
	<property equn='forall i j ((i != j) implies (q[i] != C or q[j] != C))' type='safety' />
	<property equn='forall i j ((i != j and q[i] == C) implies (q[j] != C))' type='safety' />
-->
	
	
	
	
	<!-- generated by split invariants (not inductive, from N = 2) -->
<!-- 
	<property equn='forall i j ((i != j) implies 
               ((q[j] == cs and x == 0 and start == q[i]) or
                (q[j] == idle and x == 1 and start == q[i]) or
                (q[i] == idle and x == 1 and idle == q[j]) or
                (q[i] == start and idle == q[j] and x == 1) or
                (q[i] == cs and x == 0 and start == q[j]) or
                (q[i] == start and cs == q[j] and x == 0) or
                (q[i] == idle and x == 1 and start == q[j]) or
                (q[j] == idle and x == 1 and idle == q[i]) or
                (q[j] == start and idle == q[i] and x == 1) or
                (q[i] == cs and x == 0 and idle == q[j]) or
                (q[j] == start and start == q[i] and x == 1) or
                (q[i] == start and start == q[j] and x == 1) or
                (q[j] == cs and x == 0 and idle == q[i]) or
                (q[j] == start and cs == q[i] and x == 0)))' type='safety' />
-->


<!-- generated by split invariants from N = 2 
	<property format='smt' type='safety' equn='(forall ((i Int) (j Int))
  (let ((a!1 (not (and (&gt;= i 1) (&lt;= i N) (&gt;= j 1) (&lt;= j N) (not (= i j))))))
    (or a!1
        (and (= (q i) start) (= idle (q j)) (= x 1))
        (and (= (q i) cs) (= idle (q j)) (= x 0))
        (and (= (q i) start) (= start (q j)) (= x 1))
        (and (= (q i) idle) (= idle (q j)) (= x 1))
        (and (= (q i) cs) (= start (q j)) (= x 0))
        (and (= (q i) start) (= cs (q j)) (= x 0))
        (and (= (q i) start) (= idle (q j)) (= x 0))
        (and (= (q i) idle) (= start (q j)) (= x 1))
        (and (= (q i) start) (= start (q j)) (= x 0))
        (and (= (q j) start) (= idle (q i)) (= x 1))
        (and (= (q j) start) (= start (q i)) (= x 1))
        (and (= (q j) cs) (= idle (q i)) (= x 0))
        (and (= (q j) start) (= cs (q i)) (= x 0))
        (and (= (q j) cs) (= start (q i)) (= x 0))
        (and (= (q j) idle) (= idle (q i)) (= x 1))
        (and (= (q j) start) (= idle (q i)) (= x 0))
        (and (= (q j) idle) (= start (q i)) (= x 1))
        (and (= (q j) start) (= start (q i)) (= x 0))
        (and (= idle (q i)) (= idle (q j)) (= x 1))
        (and (= idle (q i)) (= idle (q j)) (= x 0))
        (and (= start (q i)) (= idle (q j)) (= x 1))
        (and (= start (q i)) (= idle (q j)) (= x 0))
        (and (= idle (q i)) (= start (q j)) (= x 1))
        (and (= idle (q i)) (= start (q j)) (= x 0))
        (and (= cs (q i)) (= idle (q j)) (= x 0))
        (and (= start (q i)) (= start (q j)) (= x 1))
        (and (= start (q i)) (= start (q j)) (= x 0))
        (and (= idle (q i)) (= cs (q j)) (= x 0))
        (and (= cs (q i)) (= start (q j)) (= x 0))
        (and (= start (q i)) (= cs (q j)) (= x 0)))))' />
-->

<!-- generated by split invariants (is inductive, from N = 3) 
	<property format='smt' type='safety' equn='(forall ((i Int) (j Int))
  (let ((a!1 (or (and (= (q i) start) (= idle (q j)) (= x 1))
                 (and (= (q i) cs) (= idle (q j)) (= x 0))
                 (and (= (q i) start) (= start (q j)) (= x 1))
                 (and (= (q i) idle) (= idle (q j)) (= x 1))
                 (and (= (q i) cs) (= start (q j)) (= x 0))
                 (and (= (q i) start) (= cs (q j)) (= x 0))
                 (and (= (q i) start) (= idle (q j)) (= x 0))
                 (and (= (q i) idle) (= start (q j)) (= x 1))
                 (and (= (q i) start) (= start (q j)) (= x 0))
                 (and (= (q j) start) (= idle (q i)) (= x 1))
                 (and (= (q j) start) (= start (q i)) (= x 1))
                 (and (= (q j) cs) (= idle (q i)) (= x 0))
                 (and (= (q j) start) (= cs (q i)) (= x 0))
                 (and (= (q j) cs) (= start (q i)) (= x 0))
                 (and (= (q j) start) (= idle (q i)) (= x 0))
                 (and (= (q j) idle) (= start (q i)) (= x 1))
                 (and (= (q j) start) (= start (q i)) (= x 0))
                 (and (= idle (q i)) (= idle (q j)) (= x 1))
                 (and (= idle (q i)) (= idle (q j)) (= x 0))
                 (and (= start (q i)) (= idle (q j)) (= x 1))
                 (and (= start (q i)) (= idle (q j)) (= x 0))
                 (and (= idle (q i)) (= start (q j)) (= x 1))
                 (and (= idle (q i)) (= start (q j)) (= x 0))
                 (and (= cs (q i)) (= idle (q j)) (= x 0))
                 (and (= start (q i)) (= start (q j)) (= x 1))
                 (and (= start (q i)) (= start (q j)) (= x 0))
                 (and (= idle (q i)) (= cs (q j)) (= x 0))
                 (and (= cs (q i)) (= start (q j)) (= x 0))
                 (and (= start (q i)) (= cs (q j)) (= x 0)))))
    (=&gt; (and (&gt;= i 1) (&lt;= i N) (&gt;= j 1) (&lt;= j N) (distinct i j)) a!1)))' />
-->
	
<!--
	<property format='smt' type='safety' equn='(forall ((i Int) (j Int))
  (let ((a!1 (or (not (= (q i) idle))
                 (not (= (q j) idle))
                 (not (= x 1))))
        (a!2 (or (not (= (q i) start)) (not (= idle (q j))) (not (= x 1))))
        (a!3 (or (not (= (q j) start)) (not (= idle (q i))) (not (= x 1))))
        (a!4 (or (not (= idle (q i))) (not (= idle (q j))) (not (= x 1))))
        (a!5 (or (not (= (q i) cs)) (not (= idle (q j))) (not (= x 0))))
        (a!6 (or (not (= (q j) start)) (not (= start (q i))) (not (= x 1))))
        (a!7 (or (not (= start (q i))) (not (= idle (q j))) (not (= x 1))))
        (a!8 (or (not (= (q i) start)) (not (= start (q j))) (not (= x 1))))
        (a!9 (or (not (= (q j) cs)) (not (= idle (q i))) (not (= x 0))))
        (a!10 (or (not (= idle (q i))) (not (= start (q j))) (not (= x 1))))
        (a!11 (or (not (= idle (q i))) (not (= idle (q j))) (not (= x 0))))
        (a!12 (or (not (= start (q i))) (not (= idle (q j))) (not (= x 0))))
        (a!13 (or (not (= idle (q i))) (not (= start (q j))) (not (= x 0))))
        (a!14 (or (not (= (q i) idle)) (not (= idle (q j))) (not (= x 1))))
        (a!15 (or (not (= (q j) start)) (not (= cs (q i))) (not (= x 0))))
        (a!16 (or (not (= cs (q i))) (not (= idle (q j))) (not (= x 0))))
        (a!17 (or (not (= (q i) cs)) (not (= start (q j))) (not (= x 0))))
        (a!18 (or (not (= (q j) cs)) (not (= start (q i))) (not (= x 0))))
        (a!19 (or (not (= start (q i))) (not (= start (q j))) (not (= x 1))))
        (a!20 (or (not (= start (q i))) (not (= start (q j))) (not (= x 0))))
        (a!21 (or (not (= (q i) start)) (not (= cs (q j))) (not (= x 0))))
        (a!22 (or (not (= (q j) idle)) (not (= idle (q i))) (not (= x 1))))
        (a!23 (or (not (= idle (q i))) (not (= cs (q j))) (not (= x 0))))
        (a!24 (or (not (= (q i) start)) (not (= idle (q j))) (not (= x 0))))
        (a!25 (or (not (= (q j) start)) (not (= idle (q i))) (not (= x 0))))
        (a!26 (or (not (= (q j) start)) (not (= start (q i))) (not (= x 0))))
        (a!27 (or (not (= (q i) start)) (not (= start (q j))) (not (= x 0))))
        (a!28 (or (not (= (q i) idle)) (not (= start (q j))) (not (= x 1))))
        (a!29 (or (not (= cs (q i))) (not (= start (q j))) (not (= x 0))))
        (a!30 (or (not (= (q j) idle)) (not (= start (q i))) (not (= x 1))))
        (a!31 (or (not (= start (q i))) (not (= cs (q j))) (not (= x 0)))))
    (implies (and (&gt;= i 1) (&lt;= i N) (&gt;= j 1) (&lt;= j N) (distinct i j))
        (or (not a!1)
            (not a!2)
            (not a!3)
            (not a!4)
            (not a!5)
            (not a!6)
            (not a!7)
            (not a!8)
            (not a!9)
            (not a!10)
            (not a!11)
            (not a!12)
            (not a!13)
            (not a!14)
            (not a!15)
            (not a!16)
            (not a!17)
            (not a!18)
            (not a!19)
            (not a!20)
            (not a!21)
            (not a!22)
            (not a!23)
            (not a!24)
            (not a!25)
            (not a!26)
            (not a!27)
            (not a!28)
            (not a!29)
            (not a!30)
            (not a!31)))))' />
-->
	

	<property equn='false' type='safety' />



</holism>
