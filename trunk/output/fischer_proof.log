File: C:\Users\tjohnson\Dropbox\Research\tools\phyea\repos\trunk\input\fischer_umeno_global_clock.xml

Attempting to prove the following properties as inductive invariants: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

(forall (i Int)
  (implies (and (>= i 1) (<= i N))
           (implies (= (q i) 2) (<= (last i) (+ now A)))))

(forall (i Int)
  (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))

(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))

(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                    (> (first i) (last j)))))

(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))

(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))



ASSUMPTIONS: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0))



Properties proved and used as assumption lemmas: 


Model for basic assumptions: 


A -> 1
N -> 2
g -> 0
B -> 2
g' -> 0
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
Unsat core:

Term:
(implies (and (and (and (forall (i Int)
                          (implies (and (>= i 1) (<= i N))
                                   (and (and (and (= (last i) A)
                                                  (= (first i) 0))
                                             (= g 0))
                                        (= now 0))))
                        (= now 0))
                   (= g 0))
              (forall (i Int) (or (= (q i) 0))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q i) 2) (<= (last i) (+ now A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (= now 0)
     (= g 0)
     (forall (x!36 Int)
       (or (not (>= x!36 1))
           (not (>= (+ N (* -1 x!36)) 0))
           (not (or (not (= (last x!36) A)) (not (= (first x!36) 0)))))
       :pat {(last x!36)}
       :pat {(first x!36)})
     (forall (x!38 Int) (= (q x!38) 0) :pat {(q x!38)})
     (>= x!40!42 1)
     (>= (+ N (* -1 x!40!42)) 0)
     (= (q x!40!42) 2)
     (not (>= (+ A (* -1 (last x!40!42))) 0))
     (<= g 0)
     (= (q x!40!42) 0)
     (>= (q x!40!42) 0)
     (<= (q x!40!42) 4)
     (>= (last x!40!42) 0)
     (<= (+ A (* -1 (last x!40!42))) 0)
     (not (= A (last x!40!42)))
     (not (or (not (= (last x!40!42) A)) (not (= (first x!40!42) 0))))
     (= (last x!40!42) A)
     (= (first x!40!42) 0))


unsat: proved claim
added eqs:            5
assert lower:         23
assert upper:         11
conflicts:            10
decisions:            8
del clause:           5
eq adapter:           2
final checks:         29
max generation:       1
mk clause:            10
offset eqs:           1
pivots:               16
propagations:         7
quant instantiations: 5
max. heap size:     1.41539 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N))
                (implies (= (q i) 2) (<= (last i) (+ now A)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 0) (= (q' h) 1))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!48!53 1)
     (>= (+ N (* -1 x!48!53)) 0)
     (= (q x!48!53) 0)
     (= (q' x!48!53) 1)
     (= (last x!48!53) (last' x!48!53))
     (= (first x!48!53) (first' x!48!53))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!48!53)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!51!54 1)
     (>= (+ N (* -1 x!51!54)) 0)
     (= (q' x!51!54) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!54)))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!48!53) 0)
     (<= (q x!48!53) 4)
     (>= (q' x!48!53) 0)
     (<= (q' x!48!53) 4)
     (>= (q' x!51!54) 0)
     (<= (q' x!51!54) 4)
     (>= (last' x!48!53) 0)
     (>= (last' x!51!54) 0)
     (>= (last x!48!53) 0)
     (>= (first' x!48!53) 0)
     (>= (first x!48!53) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!48!53) 0)
     (<= (q' x!48!53) 1)
     (>= (q' x!48!53) 1)
     (<= (q' x!51!54) 2)
     (>= (q' x!51!54) 2)
     (<= (+ (last x!48!53) (* -1 (last' x!48!53))) 0)
     (>= (+ (last x!48!53) (* -1 (last' x!48!53))) 0)
     (<= (+ (first x!48!53) (* -1 (first' x!48!53))) 0)
     (>= (+ (first x!48!53) (* -1 (first' x!48!53))) 0))


unsat: proved claim
add rows:             9
added eqs:            26
arith conflicts:      1
assert lower:         57
assert upper:         28
conflicts:            16
decisions:            21
del clause:           24
eq adapter:           13
final checks:         41
fixed eqs:            5
max generation:       2
mk clause:            34
offset eqs:           1
pivots:               34
propagations:         13
quant instantiations: 24
max. heap size:     1.53561 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N))
                (implies (= (q i) 2) (<= (last i) (+ now A)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!55!58 1)
     (>= (+ N (* -1 x!55!58)) 0)
     (= (q x!55!58) 1)
     (= (q' x!55!58) 1)
     (not (= g 0))
     (= (last x!55!58) (last' x!55!58))
     (= (first x!55!58) (first' x!55!58))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!55!58)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!51!59 1)
     (>= (+ N (* -1 x!51!59)) 0)
     (= (q' x!51!59) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!59)))) 0))
     (not (<= g 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!55!58) 0)
     (<= (q x!55!58) 4)
     (>= (q' x!55!58) 0)
     (<= (q' x!55!58) 4)
     (>= (q' x!51!59) 0)
     (<= (q' x!51!59) 4)
     (>= (last' x!55!58) 0)
     (>= (last' x!51!59) 0)
     (>= (last x!55!58) 0)
     (>= (first' x!55!58) 0)
     (>= (first x!55!58) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!55!58) 1)
     (>= (q x!55!58) 1)
     (<= (q' x!55!58) 1)
     (>= (q' x!55!58) 1)
     (<= (q' x!51!59) 2)
     (>= (q' x!51!59) 2)
     (= (last' x!55!58) (last x!55!58))
     (<= (+ (last' x!55!58) (* -1 (last x!55!58))) 0)
     (>= (+ (last' x!55!58) (* -1 (last x!55!58))) 0)
     (<= (+ (first x!55!58) (* -1 (first' x!55!58))) 0)
     (>= (+ (first x!55!58) (* -1 (first' x!55!58))) 0))


unsat: proved claim
add rows:             20
added eqs:            46
arith conflicts:      2
assert diseq:         1
assert lower:         87
assert upper:         43
conflicts:            19
decisions:            28
del clause:           50
eq adapter:           25
final checks:         44
fixed eqs:            10
max generation:       2
mk clause:            60
offset eqs:           1
pivots:               42
propagations:         20
quant instantiations: 43
max. heap size:     1.69643 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N))
                (implies (= (q i) 2) (<= (last i) (+ now A)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 2) (= g 0) (= (last' h) (+ now A)))
                 (and (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!60!63 1)
     (>= (+ N (* -1 x!60!63)) 0)
     (= (q x!60!63) 1)
     (= (q' x!60!63) 2)
     (= g 0)
     (= (+ A (+ now (* -1 (last' x!60!63)))) 0)
     (= (first x!60!63) (first' x!60!63))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!60!63)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!51!64 1)
     (>= (+ N (* -1 x!51!64)) 0)
     (= (q' x!51!64) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!64)))) 0))
     (<= g 0)
     (<= (+ A (+ now (* -1 (last' x!60!63)))) 0)
     (>= (+ A (+ now (* -1 (last' x!60!63)))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!60!63) 0)
     (<= (q x!60!63) 4)
     (>= (q' x!60!63) 0)
     (<= (q' x!60!63) 4)
     (>= (q' x!51!64) 0)
     (<= (q' x!51!64) 4)
     (>= (last' x!60!63) 0)
     (>= (last' x!51!64) 0)
     (>= (first' x!60!63) 0)
     (>= (first x!60!63) 0)
     (<= (q x!60!63) 1)
     (>= (q x!60!63) 1)
     (<= (q' x!60!63) 2)
     (>= (q' x!60!63) 2)
     (<= (q' x!51!64) 2)
     (>= (q' x!51!64) 2)
     (<= (+ (first x!60!63) (* -1 (first' x!60!63))) 0)
     (>= (+ (first x!60!63) (* -1 (first' x!60!63))) 0))


unsat: proved claim
add rows:             39
added eqs:            75
arith conflicts:      4
assert diseq:         1
assert lower:         117
assert upper:         61
conflicts:            22
decisions:            35
del clause:           79
eq adapter:           38
final checks:         47
fixed eqs:            17
max generation:       2
mk clause:            90
offset eqs:           4
pivots:               56
propagations:         31
quant instantiations: 61
max. heap size:     1.73534 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N))
                (implies (= (q i) 2) (<= (last i) (+ now A)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 2)
                      (= (q' h) 3)
                      (<= now (last h))
                      (>= now (last h))
                      (and (= g' h) (= (first' h) (+ now B))))
                 (and (= (last h) (last' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!65!68 1)
     (>= (+ N (* -1 x!65!68)) 0)
     (= (q x!65!68) 2)
     (= (q' x!65!68) 3)
     (<= (+ now (* -1 (last x!65!68))) 0)
     (>= (+ now (* -1 (last x!65!68))) 0)
     (= g' x!65!68)
     (= (+ B (+ now (* -1 (first' x!65!68)))) 0)
     (= (last x!65!68) (last' x!65!68))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!65!68)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!51!69 1)
     (>= (+ N (* -1 x!51!69)) 0)
     (= (q' x!51!69) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!69)))) 0))
     (<= (+ g' (* -1 x!65!68)) 0)
     (>= (+ g' (* -1 x!65!68)) 0)
     (<= (+ B (+ now (* -1 (first' x!65!68)))) 0)
     (>= (+ B (+ now (* -1 (first' x!65!68)))) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (+ A (+ now (* -1 (last x!65!68)))) 0)
     (>= (q x!65!68) 0)
     (<= (q x!65!68) 4)
     (>= (q' x!65!68) 0)
     (<= (q' x!65!68) 4)
     (>= (q' x!51!69) 0)
     (<= (q' x!51!69) 4)
     (>= (last x!65!68) 0)
     (>= (first' x!65!68) 0)
     (>= (last' x!65!68) 0)
     (>= (last' x!51!69) 0)
     (<= (q x!65!68) 2)
     (>= (q x!65!68) 2)
     (<= (q' x!65!68) 3)
     (>= (q' x!65!68) 3)
     (<= (q' x!51!69) 2)
     (>= (q' x!51!69) 2)
     (<= (+ (last x!65!68) (* -1 (last' x!65!68))) 0)
     (>= (+ (last x!65!68) (* -1 (last' x!65!68))) 0))


unsat: proved claim
add rows:             51
added eqs:            95
arith conflicts:      5
assert diseq:         1
assert lower:         147
assert upper:         77
conflicts:            25
decisions:            42
del clause:           107
eq adapter:           49
final checks:         50
fixed eqs:            22
max generation:       2
mk clause:            116
offset eqs:           5
pivots:               69
propagations:         39
quant instantiations: 79
max. heap size:     1.77382 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N))
                (implies (= (q i) 2) (<= (last i) (+ now A)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3)
                      (= (q' h) 1)
                      (and (not (= g h)) (>= now (first h)))
                      (= (first' h) 0))
                 (and (= (last h) (last' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!70!73 1)
     (>= (+ N (* -1 x!70!73)) 0)
     (= (q x!70!73) 3)
     (= (q' x!70!73) 1)
     (not (= g x!70!73))
     (>= (+ now (* -1 (first x!70!73))) 0)
     (= (first' x!70!73) 0)
     (= (last x!70!73) (last' x!70!73))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!70!73)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!51!74 1)
     (>= (+ N (* -1 x!51!74)) 0)
     (= (q' x!51!74) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!74)))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!70!73) 0)
     (<= (q x!70!73) 4)
     (>= (q' x!70!73) 0)
     (<= (q' x!70!73) 4)
     (>= (q' x!51!74) 0)
     (<= (q' x!51!74) 4)
     (>= (first x!70!73) 0)
     (>= (first' x!70!73) 0)
     (>= (last' x!70!73) 0)
     (>= (last' x!51!74) 0)
     (>= (last x!70!73) 0)
     (<= (q x!70!73) 3)
     (>= (q x!70!73) 3)
     (<= (q' x!70!73) 1)
     (>= (q' x!70!73) 1)
     (<= (q' x!51!74) 2)
     (>= (q' x!51!74) 2)
     (<= (first' x!70!73) 0)
     (<= (+ (last x!70!73) (* -1 (last' x!70!73))) 0)
     (>= (+ (last x!70!73) (* -1 (last' x!70!73))) 0))


unsat: proved claim
add rows:             65
added eqs:            113
arith conflicts:      6
assert diseq:         2
assert lower:         176
assert upper:         92
conflicts:            28
decisions:            49
del clause:           131
eq adapter:           61
final checks:         53
fixed eqs:            26
max generation:       2
mk clause:            143
offset eqs:           5
pivots:               80
propagations:         45
quant instantiations: 98
max. heap size:     1.84961 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N))
                (implies (= (q i) 2) (<= (last i) (+ now A)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3) (= (q' h) 4) (and (= g h) (>= now (first h))))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!75!78 1)
     (>= (+ N (* -1 x!75!78)) 0)
     (= (q x!75!78) 3)
     (= (q' x!75!78) 4)
     (= g x!75!78)
     (>= (+ now (* -1 (first x!75!78))) 0)
     (= (last x!75!78) (last' x!75!78))
     (= (first x!75!78) (first' x!75!78))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!75!78)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!51!79 1)
     (>= (+ N (* -1 x!51!79)) 0)
     (= (q' x!51!79) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!79)))) 0))
     (<= (+ g (* -1 x!75!78)) 0)
     (>= (+ g (* -1 x!75!78)) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!75!78) 0)
     (<= (q x!75!78) 4)
     (>= (q' x!75!78) 0)
     (<= (q' x!75!78) 4)
     (>= (q' x!51!79) 0)
     (<= (q' x!51!79) 4)
     (>= (first x!75!78) 0)
     (>= (last' x!75!78) 0)
     (>= (last' x!51!79) 0)
     (>= (last x!75!78) 0)
     (>= (first' x!75!78) 0)
     (<= (q x!75!78) 3)
     (>= (q x!75!78) 3)
     (>= (q' x!75!78) 4)
     (<= (q' x!51!79) 2)
     (>= (q' x!51!79) 2)
     (<= (+ (last x!75!78) (* -1 (last' x!75!78))) 0)
     (>= (+ (last x!75!78) (* -1 (last' x!75!78))) 0)
     (= (first' x!75!78) (first x!75!78))
     (<= (+ (first' x!75!78) (* -1 (first x!75!78))) 0)
     (>= (+ (first' x!75!78) (* -1 (first x!75!78))) 0))


unsat: proved claim
add rows:             81
added eqs:            132
arith conflicts:      7
assert diseq:         2
assert lower:         207
assert upper:         107
conflicts:            31
decisions:            56
del clause:           160
eq adapter:           73
final checks:         56
fixed eqs:            27
max generation:       2
mk clause:            170
offset eqs:           5
pivots:               91
propagations:         53
quant instantiations: 117
max. heap size:     1.91758 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N))
                (implies (= (q i) 2) (<= (last i) (+ now A)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!80!83 1)
     (>= (+ N (* -1 x!80!83)) 0)
     (= (q x!80!83) 4)
     (= (q' x!80!83) 0)
     (= g' 0)
     (= (last x!80!83) (last' x!80!83))
     (= (first x!80!83) (first' x!80!83))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!80!83)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!51!84 1)
     (>= (+ N (* -1 x!51!84)) 0)
     (= (q' x!51!84) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!84)))) 0))
     (<= g' 0)
     (>= (q x!80!83) 0)
     (<= (q x!80!83) 4)
     (>= (q' x!80!83) 0)
     (<= (q' x!80!83) 4)
     (>= (q' x!51!84) 0)
     (<= (q' x!51!84) 4)
     (>= (last' x!80!83) 0)
     (>= (last' x!51!84) 0)
     (>= (last x!80!83) 0)
     (>= (first' x!80!83) 0)
     (>= (first x!80!83) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!80!83) 4)
     (<= (q' x!80!83) 0)
     (<= (q' x!51!84) 2)
     (>= (q' x!51!84) 2)
     (= (last' x!80!83) (last x!80!83))
     (<= (+ (last' x!80!83) (* -1 (last x!80!83))) 0)
     (>= (+ (last' x!80!83) (* -1 (last x!80!83))) 0)
     (<= (+ (first x!80!83) (* -1 (first' x!80!83))) 0)
     (>= (+ (first x!80!83) (* -1 (first' x!80!83))) 0))


unsat: proved claim
add rows:             92
added eqs:            152
arith conflicts:      8
assert diseq:         2
assert lower:         234
assert upper:         121
conflicts:            34
decisions:            63
del clause:           180
eq adapter:           84
final checks:         59
fixed eqs:            31
max generation:       2
mk clause:            190
offset eqs:           6
pivots:               101
propagations:         58
quant instantiations: 136
max. heap size:     1.92684 Mbytes
Unsat core:

Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!94!99 0)
     (forall (x!96 Real) (x!95 Int)
       (or (not (>= x!96 0))
           (not (<= (+ x!96 (* -1 x!94!99)) 0))
           (not (>= x!95 1))
           (not (>= (+ N (* -1 x!95)) 0))
           (not (or (not (or (not (= (q x!95) 0))
                             (= (+ now (+ (* -1 now') x!94!99)) 0)))
                    (not (or (not (= (q x!95) 1))
                             (= (+ now (+ (* -1 now') x!94!99)) 0)))
                    (not (or (not (= (q x!95) 2))
                             (not (or (not (<= (+ now
                                                  (+ x!96 (* -1 (last x!95))))
                                               0))
                                      (not (or (not (>= (+ now
                                                           (+ x!96
                                                              (* -1 (last x!95))))
                                                        0))
                                               (= x!94!99 x!96)))
                                      (not (= (+ now (+ (* -1 now') x!94!99)) 0))))))
                    (not (or (not (= (q x!95) 3))
                             (= (+ now (+ (* -1 now') x!94!99)) 0)))
                    (not (or (not (= (q x!95) 4))
                             (= (+ now (+ (* -1 now') x!94!99)) 0)))
                    (not (= (q x!95) (q' x!95)))
                    (not (= (last x!95) (last' x!95)))
                    (not (= (first x!95) (first' x!95)))
                    (not (= g g'))))))
     (>= x!51!100 1)
     (>= (+ N (* -1 x!51!100)) 0)
     (= (q' x!51!100) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!100)))) 0))
     (>= (q' x!51!100) 0)
     (<= (q' x!51!100) 4)
     (>= (last' x!51!100) 0)
     (<= (q' x!51!100) 2)
     (>= (q' x!51!100) 2))


unsat: proved claim
add rows:             102
added eqs:            167
arith conflicts:      9
assert diseq:         11
assert lower:         259
assert upper:         138
conflicts:            38
decisions:            135
del clause:           279
eq adapter:           95
final checks:         69
fixed eqs:            33
max generation:       2
mk clause:            321
offset eqs:           6
pivots:               122
propagations:         140
quant instantiations: 146
restarts:             1
max. heap size:     2.27613 Mbytes
Unsat core:



Property was an inductive invariant! Property checked was: 
(forall (i Int)
  (implies (and (>= i 1) (<= i N))
           (implies (= (q i) 2) (<= (last i) (+ now A)))))


ASSUMPTIONS: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)}))



Properties proved and used as assumption lemmas: 


(forall (i Int)
  (implies (and (>= i 1) (<= i N))
           (implies (= (q i) 2) (<= (last i) (+ now A)))))


Model for basic assumptions: 


A -> 1
N -> 2
g -> 0
B -> 2
now -> 1
g' -> 0
now' -> 1
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
Unsat core:

Term:
(implies (and (and (and (forall (i Int)
                          (implies (and (>= i 1) (<= i N))
                                   (and (and (and (= (last i) A)
                                                  (= (first i) 0))
                                             (= g 0))
                                        (= now 0))))
                        (= now 0))
                   (= g 0))
              (forall (i Int) (or (= (q i) 0))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q i) 2) (<= now (last i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (= now 0)
     (= g 0)
     (forall (x!36 Int)
       (or (not (>= x!36 1))
           (not (>= (+ N (* -1 x!36)) 0))
           (not (or (not (= (last x!36) A)) (not (= (first x!36) 0)))))
       :pat {(last x!36)}
       :pat {(first x!36)})
     (forall (x!38 Int) (= (q x!38) 0) :pat {(q x!38)})
     (>= x!144!146 1)
     (>= (+ N (* -1 x!144!146)) 0)
     (= (q x!144!146) 2)
     (not (>= (last x!144!146) 0))
     (<= g 0)
     (= (q x!144!146) 0)
     (>= (+ A (+ now (* -1 (last x!144!146)))) 0)
     (>= (q x!144!146) 0)
     (<= (q x!144!146) 4)
     (not (or (not (= (last x!144!146) A)) (not (= (first x!144!146) 0)))))


unsat: proved claim
add rows:             107
added eqs:            171
arith conflicts:      9
assert diseq:         11
assert lower:         263
assert upper:         141
conflicts:            40
decisions:            135
del clause:           321
eq adapter:           97
final checks:         74
fixed eqs:            33
max generation:       2
mk clause:            330
offset eqs:           7
pivots:               128
propagations:         141
quant instantiations: 152
restarts:             1
max. heap size:     2.38205 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 0) (= (q' h) 1))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!48!151 1)
     (>= (+ N (* -1 x!48!151)) 0)
     (= (q x!48!151) 0)
     (= (q' x!48!151) 1)
     (= (last x!48!151) (last' x!48!151))
     (= (first x!48!151) (first' x!48!151))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!48!151)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!149!152 1)
     (>= (+ N (* -1 x!149!152)) 0)
     (= (q' x!149!152) 2)
     (not (<= (+ now' (* -1 (last' x!149!152))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!48!151) 0)
     (<= (q x!48!151) 4)
     (>= (q' x!48!151) 0)
     (<= (q' x!48!151) 4)
     (>= (+ A (+ now' (* -1 (last' x!149!152)))) 0)
     (>= (q' x!149!152) 0)
     (<= (q' x!149!152) 4)
     (>= (last' x!48!151) 0)
     (>= (last' x!149!152) 0)
     (>= (last x!48!151) 0)
     (>= (first' x!48!151) 0)
     (>= (first x!48!151) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!48!151) 0)
     (<= (+ (last x!48!151) (* -1 (last' x!48!151))) 0)
     (>= (+ (last x!48!151) (* -1 (last' x!48!151))) 0)
     (<= (q' x!48!151) 1)
     (>= (q' x!48!151) 1)
     (<= (q' x!149!152) 2)
     (>= (q' x!149!152) 2)
     (<= (+ (first x!48!151) (* -1 (first' x!48!151))) 0)
     (>= (+ (first x!48!151) (* -1 (first' x!48!151))) 0))


unsat: proved claim
add rows:             116
added eqs:            192
arith conflicts:      10
assert diseq:         11
assert lower:         297
assert upper:         156
conflicts:            44
decisions:            136
del clause:           342
eq adapter:           108
final checks:         80
fixed eqs:            38
max generation:       2
mk clause:            354
offset eqs:           7
pivots:               140
propagations:         147
quant instantiations: 175
restarts:             1
max. heap size:     2.39859 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!55!153 1)
     (>= (+ N (* -1 x!55!153)) 0)
     (= (q x!55!153) 1)
     (= (q' x!55!153) 1)
     (not (= g 0))
     (= (last x!55!153) (last' x!55!153))
     (= (first x!55!153) (first' x!55!153))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!55!153)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!149!154 1)
     (>= (+ N (* -1 x!149!154)) 0)
     (= (q' x!149!154) 2)
     (not (<= (+ now' (* -1 (last' x!149!154))) 0))
     (not (<= g 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!55!153) 0)
     (<= (q x!55!153) 4)
     (>= (q' x!55!153) 0)
     (<= (q' x!55!153) 4)
     (>= (+ A (+ now' (* -1 (last' x!149!154)))) 0)
     (>= (q' x!149!154) 0)
     (<= (q' x!149!154) 4)
     (>= (last' x!55!153) 0)
     (>= (last' x!149!154) 0)
     (>= (last x!55!153) 0)
     (>= (first' x!55!153) 0)
     (>= (first x!55!153) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!55!153) 1)
     (>= (q x!55!153) 1)
     (<= (+ (last x!55!153) (* -1 (last' x!55!153))) 0)
     (>= (+ (last x!55!153) (* -1 (last' x!55!153))) 0)
     (<= (q' x!55!153) 1)
     (>= (q' x!55!153) 1)
     (<= (q' x!149!154) 2)
     (>= (q' x!149!154) 2)
     (<= (+ (first x!55!153) (* -1 (first' x!55!153))) 0)
     (>= (+ (first x!55!153) (* -1 (first' x!55!153))) 0))


unsat: proved claim
add rows:             128
added eqs:            212
arith conflicts:      11
assert diseq:         12
assert lower:         327
assert upper:         171
conflicts:            46
decisions:            137
del clause:           369
eq adapter:           120
final checks:         80
fixed eqs:            43
max generation:       2
mk clause:            381
offset eqs:           7
pivots:               147
propagations:         154
quant instantiations: 198
restarts:             1
max. heap size:     2.40022 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 2) (= g 0) (= (last' h) (+ now A)))
                 (and (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!60!155 1)
     (>= (+ N (* -1 x!60!155)) 0)
     (= (q x!60!155) 1)
     (= (q' x!60!155) 2)
     (= g 0)
     (= (+ A (+ now (* -1 (last' x!60!155)))) 0)
     (= (first x!60!155) (first' x!60!155))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!60!155)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!149!156 1)
     (>= (+ N (* -1 x!149!156)) 0)
     (= (q' x!149!156) 2)
     (not (<= (+ now' (* -1 (last' x!149!156))) 0))
     (<= g 0)
     (<= (+ A (+ now (* -1 (last' x!60!155)))) 0)
     (>= (+ A (+ now (* -1 (last' x!60!155)))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!60!155) 0)
     (<= (q x!60!155) 4)
     (>= (+ A (+ now' (* -1 (last' x!60!155)))) 0)
     (>= (q' x!60!155) 0)
     (<= (q' x!60!155) 4)
     (>= (+ A (+ now' (* -1 (last' x!149!156)))) 0)
     (>= (q' x!149!156) 0)
     (<= (q' x!149!156) 4)
     (>= (last' x!60!155) 0)
     (>= (last' x!149!156) 0)
     (>= (first' x!60!155) 0)
     (>= (first x!60!155) 0)
     (<= (q x!60!155) 1)
     (>= (q x!60!155) 1)
     (<= (q' x!60!155) 2)
     (>= (q' x!60!155) 2)
     (<= (q' x!149!156) 2)
     (>= (q' x!149!156) 2)
     (<= (+ (first x!60!155) (* -1 (first' x!60!155))) 0)
     (>= (+ (first x!60!155) (* -1 (first' x!60!155))) 0))


unsat: proved claim
add rows:             145
added eqs:            242
arith conflicts:      13
assert diseq:         12
assert lower:         358
assert upper:         189
conflicts:            48
decisions:            138
del clause:           399
eq adapter:           133
final checks:         80
fixed eqs:            51
max generation:       2
mk clause:            411
offset eqs:           10
pivots:               157
propagations:         165
quant instantiations: 220
restarts:             1
max. heap size:     2.4228 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 2)
                      (= (q' h) 3)
                      (<= now (last h))
                      (>= now (last h))
                      (and (= g' h) (= (first' h) (+ now B))))
                 (and (= (last h) (last' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!65!157 1)
     (>= (+ N (* -1 x!65!157)) 0)
     (= (q x!65!157) 2)
     (= (q' x!65!157) 3)
     (<= (+ now (* -1 (last x!65!157))) 0)
     (>= (+ now (* -1 (last x!65!157))) 0)
     (= g' x!65!157)
     (= (+ B (+ now (* -1 (first' x!65!157)))) 0)
     (= (last x!65!157) (last' x!65!157))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!65!157)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!149!158 1)
     (>= (+ N (* -1 x!149!158)) 0)
     (= (q' x!149!158) 2)
     (not (<= (+ now' (* -1 (last' x!149!158))) 0))
     (<= (+ g' (* -1 x!65!157)) 0)
     (>= (+ g' (* -1 x!65!157)) 0)
     (<= (+ B (+ now (* -1 (first' x!65!157)))) 0)
     (>= (+ B (+ now (* -1 (first' x!65!157)))) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (+ A (+ now (* -1 (last x!65!157)))) 0)
     (>= (q x!65!157) 0)
     (<= (q x!65!157) 4)
     (>= (q' x!65!157) 0)
     (<= (q' x!65!157) 4)
     (>= (+ A (+ now' (* -1 (last' x!149!158)))) 0)
     (>= (q' x!149!158) 0)
     (<= (q' x!149!158) 4)
     (>= (last x!65!157) 0)
     (>= (first' x!65!157) 0)
     (>= (last' x!65!157) 0)
     (>= (last' x!149!158) 0)
     (<= (q x!65!157) 2)
     (>= (q x!65!157) 2)
     (= (last' x!65!157) (last x!65!157))
     (<= (+ (last' x!65!157) (* -1 (last x!65!157))) 0)
     (>= (+ (last' x!65!157) (* -1 (last x!65!157))) 0)
     (<= (q' x!65!157) 3)
     (>= (q' x!65!157) 3)
     (<= (q' x!149!158) 2)
     (>= (q' x!149!158) 2)
     (>= (+ A (+ now' (* -1 (last' x!65!157)))) 0))


unsat: proved claim
add rows:             162
added eqs:            266
arith conflicts:      14
assert diseq:         12
assert lower:         389
assert upper:         205
bound prop:           1
conflicts:            50
decisions:            139
del clause:           429
eq adapter:           144
final checks:         80
fixed eqs:            56
max generation:       2
mk clause:            438
offset eqs:           14
pivots:               170
propagations:         173
quant instantiations: 242
restarts:             1
max. heap size:     2.42329 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3)
                      (= (q' h) 1)
                      (and (not (= g h)) (>= now (first h)))
                      (= (first' h) 0))
                 (and (= (last h) (last' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!70!159 1)
     (>= (+ N (* -1 x!70!159)) 0)
     (= (q x!70!159) 3)
     (= (q' x!70!159) 1)
     (not (= g x!70!159))
     (>= (+ now (* -1 (first x!70!159))) 0)
     (= (first' x!70!159) 0)
     (= (last x!70!159) (last' x!70!159))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!70!159)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!149!160 1)
     (>= (+ N (* -1 x!149!160)) 0)
     (= (q' x!149!160) 2)
     (not (<= (+ now' (* -1 (last' x!149!160))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!70!159) 0)
     (<= (q x!70!159) 4)
     (>= (q' x!70!159) 0)
     (<= (q' x!70!159) 4)
     (>= (+ A (+ now' (* -1 (last' x!149!160)))) 0)
     (>= (q' x!149!160) 0)
     (<= (q' x!149!160) 4)
     (>= (first x!70!159) 0)
     (>= (first' x!70!159) 0)
     (>= (last' x!70!159) 0)
     (>= (last' x!149!160) 0)
     (>= (last x!70!159) 0)
     (<= (q x!70!159) 3)
     (>= (q x!70!159) 3)
     (<= (+ (last x!70!159) (* -1 (last' x!70!159))) 0)
     (>= (+ (last x!70!159) (* -1 (last' x!70!159))) 0)
     (<= (q' x!70!159) 1)
     (>= (q' x!70!159) 1)
     (<= (q' x!149!160) 2)
     (>= (q' x!149!160) 2)
     (<= (first' x!70!159) 0))


unsat: proved claim
add rows:             177
added eqs:            284
arith conflicts:      15
assert diseq:         13
assert lower:         418
assert upper:         220
bound prop:           1
conflicts:            52
decisions:            140
del clause:           452
eq adapter:           156
final checks:         80
fixed eqs:            60
max generation:       2
mk clause:            466
offset eqs:           14
pivots:               182
propagations:         179
quant instantiations: 265
restarts:             1
max. heap size:     2.42329 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3) (= (q' h) 4) (and (= g h) (>= now (first h))))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!75!161 1)
     (>= (+ N (* -1 x!75!161)) 0)
     (= (q x!75!161) 3)
     (= (q' x!75!161) 4)
     (= g x!75!161)
     (>= (+ now (* -1 (first x!75!161))) 0)
     (= (last x!75!161) (last' x!75!161))
     (= (first x!75!161) (first' x!75!161))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!75!161)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!149!162 1)
     (>= (+ N (* -1 x!149!162)) 0)
     (= (q' x!149!162) 2)
     (not (<= (+ now' (* -1 (last' x!149!162))) 0))
     (<= (+ g (* -1 x!75!161)) 0)
     (>= (+ g (* -1 x!75!161)) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!75!161) 0)
     (<= (q x!75!161) 4)
     (>= (q' x!75!161) 0)
     (<= (q' x!75!161) 4)
     (>= (+ A (+ now' (* -1 (last' x!149!162)))) 0)
     (>= (q' x!149!162) 0)
     (<= (q' x!149!162) 4)
     (>= (first x!75!161) 0)
     (>= (last' x!75!161) 0)
     (>= (last' x!149!162) 0)
     (>= (last x!75!161) 0)
     (>= (first' x!75!161) 0)
     (<= (q x!75!161) 3)
     (>= (q x!75!161) 3)
     (= (last' x!75!161) (last x!75!161))
     (<= (+ (last' x!75!161) (* -1 (last x!75!161))) 0)
     (>= (+ (last' x!75!161) (* -1 (last x!75!161))) 0)
     (>= (q' x!75!161) 4)
     (<= (q' x!149!162) 2)
     (>= (q' x!149!162) 2)
     (= (first' x!75!161) (first x!75!161))
     (<= (+ (first' x!75!161) (* -1 (first x!75!161))) 0)
     (>= (+ (first' x!75!161) (* -1 (first x!75!161))) 0))


unsat: proved claim
add rows:             192
added eqs:            304
arith conflicts:      16
assert diseq:         13
assert lower:         449
assert upper:         235
bound prop:           1
conflicts:            54
decisions:            141
del clause:           482
eq adapter:           168
final checks:         80
fixed eqs:            61
max generation:       2
mk clause:            494
offset eqs:           14
pivots:               192
propagations:         187
quant instantiations: 288
restarts:             1
max. heap size:     2.42329 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!80!163 1)
     (>= (+ N (* -1 x!80!163)) 0)
     (= (q x!80!163) 4)
     (= (q' x!80!163) 0)
     (= g' 0)
     (= (last x!80!163) (last' x!80!163))
     (= (first x!80!163) (first' x!80!163))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!80!163)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!149!164 1)
     (>= (+ N (* -1 x!149!164)) 0)
     (= (q' x!149!164) 2)
     (not (<= (+ now' (* -1 (last' x!149!164))) 0))
     (<= g' 0)
     (>= (q x!80!163) 0)
     (<= (q x!80!163) 4)
     (>= (q' x!80!163) 0)
     (<= (q' x!80!163) 4)
     (>= (+ A (+ now' (* -1 (last' x!149!164)))) 0)
     (>= (q' x!149!164) 0)
     (<= (q' x!149!164) 4)
     (>= (last' x!80!163) 0)
     (>= (last' x!149!164) 0)
     (>= (last x!80!163) 0)
     (>= (first' x!80!163) 0)
     (>= (first x!80!163) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!80!163) 4)
     (<= (+ (last x!80!163) (* -1 (last' x!80!163))) 0)
     (>= (+ (last x!80!163) (* -1 (last' x!80!163))) 0)
     (<= (q' x!80!163) 0)
     (<= (q' x!149!164) 2)
     (>= (q' x!149!164) 2)
     (<= (+ (first x!80!163) (* -1 (first' x!80!163))) 0)
     (>= (+ (first x!80!163) (* -1 (first' x!80!163))) 0))


unsat: proved claim
add rows:             204
added eqs:            323
arith conflicts:      17
assert diseq:         13
assert lower:         476
assert upper:         249
bound prop:           1
conflicts:            56
decisions:            142
del clause:           503
eq adapter:           179
final checks:         80
fixed eqs:            65
max generation:       2
mk clause:            515
offset eqs:           15
pivots:               201
propagations:         192
quant instantiations: 311
restarts:             1
max. heap size:     2.52339 Mbytes
Unsat core:

Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!94!165 0)
     (forall (x!96 Real) (x!95 Int)
       (or (not (>= x!96 0))
           (not (<= (+ x!96 (* -1 x!94!165)) 0))
           (not (>= x!95 1))
           (not (>= (+ N (* -1 x!95)) 0))
           (not (or (not (or (not (= (q x!95) 0))
                             (= (+ now (+ (* -1 now') x!94!165)) 0)))
                    (not (or (not (= (q x!95) 1))
                             (= (+ now (+ (* -1 now') x!94!165)) 0)))
                    (not (or (not (= (q x!95) 2))
                             (not (or (not (<= (+ now
                                                  (+ x!96 (* -1 (last x!95))))
                                               0))
                                      (not (or (not (>= (+ now
                                                           (+ x!96
                                                              (* -1 (last x!95))))
                                                        0))
                                               (= x!94!165 x!96)))
                                      (not (= (+ now (+ (* -1 now') x!94!165))
                                              0))))))
                    (not (or (not (= (q x!95) 3))
                             (= (+ now (+ (* -1 now') x!94!165)) 0)))
                    (not (or (not (= (q x!95) 4))
                             (= (+ now (+ (* -1 now') x!94!165)) 0)))
                    (not (= (q x!95) (q' x!95)))
                    (not (= (last x!95) (last' x!95)))
                    (not (= (first x!95) (first' x!95)))
                    (not (= g g'))))))
     (>= x!149!166 1)
     (>= (+ N (* -1 x!149!166)) 0)
     (= (q' x!149!166) 2)
     (not (<= (+ now' (* -1 (last' x!149!166))) 0))
     (>= (+ A (+ now' (* -1 (last' x!149!166)))) 0)
     (>= (q' x!149!166) 0)
     (<= (q' x!149!166) 4)
     (>= (last' x!149!166) 0)
     (<= (q' x!149!166) 2)
     (>= (q' x!149!166) 2))


unsat: proved claim
add rows:             213
added eqs:            334
arith conflicts:      18
assert diseq:         13
assert lower:         492
assert upper:         257
bound prop:           1
conflicts:            57
decisions:            142
del clause:           516
eq adapter:           185
final checks:         81
fixed eqs:            67
max generation:       2
mk clause:            558
offset eqs:           15
pivots:               208
propagations:         210
quant instantiations: 323
restarts:             2
max. heap size:     2.64752 Mbytes
Unsat core:



Property was an inductive invariant! Property checked was: 
(forall (i Int)
  (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))


ASSUMPTIONS: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)}))



Properties proved and used as assumption lemmas: 


(forall (i Int)
  (implies (and (>= i 1) (<= i N))
           (implies (= (q i) 2) (<= (last i) (+ now A)))))


(forall (i Int)
  (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))


Model for basic assumptions: 


A -> 1
N -> 2
g -> 0
B -> 2
now -> 1
g' -> 0
now' -> 1
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
Unsat core:

Term:
(implies (and (and (and (forall (i Int)
                          (implies (and (>= i 1) (<= i N))
                                   (and (and (and (= (last i) A)
                                                  (= (first i) 0))
                                             (= g 0))
                                        (= now 0))))
                        (= now 0))
                   (= g 0))
              (forall (i Int) (or (= (q i) 0))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (= now 0)
     (= g 0)
     (forall (x!36 Int)
       (or (not (>= x!36 1))
           (not (>= (+ N (* -1 x!36)) 0))
           (not (or (not (= (last x!36) A)) (not (= (first x!36) 0)))))
       :pat {(last x!36)}
       :pat {(first x!36)})
     (forall (x!38 Int) (= (q x!38) 0) :pat {(q x!38)})
     (>= x!0!216 1)
     (>= (+ N (* -1 x!0!216)) 0)
     (not (>= (last x!0!216) 0))
     (<= g 0)
     (not (or (not (= (last x!0!216) A)) (not (= (first x!0!216) 0)))))


unsat: proved claim
add rows:             214
added eqs:            336
arith conflicts:      18
assert diseq:         13
assert lower:         494
assert upper:         259
bound prop:           1
conflicts:            58
decisions:            142
del clause:           558
eq adapter:           187
final checks:         83
fixed eqs:            67
max generation:       2
mk clause:            569
offset eqs:           16
pivots:               212
propagations:         211
quant instantiations: 327
restarts:             2
max. heap size:     2.69707 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 0) (= (q' h) 1))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!48!221 1)
     (>= (+ N (* -1 x!48!221)) 0)
     (= (q x!48!221) 0)
     (= (q' x!48!221) 1)
     (= (last x!48!221) (last' x!48!221))
     (= (first x!48!221) (first' x!48!221))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!48!221)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!222 1)
     (>= (+ N (* -1 x!219!222)) 0)
     (not (<= (+ now' (* -1 (last' x!219!222))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!48!221) 0)
     (<= (q x!48!221) 4)
     (>= (q' x!48!221) 0)
     (<= (q' x!48!221) 4)
     (>= (last' x!48!221) 0)
     (not (= (q' x!219!222) 2))
     (>= (last' x!219!222) 0)
     (<= (+ now (* -1 (last x!48!221))) 0)
     (>= (last x!48!221) 0)
     (>= (first' x!48!221) 0)
     (>= (first x!48!221) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!48!221) 0)
     (<= (+ (last x!48!221) (* -1 (last' x!48!221))) 0)
     (>= (+ (last x!48!221) (* -1 (last' x!48!221))) 0)
     (<= (q' x!48!221) 1)
     (>= (q' x!48!221) 1)
     (<= (+ (first x!48!221) (* -1 (first' x!48!221))) 0)
     (>= (+ (first x!48!221) (* -1 (first' x!48!221))) 0)
     (>= (q' x!219!222) 0)
     (<= (q' x!219!222) 4)
     (<= (+ now' (* -1 (last' x!48!221))) 0))


unsat: proved claim
add rows:             225
added eqs:            357
arith conflicts:      19
assert diseq:         14
assert lower:         525
assert upper:         277
bound prop:           2
conflicts:            62
decisions:            144
del clause:           583
eq adapter:           198
final checks:         89
fixed eqs:            73
max generation:       2
mk clause:            596
offset eqs:           17
pivots:               227
propagations:         219
quant instantiations: 351
restarts:             2
max. heap size:     2.87951 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!55!223 1)
     (>= (+ N (* -1 x!55!223)) 0)
     (= (q x!55!223) 1)
     (= (q' x!55!223) 1)
     (not (= g 0))
     (= (last x!55!223) (last' x!55!223))
     (= (first x!55!223) (first' x!55!223))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!55!223)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!224 1)
     (>= (+ N (* -1 x!219!224)) 0)
     (not (<= (+ now' (* -1 (last' x!219!224))) 0))
     (not (<= g 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!55!223) 0)
     (<= (q x!55!223) 4)
     (>= (q' x!55!223) 0)
     (<= (q' x!55!223) 4)
     (>= (last' x!55!223) 0)
     (not (= (q' x!219!224) 2))
     (>= (last' x!219!224) 0)
     (<= (+ now (* -1 (last x!55!223))) 0)
     (>= (last x!55!223) 0)
     (>= (first' x!55!223) 0)
     (>= (first x!55!223) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!55!223) 1)
     (>= (q x!55!223) 1)
     (<= (+ (last x!55!223) (* -1 (last' x!55!223))) 0)
     (>= (+ (last x!55!223) (* -1 (last' x!55!223))) 0)
     (<= (q' x!55!223) 1)
     (>= (q' x!55!223) 1)
     (<= (+ (first x!55!223) (* -1 (first' x!55!223))) 0)
     (>= (+ (first x!55!223) (* -1 (first' x!55!223))) 0)
     (>= (q' x!219!224) 0)
     (<= (q' x!219!224) 4)
     (<= (+ now' (* -1 (last' x!55!223))) 0))


unsat: proved claim
add rows:             240
added eqs:            379
arith conflicts:      20
assert diseq:         16
assert lower:         552
assert upper:         295
bound prop:           3
conflicts:            64
decisions:            146
del clause:           613
eq adapter:           210
final checks:         89
fixed eqs:            79
max generation:       2
mk clause:            626
offset eqs:           18
pivots:               239
propagations:         228
quant instantiations: 375
restarts:             2
max. heap size:     2.87951 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 2) (= g 0) (= (last' h) (+ now A)))
                 (and (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!60!225 1)
     (>= (+ N (* -1 x!60!225)) 0)
     (= (q x!60!225) 1)
     (= (q' x!60!225) 2)
     (= g 0)
     (= (+ A (+ now (* -1 (last' x!60!225)))) 0)
     (= (first x!60!225) (first' x!60!225))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!60!225)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!226 1)
     (>= (+ N (* -1 x!219!226)) 0)
     (not (<= (+ now' (* -1 (last' x!219!226))) 0))
     (<= g 0)
     (<= (+ A (+ now (* -1 (last' x!60!225)))) 0)
     (>= (+ A (+ now (* -1 (last' x!60!225)))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!60!225) 0)
     (<= (q x!60!225) 4)
     (<= (+ now' (* -1 (last' x!60!225))) 0)
     (>= (+ A (+ now' (* -1 (last' x!60!225)))) 0)
     (>= (q' x!60!225) 0)
     (<= (q' x!60!225) 4)
     (>= (last' x!60!225) 0)
     (not (= (q' x!219!226) 2))
     (>= (last' x!219!226) 0)
     (>= (first' x!60!225) 0)
     (>= (first x!60!225) 0)
     (<= (q x!60!225) 1)
     (>= (q x!60!225) 1)
     (<= (q' x!60!225) 2)
     (>= (q' x!60!225) 2)
     (<= (+ (first x!60!225) (* -1 (first' x!60!225))) 0)
     (>= (+ (first x!60!225) (* -1 (first' x!60!225))) 0)
     (>= (q' x!219!226) 0)
     (<= (q' x!219!226) 4))


unsat: proved claim
add rows:             257
added eqs:            403
arith conflicts:      21
assert diseq:         17
assert lower:         578
assert upper:         313
bound prop:           3
conflicts:            66
decisions:            148
del clause:           643
eq adapter:           222
final checks:         89
fixed eqs:            86
max generation:       2
mk clause:            656
offset eqs:           21
pivots:               251
propagations:         239
quant instantiations: 397
restarts:             2
max. heap size:     2.87951 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 2)
                      (= (q' h) 3)
                      (<= now (last h))
                      (>= now (last h))
                      (and (= g' h) (= (first' h) (+ now B))))
                 (and (= (last h) (last' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!65!227 1)
     (>= (+ N (* -1 x!65!227)) 0)
     (= (q x!65!227) 2)
     (= (q' x!65!227) 3)
     (<= (+ now (* -1 (last x!65!227))) 0)
     (>= (+ now (* -1 (last x!65!227))) 0)
     (= g' x!65!227)
     (= (+ B (+ now (* -1 (first' x!65!227)))) 0)
     (= (last x!65!227) (last' x!65!227))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!65!227)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!228 1)
     (>= (+ N (* -1 x!219!228)) 0)
     (not (<= (+ now' (* -1 (last' x!219!228))) 0))
     (<= (+ g' (* -1 x!65!227)) 0)
     (>= (+ g' (* -1 x!65!227)) 0)
     (<= (+ B (+ now (* -1 (first' x!65!227)))) 0)
     (>= (+ B (+ now (* -1 (first' x!65!227)))) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (+ A (+ now (* -1 (last x!65!227)))) 0)
     (>= (q x!65!227) 0)
     (<= (q x!65!227) 4)
     (>= (q' x!65!227) 0)
     (<= (q' x!65!227) 4)
     (>= (last x!65!227) 0)
     (>= (first' x!65!227) 0)
     (>= (last' x!65!227) 0)
     (not (= (q' x!219!228) 2))
     (>= (last' x!219!228) 0)
     (<= (q x!65!227) 2)
     (>= (q x!65!227) 2)
     (= (last' x!65!227) (last x!65!227))
     (<= (+ (last' x!65!227) (* -1 (last x!65!227))) 0)
     (>= (+ (last' x!65!227) (* -1 (last x!65!227))) 0)
     (<= (q' x!65!227) 3)
     (>= (q' x!65!227) 3)
     (>= (q' x!219!228) 0)
     (<= (q' x!219!228) 4)
     (<= (+ now' (* -1 (last' x!65!227))) 0)
     (>= (+ A (+ now' (* -1 (last' x!65!227)))) 0))


unsat: proved claim
add rows:             273
added eqs:            429
arith conflicts:      22
assert diseq:         18
assert lower:         606
assert upper:         331
bound prop:           5
conflicts:            68
decisions:            150
del clause:           675
eq adapter:           233
final checks:         89
fixed eqs:            93
max generation:       2
mk clause:            686
offset eqs:           25
pivots:               264
propagations:         249
quant instantiations: 420
restarts:             2
max. heap size:     2.87951 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3)
                      (= (q' h) 1)
                      (and (not (= g h)) (>= now (first h)))
                      (= (first' h) 0))
                 (and (= (last h) (last' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!70!229 1)
     (>= (+ N (* -1 x!70!229)) 0)
     (= (q x!70!229) 3)
     (= (q' x!70!229) 1)
     (not (= g x!70!229))
     (>= (+ now (* -1 (first x!70!229))) 0)
     (= (first' x!70!229) 0)
     (= (last x!70!229) (last' x!70!229))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!70!229)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!230 1)
     (>= (+ N (* -1 x!219!230)) 0)
     (not (<= (+ now' (* -1 (last' x!219!230))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!70!229) 0)
     (<= (q x!70!229) 4)
     (>= (q' x!70!229) 0)
     (<= (q' x!70!229) 4)
     (>= (first x!70!229) 0)
     (>= (first' x!70!229) 0)
     (>= (last' x!70!229) 0)
     (not (= (q' x!219!230) 2))
     (>= (last' x!219!230) 0)
     (<= (+ now (* -1 (last x!70!229))) 0)
     (>= (last x!70!229) 0)
     (<= (q x!70!229) 3)
     (>= (q x!70!229) 3)
     (= (last' x!70!229) (last x!70!229))
     (<= (+ (last' x!70!229) (* -1 (last x!70!229))) 0)
     (>= (+ (last' x!70!229) (* -1 (last x!70!229))) 0)
     (<= (q' x!70!229) 1)
     (>= (q' x!70!229) 1)
     (<= (first' x!70!229) 0)
     (>= (q' x!219!230) 0)
     (<= (q' x!219!230) 4)
     (<= (+ now' (* -1 (last' x!70!229))) 0))


unsat: proved claim
add rows:             291
added eqs:            450
arith conflicts:      23
assert diseq:         20
assert lower:         632
assert upper:         349
bound prop:           6
conflicts:            70
decisions:            152
del clause:           702
eq adapter:           245
final checks:         89
fixed eqs:            98
max generation:       2
mk clause:            717
offset eqs:           26
pivots:               278
propagations:         257
quant instantiations: 444
restarts:             2
max. heap size:     2.87951 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3) (= (q' h) 4) (and (= g h) (>= now (first h))))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!75!231 1)
     (>= (+ N (* -1 x!75!231)) 0)
     (= (q x!75!231) 3)
     (= (q' x!75!231) 4)
     (= g x!75!231)
     (>= (+ now (* -1 (first x!75!231))) 0)
     (= (last x!75!231) (last' x!75!231))
     (= (first x!75!231) (first' x!75!231))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!75!231)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!232 1)
     (>= (+ N (* -1 x!219!232)) 0)
     (not (<= (+ now' (* -1 (last' x!219!232))) 0))
     (<= (+ g (* -1 x!75!231)) 0)
     (>= (+ g (* -1 x!75!231)) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!75!231) 0)
     (<= (q x!75!231) 4)
     (>= (q' x!75!231) 0)
     (<= (q' x!75!231) 4)
     (>= (first x!75!231) 0)
     (>= (last' x!75!231) 0)
     (not (= (q' x!219!232) 2))
     (>= (last' x!219!232) 0)
     (<= (+ now (* -1 (last x!75!231))) 0)
     (>= (last x!75!231) 0)
     (>= (first' x!75!231) 0)
     (<= (q x!75!231) 3)
     (>= (q x!75!231) 3)
     (<= (+ (last x!75!231) (* -1 (last' x!75!231))) 0)
     (>= (+ (last x!75!231) (* -1 (last' x!75!231))) 0)
     (>= (q' x!75!231) 4)
     (<= (+ (first x!75!231) (* -1 (first' x!75!231))) 0)
     (>= (+ (first x!75!231) (* -1 (first' x!75!231))) 0)
     (>= (q' x!219!232) 0)
     (<= (q' x!219!232) 4)
     (<= (+ now' (* -1 (last' x!75!231))) 0))


unsat: proved claim
add rows:             310
added eqs:            470
arith conflicts:      24
assert diseq:         21
assert lower:         660
assert upper:         367
bound prop:           7
conflicts:            72
decisions:            154
del clause:           735
eq adapter:           257
final checks:         89
fixed eqs:            100
max generation:       2
mk clause:            748
offset eqs:           27
pivots:               292
propagations:         267
quant instantiations: 468
restarts:             2
max. heap size:     2.87951 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!80!233 1)
     (>= (+ N (* -1 x!80!233)) 0)
     (= (q x!80!233) 4)
     (= (q' x!80!233) 0)
     (= g' 0)
     (= (last x!80!233) (last' x!80!233))
     (= (first x!80!233) (first' x!80!233))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!80!233)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!234 1)
     (>= (+ N (* -1 x!219!234)) 0)
     (not (<= (+ now' (* -1 (last' x!219!234))) 0))
     (<= g' 0)
     (>= (q x!80!233) 0)
     (<= (q x!80!233) 4)
     (>= (q' x!80!233) 0)
     (<= (q' x!80!233) 4)
     (>= (last' x!80!233) 0)
     (not (= (q' x!219!234) 2))
     (>= (last' x!219!234) 0)
     (<= (+ now (* -1 (last x!80!233))) 0)
     (>= (last x!80!233) 0)
     (>= (first' x!80!233) 0)
     (>= (first x!80!233) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!80!233) 4)
     (<= (+ (last x!80!233) (* -1 (last' x!80!233))) 0)
     (>= (+ (last x!80!233) (* -1 (last' x!80!233))) 0)
     (<= (q' x!80!233) 0)
     (<= (+ (first x!80!233) (* -1 (first' x!80!233))) 0)
     (>= (+ (first x!80!233) (* -1 (first' x!80!233))) 0)
     (>= (q' x!219!234) 0)
     (<= (q' x!219!234) 4)
     (<= (+ now' (* -1 (last' x!80!233))) 0))


unsat: proved claim
add rows:             326
added eqs:            491
arith conflicts:      25
assert diseq:         22
assert lower:         684
assert upper:         384
bound prop:           8
conflicts:            74
decisions:            156
del clause:           759
eq adapter:           268
final checks:         89
fixed eqs:            105
max generation:       2
mk clause:            772
offset eqs:           29
pivots:               304
propagations:         274
quant instantiations: 492
restarts:             2
max. heap size:     2.87951 Mbytes
Unsat core:

Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!94!235 0)
     (forall (x!96 Real) (x!95 Int)
       (or (not (>= x!96 0))
           (not (<= (+ x!96 (* -1 x!94!235)) 0))
           (not (>= x!95 1))
           (not (>= (+ N (* -1 x!95)) 0))
           (not (or (not (or (not (= (q x!95) 0))
                             (= (+ now (+ (* -1 now') x!94!235)) 0)))
                    (not (or (not (= (q x!95) 1))
                             (= (+ now (+ (* -1 now') x!94!235)) 0)))
                    (not (or (not (= (q x!95) 2))
                             (not (or (not (<= (+ now
                                                  (+ x!96 (* -1 (last x!95))))
                                               0))
                                      (not (or (not (>= (+ now
                                                           (+ x!96
                                                              (* -1 (last x!95))))
                                                        0))
                                               (= x!94!235 x!96)))
                                      (not (= (+ now (+ (* -1 now') x!94!235))
                                              0))))))
                    (not (or (not (= (q x!95) 3))
                             (= (+ now (+ (* -1 now') x!94!235)) 0)))
                    (not (or (not (= (q x!95) 4))
                             (= (+ now (+ (* -1 now') x!94!235)) 0)))
                    (not (= (q x!95) (q' x!95)))
                    (not (= (last x!95) (last' x!95)))
                    (not (= (first x!95) (first' x!95)))
                    (not (= g g'))))))
     (>= x!219!236 1)
     (>= (+ N (* -1 x!219!236)) 0)
     (not (<= (+ now' (* -1 (last' x!219!236))) 0))
     (not (= (q' x!219!236) 2))
     (>= (last' x!219!236) 0)
     (>= (q' x!219!236) 0)
     (<= (q' x!219!236) 4))


sat: disproved claim
A -> 1
N -> 2
g -> 0
x!94!235 -> 1
x!219!236 -> 1
now -> 0
g' -> 0
now' -> 1
B -> 2
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
add rows:             335
added eqs:            504
arith conflicts:      25
assert diseq:         24
assert lower:         699
assert upper:         398
bound prop:           10
conflicts:            74
decisions:            163
del clause:           803
eq adapter:           275
final checks:         91
fixed eqs:            109
max generation:       2
mk clause:            820
offset eqs:           29
pivots:               314
propagations:         293
quant instantiations: 503
restarts:             3
max. heap size:     2.87951 Mbytes


Property was NOT an inductive invariant! Property checked was: 
(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))


Property was NOT inductive! Property checked was: 
(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
Term:
(implies (and (and (and (forall (i Int)
                          (implies (and (>= i 1) (<= i N))
                                   (and (and (and (= (last i) A)
                                                  (= (first i) 0))
                                             (= g 0))
                                        (= now 0))))
                        (= now 0))
                   (= g 0))
              (forall (i Int) (or (= (q i) 0))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                             (> (first i) (last j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)}))


unsat: proved claim
add rows:             339
added eqs:            504
arith conflicts:      25
assert diseq:         24
assert lower:         699
assert upper:         398
bound prop:           10
conflicts:            75
decisions:            163
del clause:           820
eq adapter:           275
final checks:         91
fixed eqs:            109
max generation:       2
mk clause:            820
offset eqs:           29
pivots:               320
propagations:         293
quant instantiations: 503
restarts:             3
max. heap size:     2.87951 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                         (> (first i) (last j)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 0) (= (q' h) 1))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!48!285 1)
     (>= (+ N (* -1 x!48!285)) 0)
     (= (q x!48!285) 0)
     (= (q' x!48!285) 1)
     (= (last x!48!285) (last' x!48!285))
     (= (first x!48!285) (first' x!48!285))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!48!285)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= g' 1)
     (>= x!282!286 1)
     (>= (+ N (* -1 x!282!286)) 0)
     (= (q' g') 3)
     (= (q' x!282!286) 2)
     (<= (+ (first' g') (* -1 (last' x!282!286))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!48!285) 0)
     (<= (q x!48!285) 4)
     (>= (q' x!48!285) 0)
     (<= (q' x!48!285) 4)
     (>= (q' g') 0)
     (<= (q' g') 4)
     (<= (+ now' (* -1 (last' x!282!286))) 0)
     (>= (+ A (+ now' (* -1 (last' x!282!286)))) 0)
     (>= (q' x!282!286) 0)
     (<= (q' x!282!286) 4)
     (>= (last' x!48!285) 0)
     (>= (last' x!282!286) 0)
     (>= (last x!48!285) 0)
     (>= (first' x!48!285) 0)
     (>= (first' g') 0)
     (>= (first x!48!285) 0)
     (<= (q x!48!285) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!48!285) (* -1 (last' x!48!285))) 0)
     (>= (+ (last x!48!285) (* -1 (last' x!48!285))) 0)
     (<= (q' x!48!285) 1)
     (>= (q' x!48!285) 1)
     (<= (q' g') 3)
     (>= (q' g') 3)
     (<= (q' x!282!286) 2)
     (>= (q' x!282!286) 2)
     (<= (+ (first x!48!285) (* -1 (first' x!48!285))) 0)
     (>= (+ (first x!48!285) (* -1 (first' x!48!285))) 0))


unsat: proved claim
add rows:             377
added eqs:            592
arith conflicts:      27
assert diseq:         38
assert lower:         779
assert upper:         456
bound prop:           10
conflicts:            89
decisions:            197
del clause:           882
eq adapter:           320
final checks:         99
fixed eqs:            125
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            911
offset eqs:           29
pivots:               344
propagations:         354
quant instantiations: 574
restarts:             3
max. heap size:     2.96042 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                         (> (first i) (last j)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!55!287 1)
     (>= (+ N (* -1 x!55!287)) 0)
     (= (q x!55!287) 1)
     (= (q' x!55!287) 1)
     (not (= g 0))
     (= (last x!55!287) (last' x!55!287))
     (= (first x!55!287) (first' x!55!287))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!55!287)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= g' 1)
     (>= x!282!288 1)
     (>= (+ N (* -1 x!282!288)) 0)
     (= (q' g') 3)
     (= (q' x!282!288) 2)
     (<= (+ (first' g') (* -1 (last' x!282!288))) 0)
     (not (<= g 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!55!287) 0)
     (<= (q x!55!287) 4)
     (>= (q' x!55!287) 0)
     (<= (q' x!55!287) 4)
     (>= (q' g') 0)
     (<= (q' g') 4)
     (<= (+ now' (* -1 (last' x!282!288))) 0)
     (>= (+ A (+ now' (* -1 (last' x!282!288)))) 0)
     (>= (q' x!282!288) 0)
     (<= (q' x!282!288) 4)
     (>= (last' x!55!287) 0)
     (>= (last' x!282!288) 0)
     (>= (last x!55!287) 0)
     (>= (first' x!55!287) 0)
     (>= (first' g') 0)
     (>= (first x!55!287) 0)
     (<= (q x!55!287) 1)
     (>= (q x!55!287) 1)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!55!287) (* -1 (last' x!55!287))) 0)
     (>= (+ (last x!55!287) (* -1 (last' x!55!287))) 0)
     (<= (q' x!55!287) 1)
     (>= (q' x!55!287) 1)
     (<= (q' g') 3)
     (>= (q' g') 3)
     (<= (q' x!282!288) 2)
     (>= (q' x!282!288) 2)
     (<= (+ (first x!55!287) (* -1 (first' x!55!287))) 0)
     (>= (+ (first x!55!287) (* -1 (first' x!55!287))) 0))


unsat: proved claim
add rows:             406
added eqs:            660
arith conflicts:      29
assert diseq:         50
assert lower:         844
assert upper:         503
bound prop:           10
conflicts:            94
decisions:            213
del clause:           954
eq adapter:           353
final checks:         99
fixed eqs:            139
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            977
offset eqs:           29
pivots:               357
propagations:         391
quant instantiations: 644
restarts:             3
max. heap size:     3.12127 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                         (> (first i) (last j)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 2) (= g 0) (= (last' h) (+ now A)))
                 (and (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!60!289 1)
     (>= (+ N (* -1 x!60!289)) 0)
     (= (q x!60!289) 1)
     (= (q' x!60!289) 2)
     (= g 0)
     (= (+ A (+ now (* -1 (last' x!60!289)))) 0)
     (= (first x!60!289) (first' x!60!289))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!60!289)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= g' 1)
     (>= x!282!290 1)
     (>= (+ N (* -1 x!282!290)) 0)
     (= (q' g') 3)
     (= (q' x!282!290) 2)
     (<= (+ (first' g') (* -1 (last' x!282!290))) 0)
     (<= g 0)
     (<= (+ A (+ now (* -1 (last' x!60!289)))) 0)
     (>= (+ A (+ now (* -1 (last' x!60!289)))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0))


unsat: proved claim
add rows:             408
added eqs:            669
arith conflicts:      30
assert diseq:         50
assert lower:         851
assert upper:         507
bound prop:           10
conflicts:            95
decisions:            213
del clause:           977
eq adapter:           356
final checks:         99
fixed eqs:            140
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            987
offset eqs:           29
pivots:               361
propagations:         396
quant instantiations: 644
restarts:             3
max. heap size:     3.18748 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                         (> (first i) (last j)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 2)
                      (= (q' h) 3)
                      (<= now (last h))
                      (>= now (last h))
                      (and (= g' h) (= (first' h) (+ now B))))
                 (and (= (last h) (last' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!65!291 1)
     (>= (+ N (* -1 x!65!291)) 0)
     (= (q x!65!291) 2)
     (= (q' x!65!291) 3)
     (<= (+ now (* -1 (last x!65!291))) 0)
     (>= (+ now (* -1 (last x!65!291))) 0)
     (= g' x!65!291)
     (= (+ B (+ now (* -1 (first' x!65!291)))) 0)
     (= (last x!65!291) (last' x!65!291))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!65!291)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= g' 1)
     (>= x!282!292 1)
     (>= (+ N (* -1 x!282!292)) 0)
     (= (q' g') 3)
     (= (q' x!282!292) 2)
     (<= (+ (first' g') (* -1 (last' x!282!292))) 0)
     (<= (+ g' (* -1 x!65!291)) 0)
     (>= (+ g' (* -1 x!65!291)) 0)
     (<= (+ B (+ now (* -1 (first' x!65!291)))) 0)
     (>= (+ B (+ now (* -1 (first' x!65!291)))) 0)
     (= (first' g') (first' x!65!291))
     (<= (+ (first' g') (* -1 (first' x!65!291))) 0)
     (>= (+ (first' g') (* -1 (first' x!65!291))) 0)
     (>= (+ A (+ now (* -1 (last x!65!291)))) 0)
     (>= (q x!65!291) 0)
     (<= (q x!65!291) 4)
     (>= (q' x!65!291) 0)
     (<= (q' x!65!291) 4)
     (<= (+ now' (* -1 (last' x!282!292))) 0)
     (>= (+ A (+ now' (* -1 (last' x!282!292)))) 0)
     (>= (q' x!282!292) 0)
     (<= (q' x!282!292) 4)
     (>= (last x!65!291) 0)
     (>= (first' x!65!291) 0)
     (>= (last' x!65!291) 0)
     (>= (last' x!282!292) 0)
     (<= (q x!65!291) 2)
     (>= (q x!65!291) 2)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (= (last' x!65!291) (last x!65!291))
     (<= (+ (last' x!65!291) (* -1 (last x!65!291))) 0)
     (>= (+ (last' x!65!291) (* -1 (last x!65!291))) 0)
     (<= (q' x!65!291) 3)
     (>= (q' x!65!291) 3)
     (<= (q' x!282!292) 2)
     (>= (q' x!282!292) 2))


unsat: proved claim
add rows:             417
added eqs:            684
arith conflicts:      31
assert diseq:         50
assert lower:         874
assert upper:         521
bound prop:           10
conflicts:            96
decisions:            213
del clause:           987
eq adapter:           365
final checks:         99
fixed eqs:            144
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1013
offset eqs:           30
pivots:               366
propagations:         400
quant instantiations: 662
restarts:             3
max. heap size:     3.20568 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                         (> (first i) (last j)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3)
                      (= (q' h) 1)
                      (and (not (= g h)) (>= now (first h)))
                      (= (first' h) 0))
                 (and (= (last h) (last' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!70!293 1)
     (>= (+ N (* -1 x!70!293)) 0)
     (= (q x!70!293) 3)
     (= (q' x!70!293) 1)
     (not (= g x!70!293))
     (>= (+ now (* -1 (first x!70!293))) 0)
     (= (first' x!70!293) 0)
     (= (last x!70!293) (last' x!70!293))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!70!293)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= g' 1)
     (>= x!282!294 1)
     (>= (+ N (* -1 x!282!294)) 0)
     (= (q' g') 3)
     (= (q' x!282!294) 2)
     (<= (+ (first' g') (* -1 (last' x!282!294))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!70!293) 0)
     (<= (q x!70!293) 4)
     (>= (q' x!70!293) 0)
     (<= (q' x!70!293) 4)
     (>= (q' g') 0)
     (<= (q' g') 4)
     (<= (+ now' (* -1 (last' x!282!294))) 0)
     (>= (+ A (+ now' (* -1 (last' x!282!294)))) 0)
     (>= (q' x!282!294) 0)
     (<= (q' x!282!294) 4)
     (>= (first x!70!293) 0)
     (>= (first' x!70!293) 0)
     (>= (first' g') 0)
     (>= (last' x!70!293) 0)
     (>= (last' x!282!294) 0)
     (>= (last x!70!293) 0)
     (not (= g' x!70!293))
     (<= (q x!70!293) 3)
     (>= (q x!70!293) 3)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (= (last' x!70!293) (last x!70!293))
     (<= (+ (last' x!70!293) (* -1 (last x!70!293))) 0)
     (>= (+ (last' x!70!293) (* -1 (last x!70!293))) 0)
     (<= (q' x!70!293) 1)
     (>= (q' x!70!293) 1)
     (<= (q' g') 3)
     (>= (q' g') 3)
     (<= (q' x!282!294) 2)
     (>= (q' x!282!294) 2)
     (<= (first' x!70!293) 0)
     (not (or (not (= (q g') (q' g')))
              (not (= (last g') (last' g')))
              (not (= (first g') (first' g')))))
     (= (q g') (q' g'))
     (= (last g') (last' g'))
     (= (first g') (first' g'))
     (= (q g) 3)
     (= (first g) (first' g'))
     (<= (+ (first g) (* -1 (first' g'))) 0)
     (>= (+ (first g) (* -1 (first' g'))) 0)
     (>= (first g') 0)
     (>= (last' g') 0)
     (>= (last g') 0)
     (>= (q g') 0)
     (<= (q g') 4)
     (= (first g) (first g'))
     (<= (+ (first g) (* -1 (first g'))) 0)
     (>= (+ (first g) (* -1 (first g'))) 0)
     (<= (+ (last g') (* -1 (last' g'))) 0)
     (>= (+ (last g') (* -1 (last' g'))) 0)
     (= (q g') 3)
     (<= (q g') 3)
     (>= (q g') 3))


unsat: proved claim
add rows:             442
added eqs:            735
arith conflicts:      33
assert diseq:         61
assert lower:         935
assert upper:         557
bound prop:           10
conflicts:            101
decisions:            232
del clause:           1044
eq adapter:           394
final checks:         99
fixed eqs:            154
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1069
offset eqs:           30
pivots:               377
propagations:         427
quant instantiations: 719
restarts:             3
max. heap size:     3.20568 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                         (> (first i) (last j)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3) (= (q' h) 4) (and (= g h) (>= now (first h))))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!75!295 1)
     (>= (+ N (* -1 x!75!295)) 0)
     (= (q x!75!295) 3)
     (= (q' x!75!295) 4)
     (= g x!75!295)
     (>= (+ now (* -1 (first x!75!295))) 0)
     (= (last x!75!295) (last' x!75!295))
     (= (first x!75!295) (first' x!75!295))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!75!295)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= g' 1)
     (>= x!282!296 1)
     (>= (+ N (* -1 x!282!296)) 0)
     (= (q' g') 3)
     (= (q' x!282!296) 2)
     (<= (+ (first' g') (* -1 (last' x!282!296))) 0)
     (<= (+ g (* -1 x!75!295)) 0)
     (>= (+ g (* -1 x!75!295)) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0))


unsat: proved claim
add rows:             448
added eqs:            745
arith conflicts:      33
assert diseq:         61
assert lower:         935
assert upper:         557
bound prop:           10
conflicts:            102
decisions:            232
del clause:           1069
eq adapter:           396
final checks:         99
fixed eqs:            154
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1077
offset eqs:           30
pivots:               382
propagations:         431
quant instantiations: 719
restarts:             3
max. heap size:     3.21793 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                         (> (first i) (last j)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!80!297 1)
     (>= (+ N (* -1 x!80!297)) 0)
     (= (q x!80!297) 4)
     (= (q' x!80!297) 0)
     (= g' 0)
     (= (last x!80!297) (last' x!80!297))
     (= (first x!80!297) (first' x!80!297))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!80!297)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= g' 1)
     (>= x!282!298 1)
     (>= (+ N (* -1 x!282!298)) 0)
     (= (q' g') 3)
     (= (q' x!282!298) 2)
     (<= (+ (first' g') (* -1 (last' x!282!298))) 0)
     (<= g' 0))


unsat: proved claim
add rows:             448
added eqs:            745
arith conflicts:      33
assert diseq:         61
assert lower:         935
assert upper:         557
bound prop:           10
conflicts:            103
decisions:            232
del clause:           1077
eq adapter:           397
final checks:         99
fixed eqs:            154
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1080
offset eqs:           30
pivots:               382
propagations:         432
quant instantiations: 719
restarts:             3
max. heap size:     3.23647 Mbytes
Unsat core:

Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!94!299 0)
     (forall (x!96 Real) (x!95 Int)
       (or (not (>= x!96 0))
           (not (<= (+ x!96 (* -1 x!94!299)) 0))
           (not (>= x!95 1))
           (not (>= (+ N (* -1 x!95)) 0))
           (not (or (not (or (not (= (q x!95) 0))
                             (= (+ now (+ (* -1 now') x!94!299)) 0)))
                    (not (or (not (= (q x!95) 1))
                             (= (+ now (+ (* -1 now') x!94!299)) 0)))
                    (not (or (not (= (q x!95) 2))
                             (not (or (not (<= (+ now
                                                  (+ x!96 (* -1 (last x!95))))
                                               0))
                                      (not (or (not (>= (+ now
                                                           (+ x!96
                                                              (* -1 (last x!95))))
                                                        0))
                                               (= x!94!299 x!96)))
                                      (not (= (+ now (+ (* -1 now') x!94!299))
                                              0))))))
                    (not (or (not (= (q x!95) 3))
                             (= (+ now (+ (* -1 now') x!94!299)) 0)))
                    (not (or (not (= (q x!95) 4))
                             (= (+ now (+ (* -1 now') x!94!299)) 0)))
                    (not (= (q x!95) (q' x!95)))
                    (not (= (last x!95) (last' x!95)))
                    (not (= (first x!95) (first' x!95)))
                    (not (= g g'))))))
     (>= g' 1)
     (>= x!282!300 1)
     (>= (+ N (* -1 x!282!300)) 0)
     (= (q' g') 3)
     (= (q' x!282!300) 2)
     (<= (+ (first' g') (* -1 (last' x!282!300))) 0)
     (>= (q' g') 0)
     (<= (q' g') 4)
     (<= (+ now' (* -1 (last' x!282!300))) 0)
     (>= (+ A (+ now' (* -1 (last' x!282!300)))) 0)
     (>= (q' x!282!300) 0)
     (<= (q' x!282!300) 4)
     (>= (first' g') 0)
     (>= (last' x!282!300) 0)
     (<= (q' g') 3)
     (>= (q' g') 3)
     (<= (q' x!282!300) 2)
     (>= (q' x!282!300) 2))


unsat: proved claim
add rows:             483
added eqs:            819
arith conflicts:      35
assert diseq:         121
assert lower:         1032
assert upper:         655
bound prop:           18
conflicts:            108
decisions:            350
del clause:           1258
eq adapter:           450
final checks:         106
fixed eqs:            178
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1433
offset eqs:           30
pivots:               398
propagations:         615
quant instantiations: 779
restarts:             7
max. heap size:     3.61553 Mbytes
Unsat core:



Property was an inductive invariant! Property checked was: 
(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                    (> (first i) (last j)))))


ASSUMPTIONS: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)}))



Properties proved and used as assumption lemmas: 


(forall (i Int)
  (implies (and (>= i 1) (<= i N))
           (implies (= (q i) 2) (<= (last i) (+ now A)))))


(forall (i Int)
  (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))


(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                    (> (first i) (last j)))))


Model for basic assumptions: 


A -> 1
N -> 4
g -> 2
B -> 2
now -> 1
g' -> 2
now' -> 1
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
Unsat core:

Term:
(implies (and (and (and (forall (i Int)
                          (implies (and (>= i 1) (<= i N))
                                   (and (and (and (= (last i) A)
                                                  (= (first i) 0))
                                             (= g 0))
                                        (= now 0))))
                        (= now 0))
                   (= g 0))
              (forall (i Int) (or (= (q i) 0))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (= now 0)
     (= g 0)
     (forall (x!36 Int)
       (or (not (>= x!36 1))
           (not (>= (+ N (* -1 x!36)) 0))
           (not (or (not (= (last x!36) A)) (not (= (first x!36) 0)))))
       :pat {(last x!36)}
       :pat {(first x!36)})
     (forall (x!38 Int) (= (q x!38) 0) :pat {(q x!38)})
     (>= x!0!439 1)
     (>= (+ N (* -1 x!0!439)) 0)
     (not (>= (last x!0!439) 0))
     (<= g 0)
     (not (or (not (= (last x!0!439) A)) (not (= (first x!0!439) 0))))
     (not (>= g 1)))


unsat: proved claim
add rows:             502
added eqs:            821
arith conflicts:      35
assert diseq:         121
assert lower:         1034
assert upper:         657
bound prop:           18
conflicts:            109
decisions:            350
del clause:           1433
eq adapter:           452
final checks:         108
fixed eqs:            178
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1444
offset eqs:           31
pivots:               412
propagations:         616
quant instantiations: 784
restarts:             7
max. heap size:     3.61553 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 0) (= (q' h) 1))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!48!440 1)
     (>= (+ N (* -1 x!48!440)) 0)
     (= (q x!48!440) 0)
     (= (q' x!48!440) 1)
     (= (last x!48!440) (last' x!48!440))
     (= (first x!48!440) (first' x!48!440))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!48!440)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!441 1)
     (>= (+ N (* -1 x!219!441)) 0)
     (not (<= (+ now' (* -1 (last' x!219!441))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!48!440) 0)
     (<= (q x!48!440) 4)
     (>= (q' x!48!440) 0)
     (<= (q' x!48!440) 4)
     (>= (last' x!48!440) 0)
     (not (= (q' x!219!441) 2))
     (>= (last' x!219!441) 0)
     (<= (+ now (* -1 (last x!48!440))) 0)
     (>= (last x!48!440) 0)
     (>= (first' x!48!440) 0)
     (>= (first x!48!440) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!48!440) 0)
     (= (last' x!48!440) (last x!48!440))
     (<= (+ (last' x!48!440) (* -1 (last x!48!440))) 0)
     (>= (+ (last' x!48!440) (* -1 (last x!48!440))) 0)
     (<= (q' x!48!440) 1)
     (>= (q' x!48!440) 1)
     (= (first' x!48!440) (first x!48!440))
     (<= (+ (first' x!48!440) (* -1 (first x!48!440))) 0)
     (>= (+ (first' x!48!440) (* -1 (first x!48!440))) 0)
     (>= (q' x!219!441) 0)
     (<= (q' x!219!441) 4)
     (<= (+ now' (* -1 (last' x!48!440))) 0))


unsat: proved claim
add rows:             516
added eqs:            845
arith conflicts:      36
assert diseq:         122
assert lower:         1059
assert upper:         675
bound prop:           19
conflicts:            111
decisions:            353
del clause:           1447
eq adapter:           463
final checks:         108
fixed eqs:            184
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1474
offset eqs:           32
pivots:               419
propagations:         624
quant instantiations: 811
restarts:             7
max. heap size:     3.61553 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!55!442 1)
     (>= (+ N (* -1 x!55!442)) 0)
     (= (q x!55!442) 1)
     (= (q' x!55!442) 1)
     (not (= g 0))
     (= (last x!55!442) (last' x!55!442))
     (= (first x!55!442) (first' x!55!442))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!55!442)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!443 1)
     (>= (+ N (* -1 x!219!443)) 0)
     (not (<= (+ now' (* -1 (last' x!219!443))) 0))
     (not (<= g 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!55!442) 0)
     (<= (q x!55!442) 4)
     (>= (q' x!55!442) 0)
     (<= (q' x!55!442) 4)
     (>= (last' x!55!442) 0)
     (not (= (q' x!219!443) 2))
     (>= (last' x!219!443) 0)
     (<= (+ now (* -1 (last x!55!442))) 0)
     (>= (last x!55!442) 0)
     (>= (first' x!55!442) 0)
     (>= (first x!55!442) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!55!442) 1)
     (>= (q x!55!442) 1)
     (<= (+ (last x!55!442) (* -1 (last' x!55!442))) 0)
     (>= (+ (last x!55!442) (* -1 (last' x!55!442))) 0)
     (<= (q' x!55!442) 1)
     (>= (q' x!55!442) 1)
     (<= (+ (first x!55!442) (* -1 (first' x!55!442))) 0)
     (>= (+ (first x!55!442) (* -1 (first' x!55!442))) 0)
     (>= (q' x!219!443) 0)
     (<= (q' x!219!443) 4)
     (<= (+ now' (* -1 (last' x!55!442))) 0))


unsat: proved claim
add rows:             537
added eqs:            867
arith conflicts:      37
assert diseq:         124
assert lower:         1086
assert upper:         693
bound prop:           20
conflicts:            113
decisions:            356
del clause:           1477
eq adapter:           475
final checks:         108
fixed eqs:            190
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1507
offset eqs:           33
pivots:               431
propagations:         633
quant instantiations: 838
restarts:             7
max. heap size:     3.61553 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 2) (= g 0) (= (last' h) (+ now A)))
                 (and (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!60!444 1)
     (>= (+ N (* -1 x!60!444)) 0)
     (= (q x!60!444) 1)
     (= (q' x!60!444) 2)
     (= g 0)
     (= (+ A (+ now (* -1 (last' x!60!444)))) 0)
     (= (first x!60!444) (first' x!60!444))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!60!444)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!445 1)
     (>= (+ N (* -1 x!219!445)) 0)
     (not (<= (+ now' (* -1 (last' x!219!445))) 0))
     (<= g 0)
     (<= (+ A (+ now (* -1 (last' x!60!444)))) 0)
     (>= (+ A (+ now (* -1 (last' x!60!444)))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (not (>= g 1))
     (>= (q x!60!444) 0)
     (<= (q x!60!444) 4)
     (<= (+ now' (* -1 (last' x!60!444))) 0)
     (>= (+ A (+ now' (* -1 (last' x!60!444)))) 0)
     (>= (q' x!60!444) 0)
     (<= (q' x!60!444) 4)
     (>= (last' x!60!444) 0)
     (not (= (q' x!219!445) 2))
     (>= (last' x!219!445) 0)
     (>= (first' x!60!444) 0)
     (>= (first x!60!444) 0)
     (<= (q x!60!444) 1)
     (>= (q x!60!444) 1)
     (<= (q' x!60!444) 2)
     (>= (q' x!60!444) 2)
     (<= (+ (first x!60!444) (* -1 (first' x!60!444))) 0)
     (>= (+ (first x!60!444) (* -1 (first' x!60!444))) 0)
     (>= (q' x!219!445) 0)
     (<= (q' x!219!445) 4))


unsat: proved claim
add rows:             561
added eqs:            891
arith conflicts:      38
assert diseq:         125
assert lower:         1112
assert upper:         712
bound prop:           20
conflicts:            115
decisions:            359
del clause:           1510
eq adapter:           487
final checks:         108
fixed eqs:            197
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1539
offset eqs:           36
pivots:               443
propagations:         644
quant instantiations: 863
restarts:             7
max. heap size:     3.61553 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 2)
                      (= (q' h) 3)
                      (<= now (last h))
                      (>= now (last h))
                      (and (= g' h) (= (first' h) (+ now B))))
                 (and (= (last h) (last' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!65!446 1)
     (>= (+ N (* -1 x!65!446)) 0)
     (= (q x!65!446) 2)
     (= (q' x!65!446) 3)
     (<= (+ now (* -1 (last x!65!446))) 0)
     (>= (+ now (* -1 (last x!65!446))) 0)
     (= g' x!65!446)
     (= (+ B (+ now (* -1 (first' x!65!446)))) 0)
     (= (last x!65!446) (last' x!65!446))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!65!446)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!447 1)
     (>= (+ N (* -1 x!219!447)) 0)
     (not (<= (+ now' (* -1 (last' x!219!447))) 0))
     (<= (+ g' (* -1 x!65!446)) 0)
     (>= (+ g' (* -1 x!65!446)) 0)
     (<= (+ B (+ now (* -1 (first' x!65!446)))) 0)
     (>= (+ B (+ now (* -1 (first' x!65!446)))) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (+ A (+ now (* -1 (last x!65!446)))) 0)
     (>= (q x!65!446) 0)
     (<= (q x!65!446) 4)
     (>= (q' x!65!446) 0)
     (<= (q' x!65!446) 4)
     (>= (last x!65!446) 0)
     (>= (first' x!65!446) 0)
     (>= (last' x!65!446) 0)
     (not (= (q' x!219!447) 2))
     (>= (last' x!219!447) 0)
     (= (q' g') 3)
     (<= (q x!65!446) 2)
     (>= (q x!65!446) 2)
     (<= (+ (last x!65!446) (* -1 (last' x!65!446))) 0)
     (>= (+ (last x!65!446) (* -1 (last' x!65!446))) 0)
     (<= (q' x!65!446) 3)
     (>= (q' x!65!446) 3)
     (= (first' g') (first' x!65!446))
     (<= (+ (first' g') (* -1 (first' x!65!446))) 0)
     (>= (+ (first' g') (* -1 (first' x!65!446))) 0)
     (>= (q' x!219!447) 0)
     (<= (q' x!219!447) 4)
     (not (<= (+ (first' g') (* -1 (last' x!65!446))) 0))
     (<= (+ now' (* -1 (last' x!65!446))) 0)
     (>= (+ A (+ now' (* -1 (last' x!65!446)))) 0)
     (not (<= (+ (first' g') (* -1 (last' x!219!447))) 0)))


unsat: proved claim
add rows:             585
added eqs:            920
arith conflicts:      39
assert diseq:         126
assert lower:         1142
assert upper:         731
bound prop:           24
conflicts:            117
decisions:            361
del clause:           1563
eq adapter:           499
final checks:         108
fixed eqs:            205
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1575
offset eqs:           40
pivots:               457
propagations:         654
quant instantiations: 889
restarts:             7
max. heap size:     3.61553 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3)
                      (= (q' h) 1)
                      (and (not (= g h)) (>= now (first h)))
                      (= (first' h) 0))
                 (and (= (last h) (last' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!70!448 1)
     (>= (+ N (* -1 x!70!448)) 0)
     (= (q x!70!448) 3)
     (= (q' x!70!448) 1)
     (not (= g x!70!448))
     (>= (+ now (* -1 (first x!70!448))) 0)
     (= (first' x!70!448) 0)
     (= (last x!70!448) (last' x!70!448))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!70!448)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!449 1)
     (>= (+ N (* -1 x!219!449)) 0)
     (not (<= (+ now' (* -1 (last' x!219!449))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!70!448) 0)
     (<= (q x!70!448) 4)
     (>= (q' x!70!448) 0)
     (<= (q' x!70!448) 4)
     (>= (first x!70!448) 0)
     (>= (first' x!70!448) 0)
     (>= (last' x!70!448) 0)
     (not (= (q' x!219!449) 2))
     (>= (last' x!219!449) 0)
     (<= (+ now (* -1 (last x!70!448))) 0)
     (>= (last x!70!448) 0)
     (<= (q x!70!448) 3)
     (>= (q x!70!448) 3)
     (<= (+ (last x!70!448) (* -1 (last' x!70!448))) 0)
     (>= (+ (last x!70!448) (* -1 (last' x!70!448))) 0)
     (<= (q' x!70!448) 1)
     (>= (q' x!70!448) 1)
     (<= (first' x!70!448) 0)
     (>= (q' x!219!449) 0)
     (<= (q' x!219!449) 4)
     (<= (+ now' (* -1 (last' x!70!448))) 0))


unsat: proved claim
add rows:             610
added eqs:            940
arith conflicts:      40
assert diseq:         128
assert lower:         1168
assert upper:         749
bound prop:           25
conflicts:            119
decisions:            364
del clause:           1592
eq adapter:           511
final checks:         108
fixed eqs:            210
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1609
offset eqs:           41
pivots:               472
propagations:         662
quant instantiations: 916
restarts:             7
max. heap size:     3.61553 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3) (= (q' h) 4) (and (= g h) (>= now (first h))))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!75!450 1)
     (>= (+ N (* -1 x!75!450)) 0)
     (= (q x!75!450) 3)
     (= (q' x!75!450) 4)
     (= g x!75!450)
     (>= (+ now (* -1 (first x!75!450))) 0)
     (= (last x!75!450) (last' x!75!450))
     (= (first x!75!450) (first' x!75!450))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!75!450)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!451 1)
     (>= (+ N (* -1 x!219!451)) 0)
     (not (<= (+ now' (* -1 (last' x!219!451))) 0))
     (<= (+ g (* -1 x!75!450)) 0)
     (>= (+ g (* -1 x!75!450)) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!75!450) 0)
     (<= (q x!75!450) 4)
     (>= (q' x!75!450) 0)
     (<= (q' x!75!450) 4)
     (>= (first x!75!450) 0)
     (>= (last' x!75!450) 0)
     (not (= (q' x!219!451) 2))
     (>= (last' x!219!451) 0)
     (<= (+ now (* -1 (last x!75!450))) 0)
     (>= (last x!75!450) 0)
     (>= (first' x!75!450) 0)
     (= (q g) 3)
     (<= (q x!75!450) 3)
     (>= (q x!75!450) 3)
     (<= (+ (last x!75!450) (* -1 (last' x!75!450))) 0)
     (>= (+ (last x!75!450) (* -1 (last' x!75!450))) 0)
     (>= (q' x!75!450) 4)
     (<= (+ (first x!75!450) (* -1 (first' x!75!450))) 0)
     (>= (+ (first x!75!450) (* -1 (first' x!75!450))) 0)
     (= (first g) (first x!75!450))
     (<= (+ (first g) (* -1 (first x!75!450))) 0)
     (>= (+ (first g) (* -1 (first x!75!450))) 0)
     (= (first' g') (first' x!75!450))
     (<= (+ (first' g') (* -1 (first' x!75!450))) 0)
     (>= (+ (first' g') (* -1 (first' x!75!450))) 0)
     (>= (q' x!219!451) 0)
     (<= (q' x!219!451) 4)
     (<= (+ now' (* -1 (last' x!75!450))) 0))


unsat: proved claim
add rows:             635
added eqs:            966
arith conflicts:      41
assert diseq:         129
assert lower:         1198
assert upper:         769
bound prop:           26
conflicts:            121
decisions:            367
del clause:           1630
eq adapter:           525
final checks:         108
fixed eqs:            212
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1645
offset eqs:           42
pivots:               486
propagations:         672
quant instantiations: 943
restarts:             7
max. heap size:     3.61553 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!80!452 1)
     (>= (+ N (* -1 x!80!452)) 0)
     (= (q x!80!452) 4)
     (= (q' x!80!452) 0)
     (= g' 0)
     (= (last x!80!452) (last' x!80!452))
     (= (first x!80!452) (first' x!80!452))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!80!452)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!453 1)
     (>= (+ N (* -1 x!219!453)) 0)
     (not (<= (+ now' (* -1 (last' x!219!453))) 0))
     (<= g' 0)
     (>= (q x!80!452) 0)
     (<= (q x!80!452) 4)
     (not (>= g' 1))
     (>= (q' x!80!452) 0)
     (<= (q' x!80!452) 4)
     (>= (last' x!80!452) 0)
     (not (= (q' x!219!453) 2))
     (>= (last' x!219!453) 0)
     (<= (+ now (* -1 (last x!80!452))) 0)
     (>= (last x!80!452) 0)
     (>= (first' x!80!452) 0)
     (>= (first x!80!452) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!80!452) 4)
     (<= (+ (last x!80!452) (* -1 (last' x!80!452))) 0)
     (>= (+ (last x!80!452) (* -1 (last' x!80!452))) 0)
     (<= (q' x!80!452) 0)
     (<= (+ (first x!80!452) (* -1 (first' x!80!452))) 0)
     (>= (+ (first x!80!452) (* -1 (first' x!80!452))) 0)
     (>= (q' x!219!453) 0)
     (<= (q' x!219!453) 4)
     (<= (+ now' (* -1 (last' x!80!452))) 0))


unsat: proved claim
add rows:             655
added eqs:            987
arith conflicts:      42
assert diseq:         130
assert lower:         1222
assert upper:         787
bound prop:           27
conflicts:            123
decisions:            369
del clause:           1656
eq adapter:           536
final checks:         108
fixed eqs:            217
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1670
offset eqs:           44
pivots:               498
propagations:         679
quant instantiations: 969
restarts:             7
max. heap size:     3.61553 Mbytes
Unsat core:

Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!94!454 0)
     (forall (x!96 Real) (x!95 Int)
       (or (not (>= x!96 0))
           (not (<= (+ x!96 (* -1 x!94!454)) 0))
           (not (>= x!95 1))
           (not (>= (+ N (* -1 x!95)) 0))
           (not (or (not (or (not (= (q x!95) 0))
                             (= (+ now (+ (* -1 now') x!94!454)) 0)))
                    (not (or (not (= (q x!95) 1))
                             (= (+ now (+ (* -1 now') x!94!454)) 0)))
                    (not (or (not (= (q x!95) 2))
                             (not (or (not (<= (+ now
                                                  (+ x!96 (* -1 (last x!95))))
                                               0))
                                      (not (or (not (>= (+ now
                                                           (+ x!96
                                                              (* -1 (last x!95))))
                                                        0))
                                               (= x!94!454 x!96)))
                                      (not (= (+ now (+ (* -1 now') x!94!454))
                                              0))))))
                    (not (or (not (= (q x!95) 3))
                             (= (+ now (+ (* -1 now') x!94!454)) 0)))
                    (not (or (not (= (q x!95) 4))
                             (= (+ now (+ (* -1 now') x!94!454)) 0)))
                    (not (= (q x!95) (q' x!95)))
                    (not (= (last x!95) (last' x!95)))
                    (not (= (first x!95) (first' x!95)))
                    (not (= g g'))))))
     (>= x!219!455 1)
     (>= (+ N (* -1 x!219!455)) 0)
     (not (<= (+ now' (* -1 (last' x!219!455))) 0))
     (not (= (q' x!219!455) 2))
     (>= (last' x!219!455) 0)
     (>= (q' x!219!455) 0)
     (<= (q' x!219!455) 4))


sat: disproved claim
A -> 1
N -> 4
g -> 0
x!219!455 -> 1
now -> 0
g' -> 0
now' -> 1
B -> 2
x!94!454 -> 1
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
add rows:             670
added eqs:            1003
arith conflicts:      42
assert diseq:         137
assert lower:         1239
assert upper:         809
bound prop:           29
conflicts:            124
decisions:            390
del clause:           1706
eq adapter:           548
final checks:         110
fixed eqs:            225
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1735
offset eqs:           44
pivots:               509
propagations:         707
quant instantiations: 986
restarts:             8
max. heap size:     3.61553 Mbytes


Property was NOT an inductive invariant! Property checked was: 
(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))


Property was NOT inductive! Property checked was: 
(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
Term:
(implies (and (and (and (forall (i Int)
                          (implies (and (>= i 1) (<= i N))
                                   (and (and (and (= (last i) A)
                                                  (= (first i) 0))
                                             (= g 0))
                                        (= now 0))))
                        (= now 0))
                   (= g 0))
              (forall (i Int) (or (= (q i) 0))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q i) 4) (and (= g i) (not (= (q j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (= now 0)
     (= g 0)
     (forall (x!36 Int)
       (or (not (>= x!36 1))
           (not (>= (+ N (* -1 x!36)) 0))
           (not (or (not (= (last x!36) A)) (not (= (first x!36) 0)))))
       :pat {(last x!36)}
       :pat {(first x!36)})
     (forall (x!38 Int) (= (q x!38) 0) :pat {(q x!38)})
     (>= x!498!502 1)
     (>= (+ N (* -1 x!498!502)) 0)
     (>= x!499!503 1)
     (>= (+ N (* -1 x!499!503)) 0)
     (= (q x!498!502) 4)
     (not (<= x!498!502 0))
     (>= x!498!502 0)
     (not (= x!498!502 0))
     (<= g 0)
     (= (q x!498!502) 0)
     (not (>= g 1))
     (>= (q x!498!502) 0)
     (<= (q x!498!502) 4))


unsat: proved claim
add rows:             680
added eqs:            1014
arith conflicts:      42
assert diseq:         139
assert lower:         1253
assert upper:         812
bound prop:           29
conflicts:            126
decisions:            396
del clause:           1745
eq adapter:           553
final checks:         115
fixed eqs:            227
interface eqs:        7
max generation:       3
minimized lits:       1
mk clause:            1749
offset eqs:           45
pivots:               519
propagations:         710
quant instantiations: 992
restarts:             8
max. heap size:     4.0204 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 0) (= (q' h) 1))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (>= x!48!512 1)
     (>= (+ N (* -1 x!48!512)) 0)
     (= (q x!48!512) 0)
     (= (q' x!48!512) 1)
     (= (last x!48!512) (last' x!48!512))
     (= (first x!48!512) (first' x!48!512))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!48!512)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!508!513 1)
     (>= (+ N (* -1 x!508!513)) 0)
     (>= x!509!514 1)
     (>= (+ N (* -1 x!509!514)) 0)
     (= (q' x!508!513) 4)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!48!512) 0)
     (<= (q x!48!512) 4)
     (>= (q' x!48!512) 0)
     (<= (q' x!48!512) 4)
     (>= (q' x!508!513) 0)
     (<= (q' x!508!513) 4)
     (>= (last' x!48!512) 0)
     (>= (last x!48!512) 0)
     (>= (first' x!48!512) 0)
     (>= (first x!48!512) 0)
     (<= (q x!48!512) 0)
     (<= (+ (last x!48!512) (* -1 (last' x!48!512))) 0)
     (>= (+ (last x!48!512) (* -1 (last' x!48!512))) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q' x!48!512) 1)
     (>= (q' x!48!512) 1)
     (>= (q' x!508!513) 4)
     (<= (+ (first x!48!512) (* -1 (first' x!48!512))) 0)
     (>= (+ (first x!48!512) (* -1 (first' x!48!512))) 0))


unsat: proved claim
add rows:             707
added eqs:            1078
arith conflicts:      42
assert diseq:         151
assert lower:         1319
assert upper:         845
bound prop:           35
conflicts:            131
decisions:            422
del clause:           1814
eq adapter:           586
final checks:         125
fixed eqs:            237
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            1855
offset eqs:           45
pivots:               531
propagations:         745
quant instantiations: 1045
restarts:             8
max. heap size:     4.53029 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (>= x!55!515 1)
     (>= (+ N (* -1 x!55!515)) 0)
     (= (q x!55!515) 1)
     (= (q' x!55!515) 1)
     (not (= g 0))
     (= (last x!55!515) (last' x!55!515))
     (= (first x!55!515) (first' x!55!515))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!55!515)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!508!516 1)
     (>= (+ N (* -1 x!508!516)) 0)
     (>= x!509!517 1)
     (>= (+ N (* -1 x!509!517)) 0)
     (= (q' x!508!516) 4)
     (not (<= g 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!55!515) 0)
     (<= (q x!55!515) 4)
     (>= (q' x!55!515) 0)
     (<= (q' x!55!515) 4)
     (>= (q' x!508!516) 0)
     (<= (q' x!508!516) 4)
     (>= (last' x!55!515) 0)
     (>= (last x!55!515) 0)
     (>= (first' x!55!515) 0)
     (>= (first x!55!515) 0)
     (<= (q x!55!515) 1)
     (>= (q x!55!515) 1)
     (<= (+ (last x!55!515) (* -1 (last' x!55!515))) 0)
     (>= (+ (last x!55!515) (* -1 (last' x!55!515))) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q' x!55!515) 1)
     (>= (q' x!55!515) 1)
     (>= (q' x!508!516) 4)
     (<= (+ (first x!55!515) (* -1 (first' x!55!515))) 0)
     (>= (+ (first x!55!515) (* -1 (first' x!55!515))) 0))


unsat: proved claim
add rows:             719
added eqs:            1135
arith conflicts:      43
assert diseq:         169
assert lower:         1379
assert upper:         876
bound prop:           38
conflicts:            135
decisions:            444
del clause:           1907
eq adapter:           618
final checks:         125
fixed eqs:            247
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            1946
offset eqs:           45
pivots:               536
propagations:         779
quant instantiations: 1098
restarts:             8
max. heap size:     4.53029 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 2) (= g 0) (= (last' h) (+ now A)))
                 (and (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (>= x!60!518 1)
     (>= (+ N (* -1 x!60!518)) 0)
     (= (q x!60!518) 1)
     (= (q' x!60!518) 2)
     (= g 0)
     (= (+ A (+ now (* -1 (last' x!60!518)))) 0)
     (= (first x!60!518) (first' x!60!518))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!60!518)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!508!519 1)
     (>= (+ N (* -1 x!508!519)) 0)
     (>= x!509!520 1)
     (>= (+ N (* -1 x!509!520)) 0)
     (= (q' x!508!519) 4)
     (<= g 0)
     (<= (+ A (+ now (* -1 (last' x!60!518)))) 0)
     (>= (+ A (+ now (* -1 (last' x!60!518)))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ g' (* -1 x!508!519)) 0)
     (not (>= (+ g' (* -1 x!508!519)) 0))
     (not (>= g 1))
     (>= (q x!60!518) 0)
     (<= (q x!60!518) 4)
     (<= (+ now' (* -1 (last' x!60!518))) 0)
     (>= (+ A (+ now' (* -1 (last' x!60!518)))) 0)
     (>= (q' x!60!518) 0)
     (<= (q' x!60!518) 4)
     (>= (q' x!508!519) 0)
     (<= (q' x!508!519) 4)
     (>= (last' x!60!518) 0)
     (>= (first' x!60!518) 0)
     (>= (first x!60!518) 0)
     (not (= g' x!508!519))
     (<= (q x!60!518) 1)
     (>= (q x!60!518) 1)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q' x!60!518) 2)
     (>= (q' x!60!518) 2)
     (>= (q' x!508!519) 4)
     (<= (+ (first x!60!518) (* -1 (first' x!60!518))) 0)
     (>= (+ (first x!60!518) (* -1 (first' x!60!518))) 0)
     (<= (+ g (* -1 x!60!518)) 0)
     (not (>= (+ g (* -1 x!60!518)) 0))
     (not (= g x!60!518))
     (or (not (= g x!60!518)) (= (q x!60!518) 2))
     (not (= (q x!60!518) 4))
     (not (>= (q x!60!518) 4)))


unsat: proved claim
add rows:             725
added eqs:            1162
arith conflicts:      43
assert diseq:         175
assert lower:         1403
assert upper:         895
bound prop:           44
conflicts:            138
decisions:            451
del clause:           1987
eq adapter:           634
final checks:         125
fixed eqs:            250
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            2008
offset eqs:           48
pivots:               539
propagations:         803
quant instantiations: 1134
restarts:             8
max. heap size:     4.53029 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 2)
                      (= (q' h) 3)
                      (<= now (last h))
                      (>= now (last h))
                      (and (= g' h) (= (first' h) (+ now B))))
                 (and (= (last h) (last' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (>= x!65!521 1)
     (>= (+ N (* -1 x!65!521)) 0)
     (= (q x!65!521) 2)
     (= (q' x!65!521) 3)
     (<= (+ now (* -1 (last x!65!521))) 0)
     (>= (+ now (* -1 (last x!65!521))) 0)
     (= g' x!65!521)
     (= (+ B (+ now (* -1 (first' x!65!521)))) 0)
     (= (last x!65!521) (last' x!65!521))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!65!521)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!508!522 1)
     (>= (+ N (* -1 x!508!522)) 0)
     (>= x!509!523 1)
     (>= (+ N (* -1 x!509!523)) 0)
     (= (q' x!508!522) 4)
     (<= (+ g' (* -1 x!65!521)) 0)
     (>= (+ g' (* -1 x!65!521)) 0)
     (<= (+ B (+ now (* -1 (first' x!65!521)))) 0)
     (>= (+ B (+ now (* -1 (first' x!65!521)))) 0)
     (or (not (= g x!65!521)) (= (q x!65!521) 2))
     (not (= (q x!65!521) 4))
     (>= (+ A (+ now (* -1 (last x!65!521)))) 0)
     (>= (q x!65!521) 0)
     (<= (q x!65!521) 4)
     (>= (q' x!65!521) 0)
     (<= (q' x!65!521) 4)
     (>= (q' x!508!522) 0)
     (<= (q' x!508!522) 4)
     (>= (last x!65!521) 0)
     (>= (first' x!65!521) 0)
     (>= (last' x!65!521) 0)
     (= (q' g') 3)
     (<= (q x!65!521) 2)
     (>= (q x!65!521) 2)
     (<= (+ (last x!65!521) (* -1 (last' x!65!521))) 0)
     (>= (+ (last x!65!521) (* -1 (last' x!65!521))) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q' x!65!521) 3)
     (>= (q' x!65!521) 3)
     (>= (q' x!508!522) 4)
     (= (first' g') (first' x!65!521))
     (<= (+ (first' g') (* -1 (first' x!65!521))) 0)
     (>= (+ (first' g') (* -1 (first' x!65!521))) 0)
     (not (>= (q x!65!521) 4)))


unsat: proved claim
add rows:             731
added eqs:            1187
arith conflicts:      43
assert diseq:         176
assert lower:         1425
assert upper:         907
bound prop:           44
conflicts:            140
decisions:            452
del clause:           2034
eq adapter:           647
final checks:         125
fixed eqs:            254
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            2056
offset eqs:           49
pivots:               544
propagations:         812
quant instantiations: 1160
restarts:             8
max. heap size:     4.53029 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3)
                      (= (q' h) 1)
                      (and (not (= g h)) (>= now (first h)))
                      (= (first' h) 0))
                 (and (= (last h) (last' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (>= x!70!524 1)
     (>= (+ N (* -1 x!70!524)) 0)
     (= (q x!70!524) 3)
     (= (q' x!70!524) 1)
     (not (= g x!70!524))
     (>= (+ now (* -1 (first x!70!524))) 0)
     (= (first' x!70!524) 0)
     (= (last x!70!524) (last' x!70!524))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!70!524)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!508!525 1)
     (>= (+ N (* -1 x!508!525)) 0)
     (>= x!509!526 1)
     (>= (+ N (* -1 x!509!526)) 0)
     (= (q' x!508!525) 4)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (or (not (= g x!70!524)) (= (q x!70!524) 2))
     (not (= (q x!70!524) 4))
     (>= (q x!70!524) 0)
     (<= (q x!70!524) 4)
     (>= (q' x!70!524) 0)
     (<= (q' x!70!524) 4)
     (>= (q' x!508!525) 0)
     (<= (q' x!508!525) 4)
     (>= (first x!70!524) 0)
     (>= (first' x!70!524) 0)
     (>= (last' x!70!524) 0)
     (>= (last x!70!524) 0)
     (<= (q x!70!524) 3)
     (>= (q x!70!524) 3)
     (<= (+ (last x!70!524) (* -1 (last' x!70!524))) 0)
     (>= (+ (last x!70!524) (* -1 (last' x!70!524))) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q' x!70!524) 1)
     (>= (q' x!70!524) 1)
     (>= (q' x!508!525) 4)
     (<= (first' x!70!524) 0)
     (not (>= (q x!70!524) 4)))


unsat: proved claim
add rows:             752
added eqs:            1241
arith conflicts:      43
assert diseq:         188
assert lower:         1482
assert upper:         934
bound prop:           50
conflicts:            143
decisions:            464
del clause:           2087
eq adapter:           676
final checks:         125
fixed eqs:            263
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            2132
offset eqs:           49
pivots:               551
propagations:         835
quant instantiations: 1210
restarts:             8
max. heap size:     4.53029 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3) (= (q' h) 4) (and (= g h) (>= now (first h))))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (>= x!75!527 1)
     (>= (+ N (* -1 x!75!527)) 0)
     (= (q x!75!527) 3)
     (= (q' x!75!527) 4)
     (= g x!75!527)
     (>= (+ now (* -1 (first x!75!527))) 0)
     (= (last x!75!527) (last' x!75!527))
     (= (first x!75!527) (first' x!75!527))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!75!527)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!508!528 1)
     (>= (+ N (* -1 x!508!528)) 0)
     (>= x!509!529 1)
     (>= (+ N (* -1 x!509!529)) 0)
     (= (q' x!508!528) 4)
     (<= (+ g (* -1 x!75!527)) 0)
     (>= (+ g (* -1 x!75!527)) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!75!527) 0)
     (<= (q x!75!527) 4)
     (>= (q' x!75!527) 0)
     (<= (q' x!75!527) 4)
     (>= (q' x!508!528) 0)
     (<= (q' x!508!528) 4)
     (>= (first x!75!527) 0)
     (>= (last' x!75!527) 0)
     (>= (last x!75!527) 0)
     (>= (first' x!75!527) 0)
     (= (q g) 3)
     (<= (q x!75!527) 3)
     (>= (q x!75!527) 3)
     (<= (+ (last x!75!527) (* -1 (last' x!75!527))) 0)
     (>= (+ (last x!75!527) (* -1 (last' x!75!527))) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q' x!75!527) 4)
     (>= (q' x!508!528) 4)
     (<= (+ (first x!75!527) (* -1 (first' x!75!527))) 0)
     (>= (+ (first x!75!527) (* -1 (first' x!75!527))) 0)
     (= (first g) (first x!75!527))
     (<= (+ (first g) (* -1 (first x!75!527))) 0)
     (>= (+ (first g) (* -1 (first x!75!527))) 0)
     (= (first' g') (first' x!75!527))
     (<= (+ (first' g') (* -1 (first' x!75!527))) 0)
     (>= (+ (first' g') (* -1 (first' x!75!527))) 0))


unsat: proved claim
add rows:             795
added eqs:            1293
arith conflicts:      45
assert diseq:         201
assert lower:         1537
assert upper:         955
bound prop:           53
conflicts:            147
decisions:            482
del clause:           2185
eq adapter:           705
final checks:         125
fixed eqs:            267
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            2203
offset eqs:           49
pivots:               563
propagations:         865
quant instantiations: 1253
restarts:             8
max. heap size:     4.53029 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (>= x!80!530 1)
     (>= (+ N (* -1 x!80!530)) 0)
     (= (q x!80!530) 4)
     (= (q' x!80!530) 0)
     (= g' 0)
     (= (last x!80!530) (last' x!80!530))
     (= (first x!80!530) (first' x!80!530))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!80!530)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!508!531 1)
     (>= (+ N (* -1 x!508!531)) 0)
     (>= x!509!532 1)
     (>= (+ N (* -1 x!509!532)) 0)
     (= (q' x!508!531) 4)
     (<= g' 0)
     (<= (+ g' (* -1 x!508!531)) 0)
     (not (>= (+ g' (* -1 x!508!531)) 0))
     (not (or (not (= g x!80!530)) (= (q x!80!530) 2)))
     (>= (q x!80!530) 0)
     (<= (q x!80!530) 4)
     (not (>= g' 1))
     (>= (q' x!80!530) 0)
     (<= (q' x!80!530) 4)
     (>= (q' x!508!531) 0)
     (<= (q' x!508!531) 4)
     (>= (last' x!80!530) 0)
     (>= (last x!80!530) 0)
     (>= (first' x!80!530) 0)
     (>= (first x!80!530) 0)
     (not (= g' x!508!531))
     (= g x!80!530)
     (not (= (q x!80!530) 2))
     (<= (+ g (* -1 x!80!530)) 0)
     (>= (+ g (* -1 x!80!530)) 0)
     (not (= (q' x!508!531) 2))
     (>= (q x!80!530) 4)
     (<= (+ (last x!80!530) (* -1 (last' x!80!530))) 0)
     (>= (+ (last x!80!530) (* -1 (last' x!80!530))) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q' x!80!530) 0)
     (>= (q' x!508!531) 4)
     (<= (+ (first x!80!530) (* -1 (first' x!80!530))) 0)
     (>= (+ (first x!80!530) (* -1 (first' x!80!530))) 0)
     (= (first g) (first x!80!530))
     (<= (+ (first g) (* -1 (first x!80!530))) 0)
     (>= (+ (first g) (* -1 (first x!80!530))) 0)
     (not (<= (q x!80!530) 2))
     (>= (q x!80!530) 2)
     (>= g 1)
     (not (<= (q' x!508!531) 2))
     (>= (q' x!508!531) 2))


unsat: proved claim
add rows:             815
added eqs:            1324
arith conflicts:      45
assert diseq:         207
assert lower:         1561
assert upper:         968
bound prop:           56
conflicts:            149
decisions:            485
del clause:           2238
eq adapter:           720
final checks:         125
fixed eqs:            271
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            2253
offset eqs:           50
pivots:               572
propagations:         882
quant instantiations: 1289
restarts:             8
max. heap size:     4.53029 Mbytes
Unsat core:

Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (>= x!94!533 0)
     (forall (x!96 Real) (x!95 Int)
       (or (not (>= x!96 0))
           (not (<= (+ x!96 (* -1 x!94!533)) 0))
           (not (>= x!95 1))
           (not (>= (+ N (* -1 x!95)) 0))
           (not (or (not (or (not (= (q x!95) 0))
                             (= (+ now (+ (* -1 now') x!94!533)) 0)))
                    (not (or (not (= (q x!95) 1))
                             (= (+ now (+ (* -1 now') x!94!533)) 0)))
                    (not (or (not (= (q x!95) 2))
                             (not (or (not (<= (+ now
                                                  (+ x!96 (* -1 (last x!95))))
                                               0))
                                      (not (or (not (>= (+ now
                                                           (+ x!96
                                                              (* -1 (last x!95))))
                                                        0))
                                               (= x!94!533 x!96)))
                                      (not (= (+ now (+ (* -1 now') x!94!533))
                                              0))))))
                    (not (or (not (= (q x!95) 3))
                             (= (+ now (+ (* -1 now') x!94!533)) 0)))
                    (not (or (not (= (q x!95) 4))
                             (= (+ now (+ (* -1 now') x!94!533)) 0)))
                    (not (= (q x!95) (q' x!95)))
                    (not (= (last x!95) (last' x!95)))
                    (not (= (first x!95) (first' x!95)))
                    (not (= g g'))))))
     (>= x!508!534 1)
     (>= (+ N (* -1 x!508!534)) 0)
     (>= x!509!535 1)
     (>= (+ N (* -1 x!509!535)) 0)
     (= (q' x!508!534) 4)
     (>= (q' x!508!534) 0)
     (<= (q' x!508!534) 4)
     (>= (q' x!508!534) 4))


unsat: proved claim
add rows:             887
added eqs:            1403
arith conflicts:      47
assert diseq:         256
assert lower:         1656
assert upper:         1058
bound prop:           65
conflicts:            153
decisions:            612
del clause:           2421
eq adapter:           784
final checks:         130
fixed eqs:            290
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            2547
offset eqs:           56
pivots:               599
propagations:         1003
quant instantiations: 1391
restarts:             11
max. heap size:     4.77733 Mbytes
Unsat core:



Property was an inductive invariant! Property checked was: 
(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))


ASSUMPTIONS: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)}))



Properties proved and used as assumption lemmas: 


(forall (i Int)
  (implies (and (>= i 1) (<= i N))
           (implies (= (q i) 2) (<= (last i) (+ now A)))))


(forall (i Int)
  (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))


(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                    (> (first i) (last j)))))


(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))


Model for basic assumptions: 


A -> 1
N -> 4
g -> 1
B -> 2
now -> 1
g' -> 1
now' -> 1
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
Unsat core:

Term:
(implies (and (and (and (forall (i Int)
                          (implies (and (>= i 1) (<= i N))
                                   (and (and (and (= (last i) A)
                                                  (= (first i) 0))
                                             (= g 0))
                                        (= now 0))))
                        (= now 0))
                   (= g 0))
              (forall (i Int) (or (= (q i) 0))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (= now 0)
     (= g 0)
     (forall (x!36 Int)
       (or (not (>= x!36 1))
           (not (>= (+ N (* -1 x!36)) 0))
           (not (or (not (= (last x!36) A)) (not (= (first x!36) 0)))))
       :pat {(last x!36)}
       :pat {(first x!36)})
     (forall (x!38 Int) (= (q x!38) 0) :pat {(q x!38)})
     (>= x!0!666 1)
     (>= (+ N (* -1 x!0!666)) 0)
     (not (>= (last x!0!666) 0))
     (<= g 0)
     (not (or (not (= (last x!0!666) A)) (not (= (first x!0!666) 0))))
     (not (>= g 1)))


unsat: proved claim
add rows:             915
added eqs:            1405
arith conflicts:      47
assert diseq:         256
assert lower:         1658
assert upper:         1060
bound prop:           65
conflicts:            154
decisions:            612
del clause:           2547
eq adapter:           786
final checks:         132
fixed eqs:            290
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            2558
offset eqs:           57
pivots:               616
propagations:         1004
quant instantiations: 1396
restarts:             11
max. heap size:     4.77733 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 0) (= (q' h) 1))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!48!667 1)
     (>= (+ N (* -1 x!48!667)) 0)
     (= (q x!48!667) 0)
     (= (q' x!48!667) 1)
     (= (last x!48!667) (last' x!48!667))
     (= (first x!48!667) (first' x!48!667))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!48!667)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!668 1)
     (>= (+ N (* -1 x!219!668)) 0)
     (not (<= (+ now' (* -1 (last' x!219!668))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!48!667) 0)
     (<= (q x!48!667) 4)
     (>= (q' x!48!667) 0)
     (<= (q' x!48!667) 4)
     (>= (last' x!48!667) 0)
     (not (= (q' x!219!668) 2))
     (>= (last' x!219!668) 0)
     (<= (+ now (* -1 (last x!48!667))) 0)
     (>= (last x!48!667) 0)
     (>= (first' x!48!667) 0)
     (>= (first x!48!667) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!48!667) 0)
     (= (last' x!48!667) (last x!48!667))
     (<= (+ (last' x!48!667) (* -1 (last x!48!667))) 0)
     (>= (+ (last' x!48!667) (* -1 (last x!48!667))) 0)
     (<= (q' x!48!667) 1)
     (>= (q' x!48!667) 1)
     (<= (+ (first x!48!667) (* -1 (first' x!48!667))) 0)
     (>= (+ (first x!48!667) (* -1 (first' x!48!667))) 0)
     (>= (q' x!219!668) 0)
     (<= (q' x!219!668) 4)
     (<= (+ now' (* -1 (last' x!48!667))) 0))


unsat: proved claim
add rows:             948
added eqs:            1536
arith conflicts:      50
assert diseq:         276
assert lower:         1717
assert upper:         1130
bound prop:           78
conflicts:            160
decisions:            627
del clause:           2628
eq adapter:           832
final checks:         132
fixed eqs:            316
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            2707
offset eqs:           62
pivots:               636
propagations:         1073
quant instantiations: 1459
restarts:             11
max. heap size:     4.77733 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!55!669 1)
     (>= (+ N (* -1 x!55!669)) 0)
     (= (q x!55!669) 1)
     (= (q' x!55!669) 1)
     (not (= g 0))
     (= (last x!55!669) (last' x!55!669))
     (= (first x!55!669) (first' x!55!669))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!55!669)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!670 1)
     (>= (+ N (* -1 x!219!670)) 0)
     (not (<= (+ now' (* -1 (last' x!219!670))) 0))
     (not (<= g 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!55!669) 0)
     (<= (q x!55!669) 4)
     (>= (q' x!55!669) 0)
     (<= (q' x!55!669) 4)
     (>= (last' x!55!669) 0)
     (not (= (q' x!219!670) 2))
     (>= (last' x!219!670) 0)
     (<= (+ now (* -1 (last x!55!669))) 0)
     (>= (last x!55!669) 0)
     (>= (first' x!55!669) 0)
     (>= (first x!55!669) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!55!669) 1)
     (>= (q x!55!669) 1)
     (= (last' x!55!669) (last x!55!669))
     (<= (+ (last' x!55!669) (* -1 (last x!55!669))) 0)
     (>= (+ (last' x!55!669) (* -1 (last x!55!669))) 0)
     (<= (q' x!55!669) 1)
     (>= (q' x!55!669) 1)
     (<= (+ (first x!55!669) (* -1 (first' x!55!669))) 0)
     (>= (+ (first x!55!669) (* -1 (first' x!55!669))) 0)
     (>= (q' x!219!670) 0)
     (<= (q' x!219!670) 4)
     (<= (+ now' (* -1 (last' x!55!669))) 0))


unsat: proved claim
add rows:             995
added eqs:            1678
arith conflicts:      54
assert diseq:         304
assert lower:         1775
assert upper:         1205
bound prop:           89
conflicts:            167
decisions:            643
del clause:           2802
eq adapter:           882
final checks:         132
fixed eqs:            340
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            2891
offset eqs:           65
pivots:               657
propagations:         1147
quant instantiations: 1523
restarts:             11
max. heap size:     4.77733 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 2) (= g 0) (= (last' h) (+ now A)))
                 (and (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!60!671 1)
     (>= (+ N (* -1 x!60!671)) 0)
     (= (q x!60!671) 1)
     (= (q' x!60!671) 2)
     (= g 0)
     (= (+ A (+ now (* -1 (last' x!60!671)))) 0)
     (= (first x!60!671) (first' x!60!671))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!60!671)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!672 1)
     (>= (+ N (* -1 x!219!672)) 0)
     (not (<= (+ now' (* -1 (last' x!219!672))) 0))
     (<= g 0)
     (<= (+ A (+ now (* -1 (last' x!60!671)))) 0)
     (>= (+ A (+ now (* -1 (last' x!60!671)))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (not (>= g 1))
     (>= (q x!60!671) 0)
     (<= (q x!60!671) 4)
     (or (not (= g' x!60!671)) (= (q' x!60!671) 2))
     (not (= (q' x!60!671) 4))
     (<= (+ now' (* -1 (last' x!60!671))) 0)
     (>= (+ A (+ now' (* -1 (last' x!60!671)))) 0)
     (>= (q' x!60!671) 0)
     (<= (q' x!60!671) 4)
     (>= (last' x!60!671) 0)
     (not (= (q' x!219!672) 2))
     (>= (last' x!219!672) 0)
     (>= (first' x!60!671) 0)
     (>= (first x!60!671) 0)
     (<= (q x!60!671) 1)
     (>= (q x!60!671) 1)
     (<= (q' x!60!671) 2)
     (>= (q' x!60!671) 2)
     (<= (+ (first x!60!671) (* -1 (first' x!60!671))) 0)
     (>= (+ (first x!60!671) (* -1 (first' x!60!671))) 0)
     (not (>= (q' x!60!671) 4))
     (<= (+ g (* -1 x!60!671)) 0)
     (not (>= (+ g (* -1 x!60!671)) 0))
     (<= (+ g' (* -1 x!60!671)) 0)
     (not (>= (+ g' (* -1 x!60!671)) 0))
     (or (not (= g' x!219!672)) (= (q' x!60!671) 2))
     (not (= (q' x!219!672) 4))
     (>= (q' x!219!672) 0)
     (<= (q' x!219!672) 4)
     (not (= g x!60!671))
     (not (= g' x!60!671))
     (or (not (= g x!60!671)) (= (q x!60!671) 2))
     (not (= (q x!60!671) 4))
     (not (>= (q' x!219!672) 4))
     (not (>= (q x!60!671) 4))
     (<= (+ g' (* -1 x!219!672)) 0)
     (not (>= (+ g' (* -1 x!219!672)) 0))
     (not (= g' x!219!672))
     (or (not (= g' x!219!672)) (= (q' x!219!672) 2)))


unsat: proved claim
add rows:             1026
added eqs:            1703
arith conflicts:      55
assert diseq:         312
assert lower:         1801
assert upper:         1233
bound prop:           95
conflicts:            169
decisions:            646
del clause:           2894
eq adapter:           900
final checks:         132
fixed eqs:            347
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            2952
offset eqs:           68
pivots:               672
propagations:         1164
quant instantiations: 1552
restarts:             11
max. heap size:     4.80906 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 2)
                      (= (q' h) 3)
                      (<= now (last h))
                      (>= now (last h))
                      (and (= g' h) (= (first' h) (+ now B))))
                 (and (= (last h) (last' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!65!673 1)
     (>= (+ N (* -1 x!65!673)) 0)
     (= (q x!65!673) 2)
     (= (q' x!65!673) 3)
     (<= (+ now (* -1 (last x!65!673))) 0)
     (>= (+ now (* -1 (last x!65!673))) 0)
     (= g' x!65!673)
     (= (+ B (+ now (* -1 (first' x!65!673)))) 0)
     (= (last x!65!673) (last' x!65!673))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!65!673)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!674 1)
     (>= (+ N (* -1 x!219!674)) 0)
     (not (<= (+ now' (* -1 (last' x!219!674))) 0))
     (<= (+ g' (* -1 x!65!673)) 0)
     (>= (+ g' (* -1 x!65!673)) 0)
     (<= (+ B (+ now (* -1 (first' x!65!673)))) 0)
     (>= (+ B (+ now (* -1 (first' x!65!673)))) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (or (not (= g x!65!673)) (= (q x!65!673) 2))
     (not (= (q x!65!673) 4))
     (>= (+ A (+ now (* -1 (last x!65!673)))) 0)
     (>= (q x!65!673) 0)
     (<= (q x!65!673) 4)
     (>= (q' x!65!673) 0)
     (<= (q' x!65!673) 4)
     (>= (last x!65!673) 0)
     (>= (first' x!65!673) 0)
     (>= (last' x!65!673) 0)
     (not (= (q' x!219!674) 2))
     (>= (last' x!219!674) 0)
     (= (q' g') 3)
     (<= (q x!65!673) 2)
     (>= (q x!65!673) 2)
     (<= (+ (last x!65!673) (* -1 (last' x!65!673))) 0)
     (>= (+ (last x!65!673) (* -1 (last' x!65!673))) 0)
     (<= (q' x!65!673) 3)
     (>= (q' x!65!673) 3)
     (= (first' g') (first' x!65!673))
     (<= (+ (first' g') (* -1 (first' x!65!673))) 0)
     (>= (+ (first' g') (* -1 (first' x!65!673))) 0)
     (not (>= (q x!65!673) 4))
     (>= (q' x!219!674) 0)
     (<= (q' x!219!674) 4)
     (not (<= (+ (first' g') (* -1 (last' x!65!673))) 0))
     (<= (+ now' (* -1 (last' x!65!673))) 0)
     (>= (+ A (+ now' (* -1 (last' x!65!673)))) 0)
     (not (<= (+ (first' g') (* -1 (last' x!219!674))) 0)))


unsat: proved claim
add rows:             1054
added eqs:            1758
arith conflicts:      57
assert diseq:         321
assert lower:         1839
assert upper:         1258
bound prop:           99
conflicts:            173
decisions:            651
del clause:           2980
eq adapter:           922
final checks:         132
fixed eqs:            359
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3015
offset eqs:           74
pivots:               685
propagations:         1197
quant instantiations: 1582
restarts:             11
max. heap size:     4.80931 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3)
                      (= (q' h) 1)
                      (and (not (= g h)) (>= now (first h)))
                      (= (first' h) 0))
                 (and (= (last h) (last' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!70!675 1)
     (>= (+ N (* -1 x!70!675)) 0)
     (= (q x!70!675) 3)
     (= (q' x!70!675) 1)
     (not (= g x!70!675))
     (>= (+ now (* -1 (first x!70!675))) 0)
     (= (first' x!70!675) 0)
     (= (last x!70!675) (last' x!70!675))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!70!675)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!676 1)
     (>= (+ N (* -1 x!219!676)) 0)
     (not (<= (+ now' (* -1 (last' x!219!676))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (or (not (= g x!70!675)) (= (q x!70!675) 2))
     (not (= (q x!70!675) 4))
     (>= (q x!70!675) 0)
     (<= (q x!70!675) 4)
     (>= (q' x!70!675) 0)
     (<= (q' x!70!675) 4)
     (>= (first x!70!675) 0)
     (>= (first' x!70!675) 0)
     (>= (last' x!70!675) 0)
     (not (= (q' x!219!676) 2))
     (>= (last' x!219!676) 0)
     (<= (+ now (* -1 (last x!70!675))) 0)
     (>= (last x!70!675) 0)
     (not (= g' x!70!675))
     (<= (q x!70!675) 3)
     (>= (q x!70!675) 3)
     (<= (+ (last x!70!675) (* -1 (last' x!70!675))) 0)
     (>= (+ (last x!70!675) (* -1 (last' x!70!675))) 0)
     (<= (q' x!70!675) 1)
     (>= (q' x!70!675) 1)
     (<= (first' x!70!675) 0)
     (not (>= (q x!70!675) 4))
     (or (not (= g' x!70!675)) (= (q' x!219!676) 2))
     (not (= (q' x!70!675) 4))
     (>= (q' x!219!676) 0)
     (<= (q' x!219!676) 4)
     (or (not (= g' x!70!675)) (= (q' x!70!675) 2))
     (not (>= (q' x!70!675) 4))
     (<= (+ now' (* -1 (last' x!70!675))) 0))


unsat: proved claim
add rows:             1090
added eqs:            1810
arith conflicts:      59
assert diseq:         338
assert lower:         1876
assert upper:         1289
bound prop:           103
conflicts:            177
decisions:            656
del clause:           3057
eq adapter:           948
final checks:         132
fixed eqs:            370
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3097
offset eqs:           75
pivots:               704
propagations:         1226
quant instantiations: 1632
restarts:             11
max. heap size:     4.80931 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3) (= (q' h) 4) (and (= g h) (>= now (first h))))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!75!677 1)
     (>= (+ N (* -1 x!75!677)) 0)
     (= (q x!75!677) 3)
     (= (q' x!75!677) 4)
     (= g x!75!677)
     (>= (+ now (* -1 (first x!75!677))) 0)
     (= (last x!75!677) (last' x!75!677))
     (= (first x!75!677) (first' x!75!677))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!75!677)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!678 1)
     (>= (+ N (* -1 x!219!678)) 0)
     (not (<= (+ now' (* -1 (last' x!219!678))) 0))
     (<= (+ g (* -1 x!75!677)) 0)
     (>= (+ g (* -1 x!75!677)) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!75!677) 0)
     (<= (q x!75!677) 4)
     (= g' x!75!677)
     (<= (+ g' (* -1 x!75!677)) 0)
     (>= (+ g' (* -1 x!75!677)) 0)
     (not (or (not (= g' x!75!677)) (= (q' x!75!677) 2)))
     (>= (q' x!75!677) 0)
     (<= (q' x!75!677) 4)
     (>= (first x!75!677) 0)
     (>= (last' x!75!677) 0)
     (not (= (q' x!219!678) 2))
     (>= (last' x!219!678) 0)
     (<= (+ now (* -1 (last x!75!677))) 0)
     (>= (last x!75!677) 0)
     (>= (first' x!75!677) 0)
     (not (= (q' x!75!677) 2))
     (= (q g) 3)
     (<= (q x!75!677) 3)
     (>= (q x!75!677) 3)
     (<= (+ (last x!75!677) (* -1 (last' x!75!677))) 0)
     (>= (+ (last x!75!677) (* -1 (last' x!75!677))) 0)
     (>= (q' x!75!677) 4)
     (<= (+ (first x!75!677) (* -1 (first' x!75!677))) 0)
     (>= (+ (first x!75!677) (* -1 (first' x!75!677))) 0)
     (= (first g) (first x!75!677))
     (<= (+ (first g) (* -1 (first x!75!677))) 0)
     (>= (+ (first g) (* -1 (first x!75!677))) 0)
     (= (first' g') (first' x!75!677))
     (<= (+ (first' g') (* -1 (first' x!75!677))) 0)
     (>= (+ (first' g') (* -1 (first' x!75!677))) 0)
     (not (<= (q' x!75!677) 2))
     (>= (q' x!75!677) 2)
     (>= g' 1)
     (>= (q' x!219!678) 0)
     (<= (q' x!219!678) 4)
     (<= (+ now' (* -1 (last' x!75!677))) 0))


unsat: proved claim
add rows:             1119
added eqs:            1863
arith conflicts:      61
assert diseq:         345
assert lower:         1915
assert upper:         1314
bound prop:           105
conflicts:            181
decisions:            661
del clause:           3123
eq adapter:           970
final checks:         132
fixed eqs:            376
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3154
offset eqs:           76
pivots:               716
propagations:         1253
quant instantiations: 1663
restarts:             11
max. heap size:     4.80931 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!80!679 1)
     (>= (+ N (* -1 x!80!679)) 0)
     (= (q x!80!679) 4)
     (= (q' x!80!679) 0)
     (= g' 0)
     (= (last x!80!679) (last' x!80!679))
     (= (first x!80!679) (first' x!80!679))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!80!679)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!680 1)
     (>= (+ N (* -1 x!219!680)) 0)
     (not (<= (+ now' (* -1 (last' x!219!680))) 0))
     (<= g' 0)
     (not (or (not (= g x!80!679)) (= (q x!80!679) 2)))
     (>= (q x!80!679) 0)
     (<= (q x!80!679) 4)
     (not (>= g' 1))
     (>= (q' x!80!679) 0)
     (<= (q' x!80!679) 4)
     (>= (last' x!80!679) 0)
     (not (= (q' x!219!680) 2))
     (>= (last' x!219!680) 0)
     (<= (+ now (* -1 (last x!80!679))) 0)
     (>= (last x!80!679) 0)
     (>= (first' x!80!679) 0)
     (>= (first x!80!679) 0)
     (= g x!80!679)
     (not (= (q x!80!679) 2))
     (<= (+ g (* -1 x!80!679)) 0)
     (>= (+ g (* -1 x!80!679)) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!80!679) 4)
     (<= (+ (last x!80!679) (* -1 (last' x!80!679))) 0)
     (>= (+ (last x!80!679) (* -1 (last' x!80!679))) 0)
     (<= (q' x!80!679) 0)
     (<= (+ (first x!80!679) (* -1 (first' x!80!679))) 0)
     (>= (+ (first x!80!679) (* -1 (first' x!80!679))) 0)
     (= (first g) (first x!80!679))
     (<= (+ (first g) (* -1 (first x!80!679))) 0)
     (>= (+ (first g) (* -1 (first x!80!679))) 0)
     (not (<= (q x!80!679) 2))
     (>= (q x!80!679) 2)
     (>= g 1)
     (<= (+ g' (* -1 x!80!679)) 0)
     (not (>= (+ g' (* -1 x!80!679)) 0))
     (>= (q' x!219!680) 0)
     (<= (q' x!219!680) 4)
     (not (= g' x!80!679))
     (or (not (= g' x!80!679)) (= (q' x!80!679) 2))
     (or (not (= g' x!80!679)) (= (q' x!219!680) 2))
     (not (= (q' x!80!679) 4))
     (not (>= (q' x!80!679) 4))
     (<= (+ g' (* -1 x!219!680)) 0)
     (not (>= (+ g' (* -1 x!219!680)) 0))
     (<= (+ now' (* -1 (last' x!80!679))) 0)
     (not (= g' x!219!680))
     (or (not (= g' x!219!680)) (= (q' x!219!680) 2))
     (or (not (= g' x!219!680)) (= (q' x!80!679) 2))
     (not (= (q' x!219!680) 4))
     (not (>= (q' x!219!680) 4)))


unsat: proved claim
add rows:             1137
added eqs:            1890
arith conflicts:      62
assert diseq:         351
assert lower:         1943
assert upper:         1340
bound prop:           111
conflicts:            183
decisions:            663
del clause:           3204
eq adapter:           988
final checks:         132
fixed eqs:            383
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3216
offset eqs:           78
pivots:               727
propagations:         1272
quant instantiations: 1694
restarts:             11
max. heap size:     4.80931 Mbytes
Unsat core:

Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!94!681 0)
     (forall (x!96 Real) (x!95 Int)
       (or (not (>= x!96 0))
           (not (<= (+ x!96 (* -1 x!94!681)) 0))
           (not (>= x!95 1))
           (not (>= (+ N (* -1 x!95)) 0))
           (not (or (not (or (not (= (q x!95) 0))
                             (= (+ now (+ (* -1 now') x!94!681)) 0)))
                    (not (or (not (= (q x!95) 1))
                             (= (+ now (+ (* -1 now') x!94!681)) 0)))
                    (not (or (not (= (q x!95) 2))
                             (not (or (not (<= (+ now
                                                  (+ x!96 (* -1 (last x!95))))
                                               0))
                                      (not (or (not (>= (+ now
                                                           (+ x!96
                                                              (* -1 (last x!95))))
                                                        0))
                                               (= x!94!681 x!96)))
                                      (not (= (+ now (+ (* -1 now') x!94!681))
                                              0))))))
                    (not (or (not (= (q x!95) 3))
                             (= (+ now (+ (* -1 now') x!94!681)) 0)))
                    (not (or (not (= (q x!95) 4))
                             (= (+ now (+ (* -1 now') x!94!681)) 0)))
                    (not (= (q x!95) (q' x!95)))
                    (not (= (last x!95) (last' x!95)))
                    (not (= (first x!95) (first' x!95)))
                    (not (= g g'))))))
     (>= x!219!682 1)
     (>= (+ N (* -1 x!219!682)) 0)
     (not (<= (+ now' (* -1 (last' x!219!682))) 0))
     (not (= (q' x!219!682) 2))
     (>= (last' x!219!682) 0)
     (>= (q' x!219!682) 0)
     (<= (q' x!219!682) 4))


sat: disproved claim
A -> 1
N -> 4
g -> 1
x!219!682 -> 1
now -> 0
g' -> 1
now' -> 1
B -> 2
x!94!681 -> 1
last' -> {
  #unspecified
}
first' -> {
  #unspecified
}
first -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
add rows:             1157
added eqs:            1924
arith conflicts:      62
assert diseq:         360
assert lower:         1967
assert upper:         1369
bound prop:           120
conflicts:            183
decisions:            674
del clause:           3262
eq adapter:           1006
final checks:         134
fixed eqs:            394
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3341
offset eqs:           78
pivots:               741
propagations:         1307
quant instantiations: 1711
restarts:             12
max. heap size:     4.80931 Mbytes


Property was NOT an inductive invariant! Property checked was: 
(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))


Property was NOT inductive! Property checked was: 
(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
Term:
(implies (and (and (and (forall (i Int)
                          (implies (and (>= i 1) (<= i N))
                                   (and (and (and (= (last i) A)
                                                  (= (first i) 0))
                                             (= g 0))
                                        (= now 0))))
                        (= now 0))
                   (= g 0))
              (forall (i Int) (or (= (q i) 0))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q i) 4)) (not (= (q j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (= now 0)
     (= g 0)
     (forall (x!36 Int)
       (or (not (>= x!36 1))
           (not (>= (+ N (* -1 x!36)) 0))
           (not (or (not (= (last x!36) A)) (not (= (first x!36) 0)))))
       :pat {(last x!36)}
       :pat {(first x!36)})
     (forall (x!38 Int) (= (q x!38) 0) :pat {(q x!38)})
     (>= x!733!737 1)
     (>= (+ N (* -1 x!733!737)) 0)
     (>= x!734!738 1)
     (>= (+ N (* -1 x!734!738)) 0)
     (not (= x!733!737 x!734!738))
     (= (q x!733!737) 4)
     (= (q x!734!738) 4)
     (<= g 0)
     (= (q x!733!737) 0)
     (not (or (not (= g x!733!737)) (= (q x!733!737) 2)))
     (not (or (not (= g x!734!738)) (= (q x!733!737) 2)))
     (not (or (not (= g x!733!737)) (= (q x!734!738) 2)))
     (not (>= g 1))
     (>= (q x!733!737) 0)
     (<= (q x!733!737) 4)
     (= (q x!734!738) 0)
     (not (or (not (= g x!734!738)) (= (q x!734!738) 2)))
     (>= (q x!734!738) 0)
     (<= (q x!734!738) 4)
     (= g x!733!737)
     (not (= (q x!733!737) 2))
     (= g x!734!738)
     (not (= (q x!734!738) 2))
     (<= (+ g (* -1 x!733!737)) 0)
     (>= (+ g (* -1 x!733!737)) 0)
     (<= (+ g (* -1 x!734!738)) 0)
     (>= (+ g (* -1 x!734!738)) 0))


unsat: proved claim
add rows:             1171
added eqs:            1931
arith conflicts:      62
assert diseq:         362
assert lower:         1975
assert upper:         1374
bound prop:           120
conflicts:            185
decisions:            676
del clause:           3348
eq adapter:           1011
final checks:         137
fixed eqs:            394
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3378
offset eqs:           79
pivots:               756
propagations:         1318
quant instantiations: 1726
restarts:             12
max. heap size:     4.94923 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 0) (= (q' h) 1))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (>= x!48!743 1)
     (>= (+ N (* -1 x!48!743)) 0)
     (= (q x!48!743) 0)
     (= (q' x!48!743) 1)
     (= (last x!48!743) (last' x!48!743))
     (= (first x!48!743) (first' x!48!743))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!48!743)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!739!744 1)
     (>= (+ N (* -1 x!739!744)) 0)
     (>= x!740!745 1)
     (>= (+ N (* -1 x!740!745)) 0)
     (not (= x!739!744 x!740!745))
     (= (q' x!739!744) 4)
     (= (q' x!740!745) 4)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!48!743) 0)
     (<= (q x!48!743) 4)
     (not (or (not (= g' x!739!744)) (= (q' x!48!743) 2)))
     (not (or (not (= g' x!740!745)) (= (q' x!48!743) 2)))
     (>= (q' x!48!743) 0)
     (<= (q' x!48!743) 4)
     (not (or (not (= g' x!739!744)) (= (q' x!739!744) 2)))
     (not (or (not (= g' x!740!745)) (= (q' x!739!744) 2)))
     (not (or (not (= g' x!739!744)) (= (q' x!740!745) 2)))
     (>= (q' x!739!744) 0)
     (<= (q' x!739!744) 4)
     (not (or (not (= g' x!740!745)) (= (q' x!740!745) 2)))
     (>= (q' x!740!745) 0)
     (<= (q' x!740!745) 4)
     (>= (last' x!48!743) 0)
     (>= (last x!48!743) 0)
     (>= (first' x!48!743) 0)
     (>= (first x!48!743) 0)
     (= g' x!739!744)
     (not (= (q' x!48!743) 2))
     (= g' x!740!745)
     (not (= (q' x!739!744) 2))
     (not (= (q' x!740!745) 2))
     (<= (+ g' (* -1 x!739!744)) 0)
     (>= (+ g' (* -1 x!739!744)) 0)
     (<= (+ g' (* -1 x!740!745)) 0)
     (>= (+ g' (* -1 x!740!745)) 0))


unsat: proved claim
add rows:             1178
added eqs:            1950
arith conflicts:      62
assert diseq:         365
assert lower:         1986
assert upper:         1379
bound prop:           120
conflicts:            187
decisions:            678
del clause:           3382
eq adapter:           1020
final checks:         140
fixed eqs:            395
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3470
offset eqs:           79
pivots:               761
propagations:         1331
quant instantiations: 1762
restarts:             12
max. heap size:     5.64447 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (>= x!55!746 1)
     (>= (+ N (* -1 x!55!746)) 0)
     (= (q x!55!746) 1)
     (= (q' x!55!746) 1)
     (not (= g 0))
     (= (last x!55!746) (last' x!55!746))
     (= (first x!55!746) (first' x!55!746))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!55!746)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!739!747 1)
     (>= (+ N (* -1 x!739!747)) 0)
     (>= x!740!748 1)
     (>= (+ N (* -1 x!740!748)) 0)
     (not (= x!739!747 x!740!748))
     (= (q' x!739!747) 4)
     (= (q' x!740!748) 4)
     (not (<= g 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!55!746) 0)
     (<= (q x!55!746) 4)
     (not (or (not (= g' x!739!747)) (= (q' x!55!746) 2)))
     (not (or (not (= g' x!740!748)) (= (q' x!55!746) 2)))
     (>= (q' x!55!746) 0)
     (<= (q' x!55!746) 4)
     (not (or (not (= g' x!739!747)) (= (q' x!739!747) 2)))
     (not (or (not (= g' x!740!748)) (= (q' x!739!747) 2)))
     (not (or (not (= g' x!739!747)) (= (q' x!740!748) 2)))
     (>= (q' x!739!747) 0)
     (<= (q' x!739!747) 4)
     (not (or (not (= g' x!740!748)) (= (q' x!740!748) 2)))
     (>= (q' x!740!748) 0)
     (<= (q' x!740!748) 4)
     (>= (last' x!55!746) 0)
     (>= (last x!55!746) 0)
     (>= (first' x!55!746) 0)
     (>= (first x!55!746) 0)
     (= g' x!739!747)
     (not (= (q' x!55!746) 2))
     (= g' x!740!748)
     (not (= (q' x!739!747) 2))
     (not (= (q' x!740!748) 2))
     (<= (+ g' (* -1 x!739!747)) 0)
     (>= (+ g' (* -1 x!739!747)) 0)
     (<= (+ g' (* -1 x!740!748)) 0)
     (>= (+ g' (* -1 x!740!748)) 0)
     (not (= (q x!55!746) 2)))


unsat: proved claim
add rows:             1179
added eqs:            1968
arith conflicts:      62
assert diseq:         367
assert lower:         1994
assert upper:         1380
bound prop:           120
conflicts:            188
decisions:            678
del clause:           3470
eq adapter:           1029
final checks:         140
fixed eqs:            396
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3560
offset eqs:           79
pivots:               762
propagations:         1343
quant instantiations: 1798
restarts:             12
max. heap size:     5.8546 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 2) (= g 0) (= (last' h) (+ now A)))
                 (and (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (>= x!60!749 1)
     (>= (+ N (* -1 x!60!749)) 0)
     (= (q x!60!749) 1)
     (= (q' x!60!749) 2)
     (= g 0)
     (= (+ A (+ now (* -1 (last' x!60!749)))) 0)
     (= (first x!60!749) (first' x!60!749))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!60!749)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!739!750 1)
     (>= (+ N (* -1 x!739!750)) 0)
     (>= x!740!751 1)
     (>= (+ N (* -1 x!740!751)) 0)
     (not (= x!739!750 x!740!751))
     (= (q' x!739!750) 4)
     (= (q' x!740!751) 4)
     (<= g 0)
     (<= (+ A (+ now (* -1 (last' x!60!749)))) 0)
     (>= (+ A (+ now (* -1 (last' x!60!749)))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (not (= x!740!751 x!739!750))
     (not (>= g 1))
     (>= (q x!60!749) 0)
     (<= (q x!60!749) 4)
     (or (not (= g' x!60!749)) (= (q' x!60!749) 2))
     (not (= (q' x!60!749) 4))
     (or (not (= g' x!739!750)) (= (q' x!60!749) 2))
     (or (not (= g' x!740!751)) (= (q' x!60!749) 2))
     (<= (+ now' (* -1 (last' x!60!749))) 0)
     (>= (+ A (+ now' (* -1 (last' x!60!749)))) 0)
     (>= (q' x!60!749) 0)
     (<= (q' x!60!749) 4)
     (not (or (not (= g' x!739!750)) (= (q' x!739!750) 2)))
     (not (or (not (= g' x!740!751)) (= (q' x!739!750) 2)))
     (not (or (not (= g' x!739!750)) (= (q' x!740!751) 2)))
     (>= (q' x!739!750) 0)
     (<= (q' x!739!750) 4)
     (not (or (not (= g' x!740!751)) (= (q' x!740!751) 2)))
     (>= (q' x!740!751) 0)
     (<= (q' x!740!751) 4)
     (>= (last' x!60!749) 0)
     (>= (first' x!60!749) 0)
     (>= (first x!60!749) 0))


unsat: proved claim
add rows:             1185
added eqs:            1978
arith conflicts:      62
assert diseq:         368
assert lower:         2002
assert upper:         1383
bound prop:           120
conflicts:            189
decisions:            678
del clause:           3560
eq adapter:           1039
final checks:         140
fixed eqs:            397
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3630
offset eqs:           82
pivots:               764
propagations:         1348
quant instantiations: 1825
restarts:             12
max. heap size:     5.93638 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 2)
                      (= (q' h) 3)
                      (<= now (last h))
                      (>= now (last h))
                      (and (= g' h) (= (first' h) (+ now B))))
                 (and (= (last h) (last' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (>= x!65!752 1)
     (>= (+ N (* -1 x!65!752)) 0)
     (= (q x!65!752) 2)
     (= (q' x!65!752) 3)
     (<= (+ now (* -1 (last x!65!752))) 0)
     (>= (+ now (* -1 (last x!65!752))) 0)
     (= g' x!65!752)
     (= (+ B (+ now (* -1 (first' x!65!752)))) 0)
     (= (last x!65!752) (last' x!65!752))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!65!752)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!739!753 1)
     (>= (+ N (* -1 x!739!753)) 0)
     (>= x!740!754 1)
     (>= (+ N (* -1 x!740!754)) 0)
     (not (= x!739!753 x!740!754))
     (= (q' x!739!753) 4)
     (= (q' x!740!754) 4)
     (<= (+ g' (* -1 x!65!752)) 0)
     (>= (+ g' (* -1 x!65!752)) 0)
     (<= (+ B (+ now (* -1 (first' x!65!752)))) 0)
     (>= (+ B (+ now (* -1 (first' x!65!752)))) 0)
     (not (= x!740!754 x!739!753))
     (or (not (= g x!65!752)) (= (q x!65!752) 2))
     (not (= (q x!65!752) 4))
     (>= (+ A (+ now (* -1 (last x!65!752)))) 0)
     (>= (q x!65!752) 0)
     (<= (q x!65!752) 4)
     (not (or (not (= g' x!739!753)) (= (q' x!65!752) 2)))
     (not (or (not (= g' x!740!754)) (= (q' x!65!752) 2)))
     (>= (q' x!65!752) 0)
     (<= (q' x!65!752) 4)
     (not (or (not (= g' x!739!753)) (= (q' x!739!753) 2)))
     (not (or (not (= g' x!740!754)) (= (q' x!739!753) 2)))
     (not (or (not (= g' x!739!753)) (= (q' x!740!754) 2)))
     (>= (q' x!739!753) 0)
     (<= (q' x!739!753) 4)
     (not (or (not (= g' x!740!754)) (= (q' x!740!754) 2)))
     (>= (q' x!740!754) 0)
     (<= (q' x!740!754) 4)
     (>= (last x!65!752) 0)
     (>= (first' x!65!752) 0)
     (>= (last' x!65!752) 0)
     (= g' x!739!753)
     (not (= (q' x!65!752) 2))
     (= g' x!740!754)
     (not (= (q' x!739!753) 2))
     (not (= (q' x!740!754) 2))
     (<= (+ g' (* -1 x!739!753)) 0)
     (>= (+ g' (* -1 x!739!753)) 0)
     (not (or (not (= g' x!65!752)) (= (q' x!65!752) 2)))
     (<= (+ g' (* -1 x!740!754)) 0)
     (>= (+ g' (* -1 x!740!754)) 0)
     (= (q' g') 3)
     (= x!739!753 x!65!752)
     (= x!65!752 x!739!753)
     (= x!740!754 x!65!752)
     (= x!65!752 x!740!754))


unsat: proved claim
add rows:             1190
added eqs:            2000
arith conflicts:      62
assert diseq:         369
assert lower:         2011
assert upper:         1386
bound prop:           120
conflicts:            190
decisions:            678
del clause:           3630
eq adapter:           1047
final checks:         140
fixed eqs:            398
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3698
offset eqs:           83
pivots:               768
propagations:         1362
quant instantiations: 1852
restarts:             12
max. heap size:     5.97613 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3)
                      (= (q' h) 1)
                      (and (not (= g h)) (>= now (first h)))
                      (= (first' h) 0))
                 (and (= (last h) (last' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (>= x!70!755 1)
     (>= (+ N (* -1 x!70!755)) 0)
     (= (q x!70!755) 3)
     (= (q' x!70!755) 1)
     (not (= g x!70!755))
     (>= (+ now (* -1 (first x!70!755))) 0)
     (= (first' x!70!755) 0)
     (= (last x!70!755) (last' x!70!755))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!70!755)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!739!756 1)
     (>= (+ N (* -1 x!739!756)) 0)
     (>= x!740!757 1)
     (>= (+ N (* -1 x!740!757)) 0)
     (not (= x!739!756 x!740!757))
     (= (q' x!739!756) 4)
     (= (q' x!740!757) 4)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (not (= x!740!757 x!739!756))
     (or (not (= g x!70!755)) (= (q x!70!755) 2))
     (not (= (q x!70!755) 4))
     (>= (q x!70!755) 0)
     (<= (q x!70!755) 4)
     (not (or (not (= g' x!739!756)) (= (q' x!70!755) 2)))
     (not (or (not (= g' x!740!757)) (= (q' x!70!755) 2)))
     (>= (q' x!70!755) 0)
     (<= (q' x!70!755) 4)
     (not (or (not (= g' x!739!756)) (= (q' x!739!756) 2)))
     (not (or (not (= g' x!740!757)) (= (q' x!739!756) 2)))
     (not (or (not (= g' x!739!756)) (= (q' x!740!757) 2)))
     (>= (q' x!739!756) 0)
     (<= (q' x!739!756) 4)
     (not (or (not (= g' x!740!757)) (= (q' x!740!757) 2)))
     (>= (q' x!740!757) 0)
     (<= (q' x!740!757) 4)
     (>= (first x!70!755) 0)
     (>= (first' x!70!755) 0)
     (>= (last' x!70!755) 0)
     (>= (last x!70!755) 0)
     (= g' x!739!756)
     (not (= (q' x!70!755) 2))
     (= g' x!740!757)
     (not (= (q' x!739!756) 2))
     (not (= (q' x!740!757) 2))
     (<= (+ g' (* -1 x!739!756)) 0)
     (>= (+ g' (* -1 x!739!756)) 0)
     (<= (+ g' (* -1 x!740!757)) 0)
     (>= (+ g' (* -1 x!740!757)) 0)
     (not (= g' x!70!755)))


unsat: proved claim
add rows:             1195
added eqs:            2016
arith conflicts:      62
assert diseq:         371
assert lower:         2019
assert upper:         1387
bound prop:           120
conflicts:            191
decisions:            678
del clause:           3698
eq adapter:           1055
final checks:         140
fixed eqs:            398
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3782
offset eqs:           83
pivots:               771
propagations:         1373
quant instantiations: 1888
restarts:             12
max. heap size:     5.97613 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3) (= (q' h) 4) (and (= g h) (>= now (first h))))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (>= x!75!758 1)
     (>= (+ N (* -1 x!75!758)) 0)
     (= (q x!75!758) 3)
     (= (q' x!75!758) 4)
     (= g x!75!758)
     (>= (+ now (* -1 (first x!75!758))) 0)
     (= (last x!75!758) (last' x!75!758))
     (= (first x!75!758) (first' x!75!758))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!75!758)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!739!759 1)
     (>= (+ N (* -1 x!739!759)) 0)
     (>= x!740!760 1)
     (>= (+ N (* -1 x!740!760)) 0)
     (not (= x!739!759 x!740!760))
     (= (q' x!739!759) 4)
     (= (q' x!740!760) 4)
     (<= (+ g (* -1 x!75!758)) 0)
     (>= (+ g (* -1 x!75!758)) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (not (= x!740!760 x!739!759))
     (>= (q x!75!758) 0)
     (<= (q x!75!758) 4)
     (= g' x!75!758)
     (<= (+ g' (* -1 x!75!758)) 0)
     (>= (+ g' (* -1 x!75!758)) 0)
     (not (or (not (= g' x!75!758)) (= (q' x!75!758) 2)))
     (not (or (not (= g' x!739!759)) (= (q' x!75!758) 2)))
     (not (or (not (= g' x!740!760)) (= (q' x!75!758) 2)))
     (not (or (not (= g' x!75!758)) (= (q' x!739!759) 2)))
     (not (or (not (= g' x!75!758)) (= (q' x!740!760) 2)))
     (>= (q' x!75!758) 0)
     (<= (q' x!75!758) 4)
     (not (or (not (= g' x!739!759)) (= (q' x!739!759) 2)))
     (not (or (not (= g' x!740!760)) (= (q' x!739!759) 2)))
     (not (or (not (= g' x!739!759)) (= (q' x!740!760) 2)))
     (>= (q' x!739!759) 0)
     (<= (q' x!739!759) 4)
     (not (or (not (= g' x!740!760)) (= (q' x!740!760) 2)))
     (>= (q' x!740!760) 0)
     (<= (q' x!740!760) 4)
     (>= (first x!75!758) 0)
     (>= (last' x!75!758) 0)
     (>= (last x!75!758) 0)
     (>= (first' x!75!758) 0)
     (not (= (q' x!75!758) 2))
     (= g' x!739!759)
     (= g' x!740!760)
     (not (= (q' x!739!759) 2))
     (not (= (q' x!740!760) 2))
     (<= (+ g' (* -1 x!739!759)) 0)
     (>= (+ g' (* -1 x!739!759)) 0)
     (<= (+ g' (* -1 x!740!760)) 0)
     (>= (+ g' (* -1 x!740!760)) 0)
     (= (q g) 3)
     (= x!739!759 x!75!758)
     (= x!75!758 x!739!759)
     (= x!740!760 x!75!758)
     (= x!75!758 x!740!760))


unsat: proved claim
add rows:             1202
added eqs:            2041
arith conflicts:      62
assert diseq:         372
assert lower:         2028
assert upper:         1389
bound prop:           120
conflicts:            192
decisions:            678
del clause:           3782
eq adapter:           1063
final checks:         140
fixed eqs:            399
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3860
offset eqs:           83
pivots:               774
propagations:         1386
quant instantiations: 1924
restarts:             12
max. heap size:     5.97613 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (>= x!80!761 1)
     (>= (+ N (* -1 x!80!761)) 0)
     (= (q x!80!761) 4)
     (= (q' x!80!761) 0)
     (= g' 0)
     (= (last x!80!761) (last' x!80!761))
     (= (first x!80!761) (first' x!80!761))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!80!761)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!739!762 1)
     (>= (+ N (* -1 x!739!762)) 0)
     (>= x!740!763 1)
     (>= (+ N (* -1 x!740!763)) 0)
     (not (= x!739!762 x!740!763))
     (= (q' x!739!762) 4)
     (= (q' x!740!763) 4)
     (<= g' 0)
     (not (= x!740!763 x!739!762))
     (not (or (not (= g x!80!761)) (= (q x!80!761) 2)))
     (>= (q x!80!761) 0)
     (<= (q x!80!761) 4)
     (not (or (not (= g' x!739!762)) (= (q' x!80!761) 2)))
     (not (or (not (= g' x!740!763)) (= (q' x!80!761) 2)))
     (not (>= g' 1))
     (>= (q' x!80!761) 0)
     (<= (q' x!80!761) 4)
     (not (or (not (= g' x!739!762)) (= (q' x!739!762) 2)))
     (not (or (not (= g' x!740!763)) (= (q' x!739!762) 2)))
     (not (or (not (= g' x!739!762)) (= (q' x!740!763) 2)))
     (>= (q' x!739!762) 0)
     (<= (q' x!739!762) 4)
     (not (or (not (= g' x!740!763)) (= (q' x!740!763) 2)))
     (>= (q' x!740!763) 0)
     (<= (q' x!740!763) 4)
     (>= (last' x!80!761) 0)
     (>= (last x!80!761) 0)
     (>= (first' x!80!761) 0)
     (>= (first x!80!761) 0)
     (= g x!80!761)
     (not (= (q x!80!761) 2))
     (= g' x!739!762)
     (not (= (q' x!80!761) 2))
     (= g' x!740!763)
     (not (= (q' x!739!762) 2))
     (not (= (q' x!740!763) 2))
     (<= (+ g (* -1 x!80!761)) 0)
     (>= (+ g (* -1 x!80!761)) 0)
     (<= (+ g' (* -1 x!739!762)) 0)
     (>= (+ g' (* -1 x!739!762)) 0)
     (<= (+ g' (* -1 x!740!763)) 0)
     (>= (+ g' (* -1 x!740!763)) 0))


unsat: proved claim
add rows:             1204
added eqs:            2061
arith conflicts:      62
assert diseq:         373
assert lower:         2034
assert upper:         1390
bound prop:           120
conflicts:            193
decisions:            678
del clause:           3860
eq adapter:           1071
final checks:         140
fixed eqs:            399
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3942
offset eqs:           84
pivots:               776
propagations:         1400
quant instantiations: 1958
restarts:             12
max. heap size:     5.97613 Mbytes
Unsat core:

Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (>= x!94!764 0)
     (forall (x!96 Real) (x!95 Int)
       (or (not (>= x!96 0))
           (not (<= (+ x!96 (* -1 x!94!764)) 0))
           (not (>= x!95 1))
           (not (>= (+ N (* -1 x!95)) 0))
           (not (or (not (or (not (= (q x!95) 0))
                             (= (+ now (+ (* -1 now') x!94!764)) 0)))
                    (not (or (not (= (q x!95) 1))
                             (= (+ now (+ (* -1 now') x!94!764)) 0)))
                    (not (or (not (= (q x!95) 2))
                             (not (or (not (<= (+ now
                                                  (+ x!96 (* -1 (last x!95))))
                                               0))
                                      (not (or (not (>= (+ now
                                                           (+ x!96
                                                              (* -1 (last x!95))))
                                                        0))
                                               (= x!94!764 x!96)))
                                      (not (= (+ now (+ (* -1 now') x!94!764))
                                              0))))))
                    (not (or (not (= (q x!95) 3))
                             (= (+ now (+ (* -1 now') x!94!764)) 0)))
                    (not (or (not (= (q x!95) 4))
                             (= (+ now (+ (* -1 now') x!94!764)) 0)))
                    (not (= (q x!95) (q' x!95)))
                    (not (= (last x!95) (last' x!95)))
                    (not (= (first x!95) (first' x!95)))
                    (not (= g g'))))))
     (>= x!739!765 1)
     (>= (+ N (* -1 x!739!765)) 0)
     (>= x!740!766 1)
     (>= (+ N (* -1 x!740!766)) 0)
     (not (= x!739!765 x!740!766))
     (= (q' x!739!765) 4)
     (= (q' x!740!766) 4)
     (not (= x!740!766 x!739!765))
     (not (or (not (= g' x!739!765)) (= (q' x!739!765) 2)))
     (not (or (not (= g' x!740!766)) (= (q' x!739!765) 2)))
     (not (or (not (= g' x!739!765)) (= (q' x!740!766) 2)))
     (>= (q' x!739!765) 0)
     (<= (q' x!739!765) 4)
     (not (or (not (= g' x!740!766)) (= (q' x!740!766) 2)))
     (>= (q' x!740!766) 0)
     (<= (q' x!740!766) 4)
     (= g' x!739!765)
     (not (= (q' x!739!765) 2))
     (= g' x!740!766)
     (not (= (q' x!740!766) 2))
     (<= (+ g' (* -1 x!739!765)) 0)
     (>= (+ g' (* -1 x!739!765)) 0)
     (<= (+ g' (* -1 x!740!766)) 0)
     (>= (+ g' (* -1 x!740!766)) 0))


unsat: proved claim
add rows:             1204
added eqs:            2066
arith conflicts:      62
assert diseq:         374
assert lower:         2039
assert upper:         1390
bound prop:           120
conflicts:            194
decisions:            678
del clause:           3942
eq adapter:           1074
final checks:         140
fixed eqs:            399
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3972
offset eqs:           84
pivots:               776
propagations:         1408
quant instantiations: 1972
restarts:             12
max. heap size:     5.97613 Mbytes
Unsat core:



Property was an inductive invariant! Property checked was: 
(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))


ASSUMPTIONS: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (forall (x!740 Int) (x!739 Int)
       (or (not (>= x!739 1))
           (not (>= (+ N (* -1 x!739)) 0))
           (not (>= x!740 1))
           (not (>= (+ N (* -1 x!740)) 0))
           (= x!739 x!740)
           (not (= (q' x!739) 4))
           (not (= (q' x!740) 4)))
       :pat {(q' x!739) (q' x!740)}))



Properties proved and used as assumption lemmas: 


(forall (i Int)
  (implies (and (>= i 1) (<= i N))
           (implies (= (q i) 2) (<= (last i) (+ now A)))))


(forall (i Int)
  (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))


(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                    (> (first i) (last j)))))


(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))


(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))


Model for basic assumptions: 


A -> 1
N -> 4
g -> 1
B -> 2
now -> 1
g' -> 0
now' -> 1
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
Unsat core:

Term:
(implies (and (and (and (forall (i Int)
                          (implies (and (>= i 1) (<= i N))
                                   (and (and (and (= (last i) A)
                                                  (= (first i) 0))
                                             (= g 0))
                                        (= now 0))))
                        (= now 0))
                   (= g 0))
              (forall (i Int) (or (= (q i) 0))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (forall (x!740 Int) (x!739 Int)
       (or (not (>= x!739 1))
           (not (>= (+ N (* -1 x!739)) 0))
           (not (>= x!740 1))
           (not (>= (+ N (* -1 x!740)) 0))
           (= x!739 x!740)
           (not (= (q' x!739) 4))
           (not (= (q' x!740) 4)))
       :pat {(q' x!739) (q' x!740)})
     (= now 0)
     (= g 0)
     (forall (x!36 Int)
       (or (not (>= x!36 1))
           (not (>= (+ N (* -1 x!36)) 0))
           (not (or (not (= (last x!36) A)) (not (= (first x!36) 0)))))
       :pat {(last x!36)}
       :pat {(first x!36)})
     (forall (x!38 Int) (= (q x!38) 0) :pat {(q x!38)})
     (>= x!0!819 1)
     (>= (+ N (* -1 x!0!819)) 0)
     (not (>= (last x!0!819) 0))
     (<= g 0)
     (not (or (not (= (last x!0!819) A)) (not (= (first x!0!819) 0))))
     (not (>= g 1)))


unsat: proved claim
add rows:             1204
added eqs:            2068
arith conflicts:      62
assert diseq:         374
assert lower:         2041
assert upper:         1392
bound prop:           120
conflicts:            195
decisions:            678
del clause:           3972
eq adapter:           1076
final checks:         142
fixed eqs:            399
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3983
offset eqs:           85
pivots:               776
propagations:         1409
quant instantiations: 1977
restarts:             12
max. heap size:     5.97613 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 0) (= (q' h) 1))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (forall (x!740 Int) (x!739 Int)
       (or (not (>= x!739 1))
           (not (>= (+ N (* -1 x!739)) 0))
           (not (>= x!740 1))
           (not (>= (+ N (* -1 x!740)) 0))
           (= x!739 x!740)
           (not (= (q' x!739) 4))
           (not (= (q' x!740) 4)))
       :pat {(q' x!739) (q' x!740)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!48!820 1)
     (>= (+ N (* -1 x!48!820)) 0)
     (= (q x!48!820) 0)
     (= (q' x!48!820) 1)
     (= (last x!48!820) (last' x!48!820))
     (= (first x!48!820) (first' x!48!820))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!48!820)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!821 1)
     (>= (+ N (* -1 x!219!821)) 0)
     (not (<= (+ now' (* -1 (last' x!219!821))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!48!820) 0)
     (<= (q x!48!820) 4)
     (>= (q' x!48!820) 0)
     (<= (q' x!48!820) 4)
     (>= (last' x!48!820) 0)
     (not (= (q' x!219!821) 2))
     (>= (last' x!219!821) 0)
     (<= (+ now (* -1 (last x!48!820))) 0)
     (>= (last x!48!820) 0)
     (>= (first' x!48!820) 0)
     (>= (first x!48!820) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!48!820) 0)
     (= (last' x!48!820) (last x!48!820))
     (<= (+ (last' x!48!820) (* -1 (last x!48!820))) 0)
     (>= (+ (last' x!48!820) (* -1 (last x!48!820))) 0)
     (<= (q' x!48!820) 1)
     (>= (q' x!48!820) 1)
     (<= (+ (first x!48!820) (* -1 (first' x!48!820))) 0)
     (>= (+ (first x!48!820) (* -1 (first' x!48!820))) 0)
     (>= (q' x!219!821) 0)
     (<= (q' x!219!821) 4)
     (<= (+ now' (* -1 (last' x!48!820))) 0))


unsat: proved claim
add rows:             1240
added eqs:            2137
arith conflicts:      64
assert diseq:         380
assert lower:         2080
assert upper:         1426
bound prop:           123
conflicts:            198
decisions:            683
del clause:           4048
eq adapter:           1101
final checks:         142
fixed eqs:            414
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4103
offset eqs:           87
pivots:               790
propagations:         1435
quant instantiations: 2039
restarts:             12
max. heap size:     5.98506 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (forall (x!740 Int) (x!739 Int)
       (or (not (>= x!739 1))
           (not (>= (+ N (* -1 x!739)) 0))
           (not (>= x!740 1))
           (not (>= (+ N (* -1 x!740)) 0))
           (= x!739 x!740)
           (not (= (q' x!739) 4))
           (not (= (q' x!740) 4)))
       :pat {(q' x!739) (q' x!740)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!55!822 1)
     (>= (+ N (* -1 x!55!822)) 0)
     (= (q x!55!822) 1)
     (= (q' x!55!822) 1)
     (not (= g 0))
     (= (last x!55!822) (last' x!55!822))
     (= (first x!55!822) (first' x!55!822))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!55!822)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!823 1)
     (>= (+ N (* -1 x!219!823)) 0)
     (not (<= (+ now' (* -1 (last' x!219!823))) 0))
     (not (<= g 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!55!822) 0)
     (<= (q x!55!822) 4)
     (>= (q' x!55!822) 0)
     (<= (q' x!55!822) 4)
     (>= (last' x!55!822) 0)
     (not (= (q' x!219!823) 2))
     (>= (last' x!219!823) 0)
     (<= (+ now (* -1 (last x!55!822))) 0)
     (>= (last x!55!822) 0)
     (>= (first' x!55!822) 0)
     (>= (first x!55!822) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!55!822) 1)
     (>= (q x!55!822) 1)
     (<= (+ (last x!55!822) (* -1 (last' x!55!822))) 0)
     (>= (+ (last x!55!822) (* -1 (last' x!55!822))) 0)
     (<= (q' x!55!822) 1)
     (>= (q' x!55!822) 1)
     (= (first' x!55!822) (first x!55!822))
     (<= (+ (first' x!55!822) (* -1 (first x!55!822))) 0)
     (>= (+ (first' x!55!822) (* -1 (first x!55!822))) 0)
     (>= (q' x!219!823) 0)
     (<= (q' x!219!823) 4)
     (<= (+ now' (* -1 (last' x!55!822))) 0))


unsat: proved claim
add rows:             1284
added eqs:            2282
arith conflicts:      68
assert diseq:         415
assert lower:         2135
assert upper:         1500
bound prop:           129
conflicts:            205
decisions:            699
del clause:           4172
eq adapter:           1151
final checks:         142
fixed eqs:            438
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4243
offset eqs:           88
pivots:               812
propagations:         1515
quant instantiations: 2110
restarts:             12
max. heap size:     6.03139 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 2) (= g 0) (= (last' h) (+ now A)))
                 (and (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (forall (x!740 Int) (x!739 Int)
       (or (not (>= x!739 1))
           (not (>= (+ N (* -1 x!739)) 0))
           (not (>= x!740 1))
           (not (>= (+ N (* -1 x!740)) 0))
           (= x!739 x!740)
           (not (= (q' x!739) 4))
           (not (= (q' x!740) 4)))
       :pat {(q' x!739) (q' x!740)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!60!824 1)
     (>= (+ N (* -1 x!60!824)) 0)
     (= (q x!60!824) 1)
     (= (q' x!60!824) 2)
     (= g 0)
     (= (+ A (+ now (* -1 (last' x!60!824)))) 0)
     (= (first x!60!824) (first' x!60!824))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!60!824)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!825 1)
     (>= (+ N (* -1 x!219!825)) 0)
     (not (<= (+ now' (* -1 (last' x!219!825))) 0))
     (<= g 0)
     (<= (+ A (+ now (* -1 (last' x!60!824)))) 0)
     (>= (+ A (+ now (* -1 (last' x!60!824)))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (not (>= g 1))
     (>= (q x!60!824) 0)
     (<= (q x!60!824) 4)
     (or (not (= g' x!60!824)) (= (q' x!60!824) 2))
     (not (= (q' x!60!824) 4))
     (<= (+ now' (* -1 (last' x!60!824))) 0)
     (>= (+ A (+ now' (* -1 (last' x!60!824)))) 0)
     (>= (q' x!60!824) 0)
     (<= (q' x!60!824) 4)
     (>= (last' x!60!824) 0)
     (not (= (q' x!219!825) 2))
     (>= (last' x!219!825) 0)
     (>= (first' x!60!824) 0)
     (>= (first x!60!824) 0)
     (<= (q x!60!824) 1)
     (>= (q x!60!824) 1)
     (<= (q' x!60!824) 2)
     (>= (q' x!60!824) 2)
     (= (first' x!60!824) (first x!60!824))
     (<= (+ (first' x!60!824) (* -1 (first x!60!824))) 0)
     (>= (+ (first' x!60!824) (* -1 (first x!60!824))) 0)
     (not (>= (q' x!60!824) 4))
     (<= (+ g (* -1 x!60!824)) 0)
     (not (>= (+ g (* -1 x!60!824)) 0))
     (<= (+ g' (* -1 x!60!824)) 0)
     (not (>= (+ g' (* -1 x!60!824)) 0))
     (or (not (= g' x!219!825)) (= (q' x!60!824) 2))
     (not (= (q' x!219!825) 4))
     (>= (q' x!219!825) 0)
     (<= (q' x!219!825) 4)
     (not (= g x!60!824))
     (not (= g' x!60!824))
     (or (not (= g x!60!824)) (= (q x!60!824) 2))
     (not (= (q x!60!824) 4))
     (not (>= (q' x!219!825) 4))
     (not (>= (q x!60!824) 4))
     (<= (+ g' (* -1 x!219!825)) 0)
     (not (>= (+ g' (* -1 x!219!825)) 0))
     (not (= g' x!219!825))
     (or (not (= g' x!219!825)) (= (q' x!219!825) 2)))


unsat: proved claim
add rows:             1312
added eqs:            2306
arith conflicts:      69
assert diseq:         423
assert lower:         2161
assert upper:         1528
bound prop:           135
conflicts:            207
decisions:            702
del clause:           4290
eq adapter:           1169
final checks:         142
fixed eqs:            445
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4304
offset eqs:           91
pivots:               826
propagations:         1534
quant instantiations: 2139
restarts:             12
max. heap size:     6.09957 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 2)
                      (= (q' h) 3)
                      (<= now (last h))
                      (>= now (last h))
                      (and (= g' h) (= (first' h) (+ now B))))
                 (and (= (last h) (last' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (forall (x!740 Int) (x!739 Int)
       (or (not (>= x!739 1))
           (not (>= (+ N (* -1 x!739)) 0))
           (not (>= x!740 1))
           (not (>= (+ N (* -1 x!740)) 0))
           (= x!739 x!740)
           (not (= (q' x!739) 4))
           (not (= (q' x!740) 4)))
       :pat {(q' x!739) (q' x!740)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!65!826 1)
     (>= (+ N (* -1 x!65!826)) 0)
     (= (q x!65!826) 2)
     (= (q' x!65!826) 3)
     (<= (+ now (* -1 (last x!65!826))) 0)
     (>= (+ now (* -1 (last x!65!826))) 0)
     (= g' x!65!826)
     (= (+ B (+ now (* -1 (first' x!65!826)))) 0)
     (= (last x!65!826) (last' x!65!826))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!65!826)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!827 1)
     (>= (+ N (* -1 x!219!827)) 0)
     (not (<= (+ now' (* -1 (last' x!219!827))) 0))
     (<= (+ g' (* -1 x!65!826)) 0)
     (>= (+ g' (* -1 x!65!826)) 0)
     (<= (+ B (+ now (* -1 (first' x!65!826)))) 0)
     (>= (+ B (+ now (* -1 (first' x!65!826)))) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (or (not (= g x!65!826)) (= (q x!65!826) 2))
     (not (= (q x!65!826) 4))
     (>= (+ A (+ now (* -1 (last x!65!826)))) 0)
     (>= (q x!65!826) 0)
     (<= (q x!65!826) 4)
     (>= (q' x!65!826) 0)
     (<= (q' x!65!826) 4)
     (>= (last x!65!826) 0)
     (>= (first' x!65!826) 0)
     (>= (last' x!65!826) 0)
     (not (= (q' x!219!827) 2))
     (>= (last' x!219!827) 0)
     (= (q' g') 3)
     (<= (q x!65!826) 2)
     (>= (q x!65!826) 2)
     (= (last' x!65!826) (last x!65!826))
     (<= (+ (last' x!65!826) (* -1 (last x!65!826))) 0)
     (>= (+ (last' x!65!826) (* -1 (last x!65!826))) 0)
     (<= (q' x!65!826) 3)
     (>= (q' x!65!826) 3)
     (= (first' g') (first' x!65!826))
     (<= (+ (first' g') (* -1 (first' x!65!826))) 0)
     (>= (+ (first' g') (* -1 (first' x!65!826))) 0)
     (not (>= (q x!65!826) 4))
     (>= (q' x!219!827) 0)
     (<= (q' x!219!827) 4)
     (not (<= (+ (first' g') (* -1 (last' x!65!826))) 0))
     (<= (+ now' (* -1 (last' x!65!826))) 0)
     (>= (+ A (+ now' (* -1 (last' x!65!826)))) 0)
     (not (<= (+ (first' g') (* -1 (last' x!219!827))) 0)))


unsat: proved claim
add rows:             1339
added eqs:            2362
arith conflicts:      71
assert diseq:         432
assert lower:         2199
assert upper:         1553
bound prop:           139
conflicts:            211
decisions:            706
del clause:           4332
eq adapter:           1191
final checks:         142
fixed eqs:            457
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4369
offset eqs:           97
pivots:               839
propagations:         1567
quant instantiations: 2171
restarts:             12
max. heap size:     6.12212 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3)
                      (= (q' h) 1)
                      (and (not (= g h)) (>= now (first h)))
                      (= (first' h) 0))
                 (and (= (last h) (last' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (forall (x!740 Int) (x!739 Int)
       (or (not (>= x!739 1))
           (not (>= (+ N (* -1 x!739)) 0))
           (not (>= x!740 1))
           (not (>= (+ N (* -1 x!740)) 0))
           (= x!739 x!740)
           (not (= (q' x!739) 4))
           (not (= (q' x!740) 4)))
       :pat {(q' x!739) (q' x!740)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!70!828 1)
     (>= (+ N (* -1 x!70!828)) 0)
     (= (q x!70!828) 3)
     (= (q' x!70!828) 1)
     (not (= g x!70!828))
     (>= (+ now (* -1 (first x!70!828))) 0)
     (= (first' x!70!828) 0)
     (= (last x!70!828) (last' x!70!828))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!70!828)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!829 1)
     (>= (+ N (* -1 x!219!829)) 0)
     (not (<= (+ now' (* -1 (last' x!219!829))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (or (not (= g x!70!828)) (= (q x!70!828) 2))
     (not (= (q x!70!828) 4))
     (>= (q x!70!828) 0)
     (<= (q x!70!828) 4)
     (>= (q' x!70!828) 0)
     (<= (q' x!70!828) 4)
     (>= (first x!70!828) 0)
     (>= (first' x!70!828) 0)
     (>= (last' x!70!828) 0)
     (not (= (q' x!219!829) 2))
     (>= (last' x!219!829) 0)
     (<= (+ now (* -1 (last x!70!828))) 0)
     (>= (last x!70!828) 0)
     (not (= g' x!70!828))
     (<= (q x!70!828) 3)
     (>= (q x!70!828) 3)
     (= (last' x!70!828) (last x!70!828))
     (<= (+ (last' x!70!828) (* -1 (last x!70!828))) 0)
     (>= (+ (last' x!70!828) (* -1 (last x!70!828))) 0)
     (<= (q' x!70!828) 1)
     (>= (q' x!70!828) 1)
     (<= (first' x!70!828) 0)
     (not (>= (q x!70!828) 4))
     (or (not (= g' x!70!828)) (= (q' x!219!829) 2))
     (not (= (q' x!70!828) 4))
     (>= (q' x!219!829) 0)
     (<= (q' x!219!829) 4)
     (or (not (= g' x!70!828)) (= (q' x!70!828) 2))
     (not (>= (q' x!70!828) 4))
     (<= (+ now' (* -1 (last' x!70!828))) 0))


unsat: proved claim
add rows:             1374
added eqs:            2416
arith conflicts:      73
assert diseq:         447
assert lower:         2236
assert upper:         1583
bound prop:           142
conflicts:            215
decisions:            711
del clause:           4407
eq adapter:           1214
final checks:         142
fixed eqs:            468
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4448
offset eqs:           98
pivots:               858
propagations:         1597
quant instantiations: 2225
restarts:             12
max. heap size:     6.12212 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3) (= (q' h) 4) (and (= g h) (>= now (first h))))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (forall (x!740 Int) (x!739 Int)
       (or (not (>= x!739 1))
           (not (>= (+ N (* -1 x!739)) 0))
           (not (>= x!740 1))
           (not (>= (+ N (* -1 x!740)) 0))
           (= x!739 x!740)
           (not (= (q' x!739) 4))
           (not (= (q' x!740) 4)))
       :pat {(q' x!739) (q' x!740)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!75!830 1)
     (>= (+ N (* -1 x!75!830)) 0)
     (= (q x!75!830) 3)
     (= (q' x!75!830) 4)
     (= g x!75!830)
     (>= (+ now (* -1 (first x!75!830))) 0)
     (= (last x!75!830) (last' x!75!830))
     (= (first x!75!830) (first' x!75!830))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!75!830)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!831 1)
     (>= (+ N (* -1 x!219!831)) 0)
     (not (<= (+ now' (* -1 (last' x!219!831))) 0))
     (<= (+ g (* -1 x!75!830)) 0)
     (>= (+ g (* -1 x!75!830)) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!75!830) 0)
     (<= (q x!75!830) 4)
     (= g' x!75!830)
     (<= (+ g' (* -1 x!75!830)) 0)
     (>= (+ g' (* -1 x!75!830)) 0)
     (not (or (not (= g' x!75!830)) (= (q' x!75!830) 2)))
     (>= (q' x!75!830) 0)
     (<= (q' x!75!830) 4)
     (>= (first x!75!830) 0)
     (>= (last' x!75!830) 0)
     (not (= (q' x!219!831) 2))
     (>= (last' x!219!831) 0)
     (<= (+ now (* -1 (last x!75!830))) 0)
     (>= (last x!75!830) 0)
     (>= (first' x!75!830) 0)
     (not (= (q' x!75!830) 2))
     (= (q g) 3)
     (<= (q x!75!830) 3)
     (>= (q x!75!830) 3)
     (<= (+ (last x!75!830) (* -1 (last' x!75!830))) 0)
     (>= (+ (last x!75!830) (* -1 (last' x!75!830))) 0)
     (>= (q' x!75!830) 4)
     (= (first' x!75!830) (first x!75!830))
     (<= (+ (first' x!75!830) (* -1 (first x!75!830))) 0)
     (>= (+ (first' x!75!830) (* -1 (first x!75!830))) 0)
     (= (first g) (first x!75!830))
     (<= (+ (first g) (* -1 (first x!75!830))) 0)
     (>= (+ (first g) (* -1 (first x!75!830))) 0)
     (= (first' g') (first' x!75!830))
     (<= (+ (first' g') (* -1 (first' x!75!830))) 0)
     (>= (+ (first' g') (* -1 (first' x!75!830))) 0)
     (not (<= (q' x!75!830) 2))
     (>= (q' x!75!830) 2)
     (>= (q' x!219!831) 0)
     (<= (q' x!219!831) 4)
     (<= (+ now' (* -1 (last' x!75!830))) 0))


unsat: proved claim
add rows:             1406
added eqs:            2469
arith conflicts:      75
assert diseq:         454
assert lower:         2273
assert upper:         1610
bound prop:           143
conflicts:            219
decisions:            715
del clause:           4473
eq adapter:           1236
final checks:         142
fixed eqs:            474
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4506
offset eqs:           99
pivots:               870
propagations:         1624
quant instantiations: 2258
restarts:             12
max. heap size:     6.12212 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (forall (x!740 Int) (x!739 Int)
       (or (not (>= x!739 1))
           (not (>= (+ N (* -1 x!739)) 0))
           (not (>= x!740 1))
           (not (>= (+ N (* -1 x!740)) 0))
           (= x!739 x!740)
           (not (= (q' x!739) 4))
           (not (= (q' x!740) 4)))
       :pat {(q' x!739) (q' x!740)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!80!832 1)
     (>= (+ N (* -1 x!80!832)) 0)
     (= (q x!80!832) 4)
     (= (q' x!80!832) 0)
     (= g' 0)
     (= (last x!80!832) (last' x!80!832))
     (= (first x!80!832) (first' x!80!832))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!80!832)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!833 1)
     (>= (+ N (* -1 x!219!833)) 0)
     (not (<= (+ now' (* -1 (last' x!219!833))) 0))
     (<= g' 0)
     (not (or (not (= g x!80!832)) (= (q x!80!832) 2)))
     (>= (q x!80!832) 0)
     (<= (q x!80!832) 4)
     (not (>= g' 1))
     (>= (q' x!80!832) 0)
     (<= (q' x!80!832) 4)
     (>= (last' x!80!832) 0)
     (not (= (q' x!219!833) 2))
     (>= (last' x!219!833) 0)
     (<= (+ now (* -1 (last x!80!832))) 0)
     (>= (last x!80!832) 0)
     (>= (first' x!80!832) 0)
     (>= (first x!80!832) 0)
     (= g x!80!832)
     (not (= (q x!80!832) 2))
     (<= (+ g (* -1 x!80!832)) 0)
     (>= (+ g (* -1 x!80!832)) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!80!832) 4)
     (<= (+ (last x!80!832) (* -1 (last' x!80!832))) 0)
     (>= (+ (last x!80!832) (* -1 (last' x!80!832))) 0)
     (<= (q' x!80!832) 0)
     (= (first' x!80!832) (first x!80!832))
     (<= (+ (first' x!80!832) (* -1 (first x!80!832))) 0)
     (>= (+ (first' x!80!832) (* -1 (first x!80!832))) 0)
     (= (first g) (first x!80!832))
     (<= (+ (first g) (* -1 (first x!80!832))) 0)
     (>= (+ (first g) (* -1 (first x!80!832))) 0)
     (not (<= (q x!80!832) 2))
     (>= (q x!80!832) 2)
     (>= g 1)
     (<= (+ g' (* -1 x!80!832)) 0)
     (not (>= (+ g' (* -1 x!80!832)) 0))
     (>= (q' x!219!833) 0)
     (<= (q' x!219!833) 4)
     (not (= g' x!80!832))
     (or (not (= g' x!80!832)) (= (q' x!80!832) 2))
     (or (not (= g' x!80!832)) (= (q' x!219!833) 2))
     (not (= (q' x!80!832) 4))
     (not (>= (q' x!80!832) 4))
     (<= (+ g' (* -1 x!219!833)) 0)
     (not (>= (+ g' (* -1 x!219!833)) 0))
     (<= (+ now' (* -1 (last' x!80!832))) 0)
     (not (= g' x!219!833))
     (or (not (= g' x!219!833)) (= (q' x!219!833) 2))
     (or (not (= g' x!219!833)) (= (q' x!80!832) 2))
     (not (= (q' x!219!833) 4))
     (not (>= (q' x!219!833) 4)))


unsat: proved claim
add rows:             1424
added eqs:            2496
arith conflicts:      76
assert diseq:         462
assert lower:         2301
assert upper:         1636
bound prop:           149
conflicts:            221
decisions:            717
del clause:           4558
eq adapter:           1254
final checks:         142
fixed eqs:            481
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4570
offset eqs:           101
pivots:               882
propagations:         1646
quant instantiations: 2291
restarts:             12
max. heap size:     6.12212 Mbytes
Unsat core:

Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (not (>= (+ A (* -1 B)) 0))
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (forall (x!282 Int)
       (or (not (>= g' 1))
           (not (>= (+ N (* -1 g')) 0))
           (not (>= x!282 1))
           (not (>= (+ N (* -1 x!282)) 0))
           (not (= (q' g') 3))
           (not (= (q' x!282) 2))
           (not (>= (+ (last' x!282) (* -1 (first' g'))) 0)))
       :pat {(q' x!282)}
       :pat {(last' x!282)})
     (forall (x!505 Int) (x!504 Int)
       (or (not (>= x!504 1))
           (not (>= (+ N (* -1 x!504)) 0))
           (not (>= x!505 1))
           (not (>= (+ N (* -1 x!505)) 0))
           (not (= (q x!504) 4))
           (not (or (not (= g x!504)) (= (q x!505) 2))))
       :pat {(q x!504) (q x!505)})
     (forall (x!509 Int) (x!508 Int)
       (or (not (>= x!508 1))
           (not (>= (+ N (* -1 x!508)) 0))
           (not (>= x!509 1))
           (not (>= (+ N (* -1 x!509)) 0))
           (not (= (q' x!508) 4))
           (not (or (not (= g' x!508)) (= (q' x!509) 2))))
       :pat {(q' x!508) (q' x!509)})
     (forall (x!734 Int) (x!733 Int)
       (or (not (>= x!733 1))
           (not (>= (+ N (* -1 x!733)) 0))
           (not (>= x!734 1))
           (not (>= (+ N (* -1 x!734)) 0))
           (= x!733 x!734)
           (not (= (q x!733) 4))
           (not (= (q x!734) 4)))
       :pat {(q x!733) (q x!734)})
     (forall (x!740 Int) (x!739 Int)
       (or (not (>= x!739 1))
           (not (>= (+ N (* -1 x!739)) 0))
           (not (>= x!740 1))
           (not (>= (+ N (* -1 x!740)) 0))
           (= x!739 x!740)
           (not (= (q' x!739) 4))
           (not (= (q' x!740) 4)))
       :pat {(q' x!739) (q' x!740)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!94!834 0)
     (forall (x!96 Real) (x!95 Int)
       (or (not (>= x!96 0))
           (not (<= (+ x!96 (* -1 x!94!834)) 0))
           (not (>= x!95 1))
           (not (>= (+ N (* -1 x!95)) 0))
           (not (or (not (or (not (= (q x!95) 0))
                             (= (+ now (+ (* -1 now') x!94!834)) 0)))
                    (not (or (not (= (q x!95) 1))
                             (= (+ now (+ (* -1 now') x!94!834)) 0)))
                    (not (or (not (= (q x!95) 2))
                             (not (or (not (<= (+ now
                                                  (+ x!96 (* -1 (last x!95))))
                                               0))
                                      (not (or (not (>= (+ now
                                                           (+ x!96
                                                              (* -1 (last x!95))))
                                                        0))
                                               (= x!94!834 x!96)))
                                      (not (= (+ now (+ (* -1 now') x!94!834))
                                              0))))))
                    (not (or (not (= (q x!95) 3))
                             (= (+ now (+ (* -1 now') x!94!834)) 0)))
                    (not (or (not (= (q x!95) 4))
                             (= (+ now (+ (* -1 now') x!94!834)) 0)))
                    (not (= (q x!95) (q' x!95)))
                    (not (= (last x!95) (last' x!95)))
                    (not (= (first x!95) (first' x!95)))
                    (not (= g g'))))))
     (>= x!219!835 1)
     (>= (+ N (* -1 x!219!835)) 0)
     (not (<= (+ now' (* -1 (last' x!219!835))) 0))
     (not (= (q' x!219!835) 2))
     (>= (last' x!219!835) 0)
     (>= (q' x!219!835) 0)
     (<= (q' x!219!835) 4))


sat: disproved claim
A -> 1
N -> 4
g -> 0
x!219!835 -> 1
now -> 0
g' -> 0
x!94!834 -> 1
now' -> 1
B -> 2
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
add rows:             1434
added eqs:            2511
arith conflicts:      76
assert diseq:         473
assert lower:         2317
assert upper:         1664
bound prop:           156
conflicts:            221
decisions:            733
del clause:           4619
eq adapter:           1270
final checks:         144
fixed eqs:            487
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4700
offset eqs:           101
pivots:               892
propagations:         1681
quant instantiations: 2305
restarts:             13
max. heap size:     6.27983 Mbytes


Property was NOT an inductive invariant! Property checked was: 
(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))


Property was NOT inductive! Property checked was: 
(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))


DISPROVED INVARIANTS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

PROPERTY DISPROVED =====================================================================

(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))


Time: 0.3243449

REASONS (counterexample / trace):

Counterexample model:

A -> 1
N -> 4
g -> 0
x!219!835 -> 1
now -> 0
g' -> 0
x!94!834 -> 1
now' -> 1
B -> 2
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}



Inductive invariant claim:


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


END PROPERTY DISPROVED =====================================================================




DISPROVED INVARIANTS SUMMARY WITH STATISTICS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))

Time: 0.3243449


Statistics: 

add rows:             225
added eqs:            357
arith conflicts:      19
assert diseq:         14
assert lower:         525
assert upper:         277
bound prop:           2
conflicts:            62
decisions:            144
del clause:           583
eq adapter:           198
final checks:         89
fixed eqs:            73
max generation:       2
mk clause:            596
offset eqs:           17
pivots:               227
propagations:         219
quant instantiations: 351
restarts:             2
max. heap size:     2.87951 Mbytes



add rows:             240
added eqs:            379
arith conflicts:      20
assert diseq:         16
assert lower:         552
assert upper:         295
bound prop:           3
conflicts:            64
decisions:            146
del clause:           613
eq adapter:           210
final checks:         89
fixed eqs:            79
max generation:       2
mk clause:            626
offset eqs:           18
pivots:               239
propagations:         228
quant instantiations: 375
restarts:             2
max. heap size:     2.87951 Mbytes



add rows:             257
added eqs:            403
arith conflicts:      21
assert diseq:         17
assert lower:         578
assert upper:         313
bound prop:           3
conflicts:            66
decisions:            148
del clause:           643
eq adapter:           222
final checks:         89
fixed eqs:            86
max generation:       2
mk clause:            656
offset eqs:           21
pivots:               251
propagations:         239
quant instantiations: 397
restarts:             2
max. heap size:     2.87951 Mbytes



add rows:             273
added eqs:            429
arith conflicts:      22
assert diseq:         18
assert lower:         606
assert upper:         331
bound prop:           5
conflicts:            68
decisions:            150
del clause:           675
eq adapter:           233
final checks:         89
fixed eqs:            93
max generation:       2
mk clause:            686
offset eqs:           25
pivots:               264
propagations:         249
quant instantiations: 420
restarts:             2
max. heap size:     2.87951 Mbytes



add rows:             291
added eqs:            450
arith conflicts:      23
assert diseq:         20
assert lower:         632
assert upper:         349
bound prop:           6
conflicts:            70
decisions:            152
del clause:           702
eq adapter:           245
final checks:         89
fixed eqs:            98
max generation:       2
mk clause:            717
offset eqs:           26
pivots:               278
propagations:         257
quant instantiations: 444
restarts:             2
max. heap size:     2.87951 Mbytes



add rows:             310
added eqs:            470
arith conflicts:      24
assert diseq:         21
assert lower:         660
assert upper:         367
bound prop:           7
conflicts:            72
decisions:            154
del clause:           735
eq adapter:           257
final checks:         89
fixed eqs:            100
max generation:       2
mk clause:            748
offset eqs:           27
pivots:               292
propagations:         267
quant instantiations: 468
restarts:             2
max. heap size:     2.87951 Mbytes



add rows:             326
added eqs:            491
arith conflicts:      25
assert diseq:         22
assert lower:         684
assert upper:         384
bound prop:           8
conflicts:            74
decisions:            156
del clause:           759
eq adapter:           268
final checks:         89
fixed eqs:            105
max generation:       2
mk clause:            772
offset eqs:           29
pivots:               304
propagations:         274
quant instantiations: 492
restarts:             2
max. heap size:     2.87951 Mbytes



add rows:             335
added eqs:            504
arith conflicts:      25
assert diseq:         24
assert lower:         699
assert upper:         398
bound prop:           10
conflicts:            74
decisions:            163
del clause:           803
eq adapter:           275
final checks:         91
fixed eqs:            109
max generation:       2
mk clause:            820
offset eqs:           29
pivots:               314
propagations:         293
quant instantiations: 503
restarts:             3
max. heap size:     2.87951 Mbytes



add rows:             516
added eqs:            845
arith conflicts:      36
assert diseq:         122
assert lower:         1059
assert upper:         675
bound prop:           19
conflicts:            111
decisions:            353
del clause:           1447
eq adapter:           463
final checks:         108
fixed eqs:            184
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1474
offset eqs:           32
pivots:               419
propagations:         624
quant instantiations: 811
restarts:             7
max. heap size:     3.61553 Mbytes



add rows:             537
added eqs:            867
arith conflicts:      37
assert diseq:         124
assert lower:         1086
assert upper:         693
bound prop:           20
conflicts:            113
decisions:            356
del clause:           1477
eq adapter:           475
final checks:         108
fixed eqs:            190
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1507
offset eqs:           33
pivots:               431
propagations:         633
quant instantiations: 838
restarts:             7
max. heap size:     3.61553 Mbytes



add rows:             561
added eqs:            891
arith conflicts:      38
assert diseq:         125
assert lower:         1112
assert upper:         712
bound prop:           20
conflicts:            115
decisions:            359
del clause:           1510
eq adapter:           487
final checks:         108
fixed eqs:            197
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1539
offset eqs:           36
pivots:               443
propagations:         644
quant instantiations: 863
restarts:             7
max. heap size:     3.61553 Mbytes



add rows:             585
added eqs:            920
arith conflicts:      39
assert diseq:         126
assert lower:         1142
assert upper:         731
bound prop:           24
conflicts:            117
decisions:            361
del clause:           1563
eq adapter:           499
final checks:         108
fixed eqs:            205
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1575
offset eqs:           40
pivots:               457
propagations:         654
quant instantiations: 889
restarts:             7
max. heap size:     3.61553 Mbytes



add rows:             610
added eqs:            940
arith conflicts:      40
assert diseq:         128
assert lower:         1168
assert upper:         749
bound prop:           25
conflicts:            119
decisions:            364
del clause:           1592
eq adapter:           511
final checks:         108
fixed eqs:            210
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1609
offset eqs:           41
pivots:               472
propagations:         662
quant instantiations: 916
restarts:             7
max. heap size:     3.61553 Mbytes



add rows:             635
added eqs:            966
arith conflicts:      41
assert diseq:         129
assert lower:         1198
assert upper:         769
bound prop:           26
conflicts:            121
decisions:            367
del clause:           1630
eq adapter:           525
final checks:         108
fixed eqs:            212
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1645
offset eqs:           42
pivots:               486
propagations:         672
quant instantiations: 943
restarts:             7
max. heap size:     3.61553 Mbytes



add rows:             655
added eqs:            987
arith conflicts:      42
assert diseq:         130
assert lower:         1222
assert upper:         787
bound prop:           27
conflicts:            123
decisions:            369
del clause:           1656
eq adapter:           536
final checks:         108
fixed eqs:            217
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1670
offset eqs:           44
pivots:               498
propagations:         679
quant instantiations: 969
restarts:             7
max. heap size:     3.61553 Mbytes



add rows:             670
added eqs:            1003
arith conflicts:      42
assert diseq:         137
assert lower:         1239
assert upper:         809
bound prop:           29
conflicts:            124
decisions:            390
del clause:           1706
eq adapter:           548
final checks:         110
fixed eqs:            225
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1735
offset eqs:           44
pivots:               509
propagations:         707
quant instantiations: 986
restarts:             8
max. heap size:     3.61553 Mbytes



add rows:             948
added eqs:            1536
arith conflicts:      50
assert diseq:         276
assert lower:         1717
assert upper:         1130
bound prop:           78
conflicts:            160
decisions:            627
del clause:           2628
eq adapter:           832
final checks:         132
fixed eqs:            316
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            2707
offset eqs:           62
pivots:               636
propagations:         1073
quant instantiations: 1459
restarts:             11
max. heap size:     4.77733 Mbytes



add rows:             995
added eqs:            1678
arith conflicts:      54
assert diseq:         304
assert lower:         1775
assert upper:         1205
bound prop:           89
conflicts:            167
decisions:            643
del clause:           2802
eq adapter:           882
final checks:         132
fixed eqs:            340
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            2891
offset eqs:           65
pivots:               657
propagations:         1147
quant instantiations: 1523
restarts:             11
max. heap size:     4.77733 Mbytes



add rows:             1026
added eqs:            1703
arith conflicts:      55
assert diseq:         312
assert lower:         1801
assert upper:         1233
bound prop:           95
conflicts:            169
decisions:            646
del clause:           2894
eq adapter:           900
final checks:         132
fixed eqs:            347
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            2952
offset eqs:           68
pivots:               672
propagations:         1164
quant instantiations: 1552
restarts:             11
max. heap size:     4.80906 Mbytes



add rows:             1054
added eqs:            1758
arith conflicts:      57
assert diseq:         321
assert lower:         1839
assert upper:         1258
bound prop:           99
conflicts:            173
decisions:            651
del clause:           2980
eq adapter:           922
final checks:         132
fixed eqs:            359
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3015
offset eqs:           74
pivots:               685
propagations:         1197
quant instantiations: 1582
restarts:             11
max. heap size:     4.80931 Mbytes



add rows:             1090
added eqs:            1810
arith conflicts:      59
assert diseq:         338
assert lower:         1876
assert upper:         1289
bound prop:           103
conflicts:            177
decisions:            656
del clause:           3057
eq adapter:           948
final checks:         132
fixed eqs:            370
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3097
offset eqs:           75
pivots:               704
propagations:         1226
quant instantiations: 1632
restarts:             11
max. heap size:     4.80931 Mbytes



add rows:             1119
added eqs:            1863
arith conflicts:      61
assert diseq:         345
assert lower:         1915
assert upper:         1314
bound prop:           105
conflicts:            181
decisions:            661
del clause:           3123
eq adapter:           970
final checks:         132
fixed eqs:            376
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3154
offset eqs:           76
pivots:               716
propagations:         1253
quant instantiations: 1663
restarts:             11
max. heap size:     4.80931 Mbytes



add rows:             1137
added eqs:            1890
arith conflicts:      62
assert diseq:         351
assert lower:         1943
assert upper:         1340
bound prop:           111
conflicts:            183
decisions:            663
del clause:           3204
eq adapter:           988
final checks:         132
fixed eqs:            383
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3216
offset eqs:           78
pivots:               727
propagations:         1272
quant instantiations: 1694
restarts:             11
max. heap size:     4.80931 Mbytes



add rows:             1157
added eqs:            1924
arith conflicts:      62
assert diseq:         360
assert lower:         1967
assert upper:         1369
bound prop:           120
conflicts:            183
decisions:            674
del clause:           3262
eq adapter:           1006
final checks:         134
fixed eqs:            394
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3341
offset eqs:           78
pivots:               741
propagations:         1307
quant instantiations: 1711
restarts:             12
max. heap size:     4.80931 Mbytes



add rows:             1240
added eqs:            2137
arith conflicts:      64
assert diseq:         380
assert lower:         2080
assert upper:         1426
bound prop:           123
conflicts:            198
decisions:            683
del clause:           4048
eq adapter:           1101
final checks:         142
fixed eqs:            414
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4103
offset eqs:           87
pivots:               790
propagations:         1435
quant instantiations: 2039
restarts:             12
max. heap size:     5.98506 Mbytes



add rows:             1284
added eqs:            2282
arith conflicts:      68
assert diseq:         415
assert lower:         2135
assert upper:         1500
bound prop:           129
conflicts:            205
decisions:            699
del clause:           4172
eq adapter:           1151
final checks:         142
fixed eqs:            438
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4243
offset eqs:           88
pivots:               812
propagations:         1515
quant instantiations: 2110
restarts:             12
max. heap size:     6.03139 Mbytes



add rows:             1312
added eqs:            2306
arith conflicts:      69
assert diseq:         423
assert lower:         2161
assert upper:         1528
bound prop:           135
conflicts:            207
decisions:            702
del clause:           4290
eq adapter:           1169
final checks:         142
fixed eqs:            445
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4304
offset eqs:           91
pivots:               826
propagations:         1534
quant instantiations: 2139
restarts:             12
max. heap size:     6.09957 Mbytes



add rows:             1339
added eqs:            2362
arith conflicts:      71
assert diseq:         432
assert lower:         2199
assert upper:         1553
bound prop:           139
conflicts:            211
decisions:            706
del clause:           4332
eq adapter:           1191
final checks:         142
fixed eqs:            457
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4369
offset eqs:           97
pivots:               839
propagations:         1567
quant instantiations: 2171
restarts:             12
max. heap size:     6.12212 Mbytes



add rows:             1374
added eqs:            2416
arith conflicts:      73
assert diseq:         447
assert lower:         2236
assert upper:         1583
bound prop:           142
conflicts:            215
decisions:            711
del clause:           4407
eq adapter:           1214
final checks:         142
fixed eqs:            468
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4448
offset eqs:           98
pivots:               858
propagations:         1597
quant instantiations: 2225
restarts:             12
max. heap size:     6.12212 Mbytes



add rows:             1406
added eqs:            2469
arith conflicts:      75
assert diseq:         454
assert lower:         2273
assert upper:         1610
bound prop:           143
conflicts:            219
decisions:            715
del clause:           4473
eq adapter:           1236
final checks:         142
fixed eqs:            474
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4506
offset eqs:           99
pivots:               870
propagations:         1624
quant instantiations: 2258
restarts:             12
max. heap size:     6.12212 Mbytes



add rows:             1424
added eqs:            2496
arith conflicts:      76
assert diseq:         462
assert lower:         2301
assert upper:         1636
bound prop:           149
conflicts:            221
decisions:            717
del clause:           4558
eq adapter:           1254
final checks:         142
fixed eqs:            481
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4570
offset eqs:           101
pivots:               882
propagations:         1646
quant instantiations: 2291
restarts:             12
max. heap size:     6.12212 Mbytes



add rows:             1434
added eqs:            2511
arith conflicts:      76
assert diseq:         473
assert lower:         2317
assert upper:         1664
bound prop:           156
conflicts:            221
decisions:            733
del clause:           4619
eq adapter:           1270
final checks:         144
fixed eqs:            487
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            4700
offset eqs:           101
pivots:               892
propagations:         1681
quant instantiations: 2305
restarts:             13
max. heap size:     6.27983 Mbytes




PROVED INVARIANTS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

(forall (i Int)
  (implies (and (>= i 1) (<= i N))
           (implies (= (q i) 2) (<= (last i) (+ now A)))))

Time: 0.3743161


Statistics: 

add rows:             9
added eqs:            26
arith conflicts:      1
assert lower:         57
assert upper:         28
conflicts:            16
decisions:            21
del clause:           24
eq adapter:           13
final checks:         41
fixed eqs:            5
max generation:       2
mk clause:            34
offset eqs:           1
pivots:               34
propagations:         13
quant instantiations: 24
max. heap size:     1.53561 Mbytes



add rows:             20
added eqs:            46
arith conflicts:      2
assert diseq:         1
assert lower:         87
assert upper:         43
conflicts:            19
decisions:            28
del clause:           50
eq adapter:           25
final checks:         44
fixed eqs:            10
max generation:       2
mk clause:            60
offset eqs:           1
pivots:               42
propagations:         20
quant instantiations: 43
max. heap size:     1.69643 Mbytes



add rows:             39
added eqs:            75
arith conflicts:      4
assert diseq:         1
assert lower:         117
assert upper:         61
conflicts:            22
decisions:            35
del clause:           79
eq adapter:           38
final checks:         47
fixed eqs:            17
max generation:       2
mk clause:            90
offset eqs:           4
pivots:               56
propagations:         31
quant instantiations: 61
max. heap size:     1.73534 Mbytes



add rows:             51
added eqs:            95
arith conflicts:      5
assert diseq:         1
assert lower:         147
assert upper:         77
conflicts:            25
decisions:            42
del clause:           107
eq adapter:           49
final checks:         50
fixed eqs:            22
max generation:       2
mk clause:            116
offset eqs:           5
pivots:               69
propagations:         39
quant instantiations: 79
max. heap size:     1.77382 Mbytes



add rows:             65
added eqs:            113
arith conflicts:      6
assert diseq:         2
assert lower:         176
assert upper:         92
conflicts:            28
decisions:            49
del clause:           131
eq adapter:           61
final checks:         53
fixed eqs:            26
max generation:       2
mk clause:            143
offset eqs:           5
pivots:               80
propagations:         45
quant instantiations: 98
max. heap size:     1.84961 Mbytes



add rows:             81
added eqs:            132
arith conflicts:      7
assert diseq:         2
assert lower:         207
assert upper:         107
conflicts:            31
decisions:            56
del clause:           160
eq adapter:           73
final checks:         56
fixed eqs:            27
max generation:       2
mk clause:            170
offset eqs:           5
pivots:               91
propagations:         53
quant instantiations: 117
max. heap size:     1.91758 Mbytes



add rows:             92
added eqs:            152
arith conflicts:      8
assert diseq:         2
assert lower:         234
assert upper:         121
conflicts:            34
decisions:            63
del clause:           180
eq adapter:           84
final checks:         59
fixed eqs:            31
max generation:       2
mk clause:            190
offset eqs:           6
pivots:               101
propagations:         58
quant instantiations: 136
max. heap size:     1.92684 Mbytes



add rows:             102
added eqs:            167
arith conflicts:      9
assert diseq:         11
assert lower:         259
assert upper:         138
conflicts:            38
decisions:            135
del clause:           279
eq adapter:           95
final checks:         69
fixed eqs:            33
max generation:       2
mk clause:            321
offset eqs:           6
pivots:               122
propagations:         140
quant instantiations: 146
restarts:             1
max. heap size:     2.27613 Mbytes



(forall (i Int)
  (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))

Time: 0.2353344


Statistics: 

add rows:             116
added eqs:            192
arith conflicts:      10
assert diseq:         11
assert lower:         297
assert upper:         156
conflicts:            44
decisions:            136
del clause:           342
eq adapter:           108
final checks:         80
fixed eqs:            38
max generation:       2
mk clause:            354
offset eqs:           7
pivots:               140
propagations:         147
quant instantiations: 175
restarts:             1
max. heap size:     2.39859 Mbytes



add rows:             128
added eqs:            212
arith conflicts:      11
assert diseq:         12
assert lower:         327
assert upper:         171
conflicts:            46
decisions:            137
del clause:           369
eq adapter:           120
final checks:         80
fixed eqs:            43
max generation:       2
mk clause:            381
offset eqs:           7
pivots:               147
propagations:         154
quant instantiations: 198
restarts:             1
max. heap size:     2.40022 Mbytes



add rows:             145
added eqs:            242
arith conflicts:      13
assert diseq:         12
assert lower:         358
assert upper:         189
conflicts:            48
decisions:            138
del clause:           399
eq adapter:           133
final checks:         80
fixed eqs:            51
max generation:       2
mk clause:            411
offset eqs:           10
pivots:               157
propagations:         165
quant instantiations: 220
restarts:             1
max. heap size:     2.4228 Mbytes



add rows:             162
added eqs:            266
arith conflicts:      14
assert diseq:         12
assert lower:         389
assert upper:         205
bound prop:           1
conflicts:            50
decisions:            139
del clause:           429
eq adapter:           144
final checks:         80
fixed eqs:            56
max generation:       2
mk clause:            438
offset eqs:           14
pivots:               170
propagations:         173
quant instantiations: 242
restarts:             1
max. heap size:     2.42329 Mbytes



add rows:             177
added eqs:            284
arith conflicts:      15
assert diseq:         13
assert lower:         418
assert upper:         220
bound prop:           1
conflicts:            52
decisions:            140
del clause:           452
eq adapter:           156
final checks:         80
fixed eqs:            60
max generation:       2
mk clause:            466
offset eqs:           14
pivots:               182
propagations:         179
quant instantiations: 265
restarts:             1
max. heap size:     2.42329 Mbytes



add rows:             192
added eqs:            304
arith conflicts:      16
assert diseq:         13
assert lower:         449
assert upper:         235
bound prop:           1
conflicts:            54
decisions:            141
del clause:           482
eq adapter:           168
final checks:         80
fixed eqs:            61
max generation:       2
mk clause:            494
offset eqs:           14
pivots:               192
propagations:         187
quant instantiations: 288
restarts:             1
max. heap size:     2.42329 Mbytes



add rows:             204
added eqs:            323
arith conflicts:      17
assert diseq:         13
assert lower:         476
assert upper:         249
bound prop:           1
conflicts:            56
decisions:            142
del clause:           503
eq adapter:           179
final checks:         80
fixed eqs:            65
max generation:       2
mk clause:            515
offset eqs:           15
pivots:               201
propagations:         192
quant instantiations: 311
restarts:             1
max. heap size:     2.52339 Mbytes



add rows:             213
added eqs:            334
arith conflicts:      18
assert diseq:         13
assert lower:         492
assert upper:         257
bound prop:           1
conflicts:            57
decisions:            142
del clause:           516
eq adapter:           185
final checks:         81
fixed eqs:            67
max generation:       2
mk clause:            558
offset eqs:           15
pivots:               208
propagations:         210
quant instantiations: 323
restarts:             2
max. heap size:     2.64752 Mbytes



(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                    (> (first i) (last j)))))

Time: 0.3590545


Statistics: 

add rows:             377
added eqs:            592
arith conflicts:      27
assert diseq:         38
assert lower:         779
assert upper:         456
bound prop:           10
conflicts:            89
decisions:            197
del clause:           882
eq adapter:           320
final checks:         99
fixed eqs:            125
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            911
offset eqs:           29
pivots:               344
propagations:         354
quant instantiations: 574
restarts:             3
max. heap size:     2.96042 Mbytes



add rows:             406
added eqs:            660
arith conflicts:      29
assert diseq:         50
assert lower:         844
assert upper:         503
bound prop:           10
conflicts:            94
decisions:            213
del clause:           954
eq adapter:           353
final checks:         99
fixed eqs:            139
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            977
offset eqs:           29
pivots:               357
propagations:         391
quant instantiations: 644
restarts:             3
max. heap size:     3.12127 Mbytes



add rows:             408
added eqs:            669
arith conflicts:      30
assert diseq:         50
assert lower:         851
assert upper:         507
bound prop:           10
conflicts:            95
decisions:            213
del clause:           977
eq adapter:           356
final checks:         99
fixed eqs:            140
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            987
offset eqs:           29
pivots:               361
propagations:         396
quant instantiations: 644
restarts:             3
max. heap size:     3.18748 Mbytes



add rows:             417
added eqs:            684
arith conflicts:      31
assert diseq:         50
assert lower:         874
assert upper:         521
bound prop:           10
conflicts:            96
decisions:            213
del clause:           987
eq adapter:           365
final checks:         99
fixed eqs:            144
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1013
offset eqs:           30
pivots:               366
propagations:         400
quant instantiations: 662
restarts:             3
max. heap size:     3.20568 Mbytes



add rows:             442
added eqs:            735
arith conflicts:      33
assert diseq:         61
assert lower:         935
assert upper:         557
bound prop:           10
conflicts:            101
decisions:            232
del clause:           1044
eq adapter:           394
final checks:         99
fixed eqs:            154
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1069
offset eqs:           30
pivots:               377
propagations:         427
quant instantiations: 719
restarts:             3
max. heap size:     3.20568 Mbytes



add rows:             448
added eqs:            745
arith conflicts:      33
assert diseq:         61
assert lower:         935
assert upper:         557
bound prop:           10
conflicts:            102
decisions:            232
del clause:           1069
eq adapter:           396
final checks:         99
fixed eqs:            154
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1077
offset eqs:           30
pivots:               382
propagations:         431
quant instantiations: 719
restarts:             3
max. heap size:     3.21793 Mbytes



add rows:             448
added eqs:            745
arith conflicts:      33
assert diseq:         61
assert lower:         935
assert upper:         557
bound prop:           10
conflicts:            103
decisions:            232
del clause:           1077
eq adapter:           397
final checks:         99
fixed eqs:            154
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1080
offset eqs:           30
pivots:               382
propagations:         432
quant instantiations: 719
restarts:             3
max. heap size:     3.23647 Mbytes



add rows:             483
added eqs:            819
arith conflicts:      35
assert diseq:         121
assert lower:         1032
assert upper:         655
bound prop:           18
conflicts:            108
decisions:            350
del clause:           1258
eq adapter:           450
final checks:         106
fixed eqs:            178
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1433
offset eqs:           30
pivots:               398
propagations:         615
quant instantiations: 779
restarts:             7
max. heap size:     3.61553 Mbytes



(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))

Time: 0.3750952


Statistics: 

add rows:             707
added eqs:            1078
arith conflicts:      42
assert diseq:         151
assert lower:         1319
assert upper:         845
bound prop:           35
conflicts:            131
decisions:            422
del clause:           1814
eq adapter:           586
final checks:         125
fixed eqs:            237
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            1855
offset eqs:           45
pivots:               531
propagations:         745
quant instantiations: 1045
restarts:             8
max. heap size:     4.53029 Mbytes



add rows:             719
added eqs:            1135
arith conflicts:      43
assert diseq:         169
assert lower:         1379
assert upper:         876
bound prop:           38
conflicts:            135
decisions:            444
del clause:           1907
eq adapter:           618
final checks:         125
fixed eqs:            247
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            1946
offset eqs:           45
pivots:               536
propagations:         779
quant instantiations: 1098
restarts:             8
max. heap size:     4.53029 Mbytes



add rows:             725
added eqs:            1162
arith conflicts:      43
assert diseq:         175
assert lower:         1403
assert upper:         895
bound prop:           44
conflicts:            138
decisions:            451
del clause:           1987
eq adapter:           634
final checks:         125
fixed eqs:            250
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            2008
offset eqs:           48
pivots:               539
propagations:         803
quant instantiations: 1134
restarts:             8
max. heap size:     4.53029 Mbytes



add rows:             731
added eqs:            1187
arith conflicts:      43
assert diseq:         176
assert lower:         1425
assert upper:         907
bound prop:           44
conflicts:            140
decisions:            452
del clause:           2034
eq adapter:           647
final checks:         125
fixed eqs:            254
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            2056
offset eqs:           49
pivots:               544
propagations:         812
quant instantiations: 1160
restarts:             8
max. heap size:     4.53029 Mbytes



add rows:             752
added eqs:            1241
arith conflicts:      43
assert diseq:         188
assert lower:         1482
assert upper:         934
bound prop:           50
conflicts:            143
decisions:            464
del clause:           2087
eq adapter:           676
final checks:         125
fixed eqs:            263
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            2132
offset eqs:           49
pivots:               551
propagations:         835
quant instantiations: 1210
restarts:             8
max. heap size:     4.53029 Mbytes



add rows:             795
added eqs:            1293
arith conflicts:      45
assert diseq:         201
assert lower:         1537
assert upper:         955
bound prop:           53
conflicts:            147
decisions:            482
del clause:           2185
eq adapter:           705
final checks:         125
fixed eqs:            267
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            2203
offset eqs:           49
pivots:               563
propagations:         865
quant instantiations: 1253
restarts:             8
max. heap size:     4.53029 Mbytes



add rows:             815
added eqs:            1324
arith conflicts:      45
assert diseq:         207
assert lower:         1561
assert upper:         968
bound prop:           56
conflicts:            149
decisions:            485
del clause:           2238
eq adapter:           720
final checks:         125
fixed eqs:            271
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            2253
offset eqs:           50
pivots:               572
propagations:         882
quant instantiations: 1289
restarts:             8
max. heap size:     4.53029 Mbytes



add rows:             887
added eqs:            1403
arith conflicts:      47
assert diseq:         256
assert lower:         1656
assert upper:         1058
bound prop:           65
conflicts:            153
decisions:            612
del clause:           2421
eq adapter:           784
final checks:         130
fixed eqs:            290
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            2547
offset eqs:           56
pivots:               599
propagations:         1003
quant instantiations: 1391
restarts:             11
max. heap size:     4.77733 Mbytes



(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))

Time: 0.3522823


Statistics: 

add rows:             1178
added eqs:            1950
arith conflicts:      62
assert diseq:         365
assert lower:         1986
assert upper:         1379
bound prop:           120
conflicts:            187
decisions:            678
del clause:           3382
eq adapter:           1020
final checks:         140
fixed eqs:            395
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3470
offset eqs:           79
pivots:               761
propagations:         1331
quant instantiations: 1762
restarts:             12
max. heap size:     5.64447 Mbytes



add rows:             1179
added eqs:            1968
arith conflicts:      62
assert diseq:         367
assert lower:         1994
assert upper:         1380
bound prop:           120
conflicts:            188
decisions:            678
del clause:           3470
eq adapter:           1029
final checks:         140
fixed eqs:            396
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3560
offset eqs:           79
pivots:               762
propagations:         1343
quant instantiations: 1798
restarts:             12
max. heap size:     5.8546 Mbytes



add rows:             1185
added eqs:            1978
arith conflicts:      62
assert diseq:         368
assert lower:         2002
assert upper:         1383
bound prop:           120
conflicts:            189
decisions:            678
del clause:           3560
eq adapter:           1039
final checks:         140
fixed eqs:            397
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3630
offset eqs:           82
pivots:               764
propagations:         1348
quant instantiations: 1825
restarts:             12
max. heap size:     5.93638 Mbytes



add rows:             1190
added eqs:            2000
arith conflicts:      62
assert diseq:         369
assert lower:         2011
assert upper:         1386
bound prop:           120
conflicts:            190
decisions:            678
del clause:           3630
eq adapter:           1047
final checks:         140
fixed eqs:            398
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3698
offset eqs:           83
pivots:               768
propagations:         1362
quant instantiations: 1852
restarts:             12
max. heap size:     5.97613 Mbytes



add rows:             1195
added eqs:            2016
arith conflicts:      62
assert diseq:         371
assert lower:         2019
assert upper:         1387
bound prop:           120
conflicts:            191
decisions:            678
del clause:           3698
eq adapter:           1055
final checks:         140
fixed eqs:            398
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3782
offset eqs:           83
pivots:               771
propagations:         1373
quant instantiations: 1888
restarts:             12
max. heap size:     5.97613 Mbytes



add rows:             1202
added eqs:            2041
arith conflicts:      62
assert diseq:         372
assert lower:         2028
assert upper:         1389
bound prop:           120
conflicts:            192
decisions:            678
del clause:           3782
eq adapter:           1063
final checks:         140
fixed eqs:            399
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3860
offset eqs:           83
pivots:               774
propagations:         1386
quant instantiations: 1924
restarts:             12
max. heap size:     5.97613 Mbytes



add rows:             1204
added eqs:            2061
arith conflicts:      62
assert diseq:         373
assert lower:         2034
assert upper:         1390
bound prop:           120
conflicts:            193
decisions:            678
del clause:           3860
eq adapter:           1071
final checks:         140
fixed eqs:            399
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3942
offset eqs:           84
pivots:               776
propagations:         1400
quant instantiations: 1958
restarts:             12
max. heap size:     5.97613 Mbytes



add rows:             1204
added eqs:            2066
arith conflicts:      62
assert diseq:         374
assert lower:         2039
assert upper:         1390
bound prop:           120
conflicts:            194
decisions:            678
del clause:           3942
eq adapter:           1074
final checks:         140
fixed eqs:            399
interface eqs:        13
max generation:       3
minimized lits:       1
mk clause:            3972
offset eqs:           84
pivots:               776
propagations:         1408
quant instantiations: 1972
restarts:             12
max. heap size:     5.97613 Mbytes




PROVED INDUCTIVE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

DISPROVED INVARIANTS SUMMARY WITH SHORT RUNTIME >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))

Time: 0.3243449



PROVED INVARIANTS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

(forall (i Int)
  (implies (and (>= i 1) (<= i N))
           (implies (= (q i) 2) (<= (last i) (+ now A)))))

Time: 0.3743161


(forall (i Int)
  (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))

Time: 0.2353344


(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                    (> (first i) (last j)))))

Time: 0.3590545


(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))

Time: 0.3750952


(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))

Time: 0.3522823



PROVED INDUCTIVE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

