File: C:\Users\tjohnson\Dropbox\Research\tools\phyea\repos\trunk\input\fischer_umeno_global_clock_buggy.xml

Attempting to prove the following properties as inductive invariants: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

(forall (i Int)
  (implies (and (>= i 1) (<= i N))
           (implies (= (q i) 2) (<= (last i) (+ now A)))))

(forall (i Int)
  (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))

(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))

(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                    (> (first i) (last j)))))

(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))

(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))



ASSUMPTIONS: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0))



Properties proved and used as assumption lemmas: 


Model for basic assumptions: 


A -> 1
N -> 2
g -> 0
B -> 1
g' -> 0
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
Unsat core:

Term:
(implies (and (and (and (forall (i Int)
                          (implies (and (>= i 1) (<= i N))
                                   (and (and (and (= (last i) A)
                                                  (= (first i) 0))
                                             (= g 0))
                                        (= now 0))))
                        (= now 0))
                   (= g 0))
              (forall (i Int) (or (= (q i) 0))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q i) 2) (<= (last i) (+ now A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (= now 0)
     (= g 0)
     (forall (x!36 Int)
       (or (not (>= x!36 1))
           (not (>= (+ N (* -1 x!36)) 0))
           (not (or (not (= (last x!36) A)) (not (= (first x!36) 0)))))
       :pat {(last x!36)}
       :pat {(first x!36)})
     (forall (x!38 Int) (= (q x!38) 0) :pat {(q x!38)})
     (>= x!40!42 1)
     (>= (+ N (* -1 x!40!42)) 0)
     (= (q x!40!42) 2)
     (not (>= (+ A (* -1 (last x!40!42))) 0))
     (<= g 0)
     (= (q x!40!42) 0)
     (>= (q x!40!42) 0)
     (<= (q x!40!42) 4)
     (>= (last x!40!42) 0)
     (<= (+ A (* -1 (last x!40!42))) 0)
     (not (= A (last x!40!42)))
     (not (or (not (= (last x!40!42) A)) (not (= (first x!40!42) 0))))
     (= (last x!40!42) A)
     (= (first x!40!42) 0))


unsat: proved claim
added eqs:            5
assert lower:         24
assert upper:         10
conflicts:            10
decisions:            8
del clause:           5
eq adapter:           2
final checks:         29
max generation:       1
mk clause:            10
offset eqs:           1
pivots:               15
propagations:         7
quant instantiations: 5
max. heap size:     1.41539 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N))
                (implies (= (q i) 2) (<= (last i) (+ now A)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 0) (= (q' h) 1))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!48!53 1)
     (>= (+ N (* -1 x!48!53)) 0)
     (= (q x!48!53) 0)
     (= (q' x!48!53) 1)
     (= (last x!48!53) (last' x!48!53))
     (= (first x!48!53) (first' x!48!53))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!48!53)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!51!54 1)
     (>= (+ N (* -1 x!51!54)) 0)
     (= (q' x!51!54) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!54)))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!48!53) 0)
     (<= (q x!48!53) 4)
     (>= (q' x!48!53) 0)
     (<= (q' x!48!53) 4)
     (>= (q' x!51!54) 0)
     (<= (q' x!51!54) 4)
     (>= (last' x!48!53) 0)
     (>= (last' x!51!54) 0)
     (>= (last x!48!53) 0)
     (>= (first' x!48!53) 0)
     (>= (first x!48!53) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!48!53) 0)
     (<= (q' x!48!53) 1)
     (>= (q' x!48!53) 1)
     (<= (q' x!51!54) 2)
     (>= (q' x!51!54) 2)
     (<= (+ (last x!48!53) (* -1 (last' x!48!53))) 0)
     (>= (+ (last x!48!53) (* -1 (last' x!48!53))) 0)
     (<= (+ (first x!48!53) (* -1 (first' x!48!53))) 0)
     (>= (+ (first x!48!53) (* -1 (first' x!48!53))) 0))


unsat: proved claim
add rows:             9
added eqs:            26
arith conflicts:      1
assert lower:         58
assert upper:         27
conflicts:            16
decisions:            21
del clause:           24
eq adapter:           13
final checks:         41
fixed eqs:            5
max generation:       2
mk clause:            34
offset eqs:           1
pivots:               33
propagations:         13
quant instantiations: 24
max. heap size:     1.53561 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N))
                (implies (= (q i) 2) (<= (last i) (+ now A)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!55!58 1)
     (>= (+ N (* -1 x!55!58)) 0)
     (= (q x!55!58) 1)
     (= (q' x!55!58) 1)
     (not (= g 0))
     (= (last x!55!58) (last' x!55!58))
     (= (first x!55!58) (first' x!55!58))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!55!58)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!51!59 1)
     (>= (+ N (* -1 x!51!59)) 0)
     (= (q' x!51!59) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!59)))) 0))
     (not (<= g 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!55!58) 0)
     (<= (q x!55!58) 4)
     (>= (q' x!55!58) 0)
     (<= (q' x!55!58) 4)
     (>= (q' x!51!59) 0)
     (<= (q' x!51!59) 4)
     (>= (last' x!55!58) 0)
     (>= (last' x!51!59) 0)
     (>= (last x!55!58) 0)
     (>= (first' x!55!58) 0)
     (>= (first x!55!58) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!55!58) 1)
     (>= (q x!55!58) 1)
     (<= (q' x!55!58) 1)
     (>= (q' x!55!58) 1)
     (<= (q' x!51!59) 2)
     (>= (q' x!51!59) 2)
     (= (last' x!55!58) (last x!55!58))
     (<= (+ (last' x!55!58) (* -1 (last x!55!58))) 0)
     (>= (+ (last' x!55!58) (* -1 (last x!55!58))) 0)
     (<= (+ (first x!55!58) (* -1 (first' x!55!58))) 0)
     (>= (+ (first x!55!58) (* -1 (first' x!55!58))) 0))


unsat: proved claim
add rows:             20
added eqs:            46
arith conflicts:      2
assert diseq:         1
assert lower:         88
assert upper:         42
conflicts:            19
decisions:            28
del clause:           50
eq adapter:           25
final checks:         44
fixed eqs:            10
max generation:       2
mk clause:            60
offset eqs:           1
pivots:               41
propagations:         20
quant instantiations: 43
max. heap size:     1.69643 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N))
                (implies (= (q i) 2) (<= (last i) (+ now A)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 2) (= g 0) (= (last' h) (+ now A)))
                 (and (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!60!63 1)
     (>= (+ N (* -1 x!60!63)) 0)
     (= (q x!60!63) 1)
     (= (q' x!60!63) 2)
     (= g 0)
     (= (+ A (+ now (* -1 (last' x!60!63)))) 0)
     (= (first x!60!63) (first' x!60!63))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!60!63)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!51!64 1)
     (>= (+ N (* -1 x!51!64)) 0)
     (= (q' x!51!64) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!64)))) 0))
     (<= g 0)
     (<= (+ A (+ now (* -1 (last' x!60!63)))) 0)
     (>= (+ A (+ now (* -1 (last' x!60!63)))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!60!63) 0)
     (<= (q x!60!63) 4)
     (>= (q' x!60!63) 0)
     (<= (q' x!60!63) 4)
     (>= (q' x!51!64) 0)
     (<= (q' x!51!64) 4)
     (>= (last' x!60!63) 0)
     (>= (last' x!51!64) 0)
     (>= (first' x!60!63) 0)
     (>= (first x!60!63) 0)
     (<= (q x!60!63) 1)
     (>= (q x!60!63) 1)
     (<= (q' x!60!63) 2)
     (>= (q' x!60!63) 2)
     (<= (q' x!51!64) 2)
     (>= (q' x!51!64) 2)
     (<= (+ (first x!60!63) (* -1 (first' x!60!63))) 0)
     (>= (+ (first x!60!63) (* -1 (first' x!60!63))) 0))


unsat: proved claim
add rows:             39
added eqs:            75
arith conflicts:      4
assert diseq:         1
assert lower:         118
assert upper:         60
conflicts:            22
decisions:            35
del clause:           79
eq adapter:           38
final checks:         47
fixed eqs:            17
max generation:       2
mk clause:            90
offset eqs:           4
pivots:               55
propagations:         31
quant instantiations: 61
max. heap size:     1.73557 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N))
                (implies (= (q i) 2) (<= (last i) (+ now A)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 2)
                      (= (q' h) 3)
                      (<= now (last h))
                      (>= now (last h))
                      (and (= g' h) (= (first' h) (+ now B))))
                 (and (= (last h) (last' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!65!68 1)
     (>= (+ N (* -1 x!65!68)) 0)
     (= (q x!65!68) 2)
     (= (q' x!65!68) 3)
     (<= (+ now (* -1 (last x!65!68))) 0)
     (>= (+ now (* -1 (last x!65!68))) 0)
     (= g' x!65!68)
     (= (+ B (+ now (* -1 (first' x!65!68)))) 0)
     (= (last x!65!68) (last' x!65!68))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!65!68)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!51!69 1)
     (>= (+ N (* -1 x!51!69)) 0)
     (= (q' x!51!69) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!69)))) 0))
     (<= (+ g' (* -1 x!65!68)) 0)
     (>= (+ g' (* -1 x!65!68)) 0)
     (<= (+ B (+ now (* -1 (first' x!65!68)))) 0)
     (>= (+ B (+ now (* -1 (first' x!65!68)))) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (+ A (+ now (* -1 (last x!65!68)))) 0)
     (>= (q x!65!68) 0)
     (<= (q x!65!68) 4)
     (>= (q' x!65!68) 0)
     (<= (q' x!65!68) 4)
     (>= (q' x!51!69) 0)
     (<= (q' x!51!69) 4)
     (>= (last x!65!68) 0)
     (>= (first' x!65!68) 0)
     (>= (last' x!65!68) 0)
     (>= (last' x!51!69) 0)
     (<= (q x!65!68) 2)
     (>= (q x!65!68) 2)
     (<= (q' x!65!68) 3)
     (>= (q' x!65!68) 3)
     (<= (q' x!51!69) 2)
     (>= (q' x!51!69) 2)
     (<= (+ (last x!65!68) (* -1 (last' x!65!68))) 0)
     (>= (+ (last x!65!68) (* -1 (last' x!65!68))) 0))


unsat: proved claim
add rows:             50
added eqs:            95
arith conflicts:      5
assert diseq:         1
assert lower:         148
assert upper:         76
conflicts:            25
decisions:            42
del clause:           107
eq adapter:           49
final checks:         50
fixed eqs:            22
max generation:       2
mk clause:            116
offset eqs:           5
pivots:               68
propagations:         39
quant instantiations: 79
max. heap size:     1.77381 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N))
                (implies (= (q i) 2) (<= (last i) (+ now A)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3)
                      (= (q' h) 1)
                      (and (not (= g h)) (>= now (first h)))
                      (= (first' h) 0))
                 (and (= (last h) (last' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!70!73 1)
     (>= (+ N (* -1 x!70!73)) 0)
     (= (q x!70!73) 3)
     (= (q' x!70!73) 1)
     (not (= g x!70!73))
     (>= (+ now (* -1 (first x!70!73))) 0)
     (= (first' x!70!73) 0)
     (= (last x!70!73) (last' x!70!73))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!70!73)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!51!74 1)
     (>= (+ N (* -1 x!51!74)) 0)
     (= (q' x!51!74) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!74)))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!70!73) 0)
     (<= (q x!70!73) 4)
     (>= (q' x!70!73) 0)
     (<= (q' x!70!73) 4)
     (>= (q' x!51!74) 0)
     (<= (q' x!51!74) 4)
     (>= (first x!70!73) 0)
     (>= (first' x!70!73) 0)
     (>= (last' x!70!73) 0)
     (>= (last' x!51!74) 0)
     (>= (last x!70!73) 0)
     (<= (q x!70!73) 3)
     (>= (q x!70!73) 3)
     (<= (q' x!70!73) 1)
     (>= (q' x!70!73) 1)
     (<= (q' x!51!74) 2)
     (>= (q' x!51!74) 2)
     (<= (first' x!70!73) 0)
     (<= (+ (last x!70!73) (* -1 (last' x!70!73))) 0)
     (>= (+ (last x!70!73) (* -1 (last' x!70!73))) 0))


unsat: proved claim
add rows:             64
added eqs:            113
arith conflicts:      6
assert diseq:         2
assert lower:         177
assert upper:         91
conflicts:            28
decisions:            49
del clause:           131
eq adapter:           61
final checks:         53
fixed eqs:            26
max generation:       2
mk clause:            143
offset eqs:           5
pivots:               79
propagations:         45
quant instantiations: 98
max. heap size:     1.84961 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N))
                (implies (= (q i) 2) (<= (last i) (+ now A)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3) (= (q' h) 4) (and (= g h) (>= now (first h))))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!75!78 1)
     (>= (+ N (* -1 x!75!78)) 0)
     (= (q x!75!78) 3)
     (= (q' x!75!78) 4)
     (= g x!75!78)
     (>= (+ now (* -1 (first x!75!78))) 0)
     (= (last x!75!78) (last' x!75!78))
     (= (first x!75!78) (first' x!75!78))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!75!78)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!51!79 1)
     (>= (+ N (* -1 x!51!79)) 0)
     (= (q' x!51!79) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!79)))) 0))
     (<= (+ g (* -1 x!75!78)) 0)
     (>= (+ g (* -1 x!75!78)) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!75!78) 0)
     (<= (q x!75!78) 4)
     (>= (q' x!75!78) 0)
     (<= (q' x!75!78) 4)
     (>= (q' x!51!79) 0)
     (<= (q' x!51!79) 4)
     (>= (first x!75!78) 0)
     (>= (last' x!75!78) 0)
     (>= (last' x!51!79) 0)
     (>= (last x!75!78) 0)
     (>= (first' x!75!78) 0)
     (<= (q x!75!78) 3)
     (>= (q x!75!78) 3)
     (>= (q' x!75!78) 4)
     (<= (q' x!51!79) 2)
     (>= (q' x!51!79) 2)
     (<= (+ (last x!75!78) (* -1 (last' x!75!78))) 0)
     (>= (+ (last x!75!78) (* -1 (last' x!75!78))) 0)
     (= (first' x!75!78) (first x!75!78))
     (<= (+ (first' x!75!78) (* -1 (first x!75!78))) 0)
     (>= (+ (first' x!75!78) (* -1 (first x!75!78))) 0))


unsat: proved claim
add rows:             80
added eqs:            132
arith conflicts:      7
assert diseq:         2
assert lower:         208
assert upper:         106
conflicts:            31
decisions:            56
del clause:           160
eq adapter:           73
final checks:         56
fixed eqs:            27
max generation:       2
mk clause:            170
offset eqs:           5
pivots:               90
propagations:         53
quant instantiations: 117
max. heap size:     1.91758 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N))
                (implies (= (q i) 2) (<= (last i) (+ now A)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!80!83 1)
     (>= (+ N (* -1 x!80!83)) 0)
     (= (q x!80!83) 4)
     (= (q' x!80!83) 0)
     (= g' 0)
     (= (last x!80!83) (last' x!80!83))
     (= (first x!80!83) (first' x!80!83))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!80!83)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!51!84 1)
     (>= (+ N (* -1 x!51!84)) 0)
     (= (q' x!51!84) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!84)))) 0))
     (<= g' 0)
     (>= (q x!80!83) 0)
     (<= (q x!80!83) 4)
     (>= (q' x!80!83) 0)
     (<= (q' x!80!83) 4)
     (>= (q' x!51!84) 0)
     (<= (q' x!51!84) 4)
     (>= (last' x!80!83) 0)
     (>= (last' x!51!84) 0)
     (>= (last x!80!83) 0)
     (>= (first' x!80!83) 0)
     (>= (first x!80!83) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!80!83) 4)
     (<= (q' x!80!83) 0)
     (<= (q' x!51!84) 2)
     (>= (q' x!51!84) 2)
     (= (last' x!80!83) (last x!80!83))
     (<= (+ (last' x!80!83) (* -1 (last x!80!83))) 0)
     (>= (+ (last' x!80!83) (* -1 (last x!80!83))) 0)
     (<= (+ (first x!80!83) (* -1 (first' x!80!83))) 0)
     (>= (+ (first x!80!83) (* -1 (first' x!80!83))) 0))


unsat: proved claim
add rows:             91
added eqs:            152
arith conflicts:      8
assert diseq:         2
assert lower:         235
assert upper:         120
conflicts:            34
decisions:            63
del clause:           180
eq adapter:           84
final checks:         59
fixed eqs:            31
max generation:       2
mk clause:            190
offset eqs:           6
pivots:               100
propagations:         58
quant instantiations: 136
max. heap size:     1.92684 Mbytes
Unsat core:

Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= (last i) (+ now A)))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= (last' i) (+ now' A))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (>= x!94!99 0)
     (forall (x!96 Real) (x!95 Int)
       (or (not (>= x!96 0))
           (not (<= (+ x!96 (* -1 x!94!99)) 0))
           (not (>= x!95 1))
           (not (>= (+ N (* -1 x!95)) 0))
           (not (or (not (or (not (= (q x!95) 0))
                             (= (+ now (+ (* -1 now') x!94!99)) 0)))
                    (not (or (not (= (q x!95) 1))
                             (= (+ now (+ (* -1 now') x!94!99)) 0)))
                    (not (or (not (= (q x!95) 2))
                             (not (or (not (<= (+ now
                                                  (+ x!96 (* -1 (last x!95))))
                                               0))
                                      (not (or (not (>= (+ now
                                                           (+ x!96
                                                              (* -1 (last x!95))))
                                                        0))
                                               (= x!94!99 x!96)))
                                      (not (= (+ now (+ (* -1 now') x!94!99)) 0))))))
                    (not (or (not (= (q x!95) 3))
                             (= (+ now (+ (* -1 now') x!94!99)) 0)))
                    (not (or (not (= (q x!95) 4))
                             (= (+ now (+ (* -1 now') x!94!99)) 0)))
                    (not (= (q x!95) (q' x!95)))
                    (not (= (last x!95) (last' x!95)))
                    (not (= (first x!95) (first' x!95)))
                    (not (= g g'))))))
     (>= x!51!100 1)
     (>= (+ N (* -1 x!51!100)) 0)
     (= (q' x!51!100) 2)
     (not (>= (+ A (+ now' (* -1 (last' x!51!100)))) 0))
     (>= (q' x!51!100) 0)
     (<= (q' x!51!100) 4)
     (>= (last' x!51!100) 0)
     (<= (q' x!51!100) 2)
     (>= (q' x!51!100) 2))


unsat: proved claim
add rows:             101
added eqs:            167
arith conflicts:      9
assert diseq:         11
assert lower:         260
assert upper:         137
conflicts:            38
decisions:            135
del clause:           279
eq adapter:           95
final checks:         69
fixed eqs:            33
max generation:       2
mk clause:            321
offset eqs:           6
pivots:               121
propagations:         140
quant instantiations: 146
restarts:             1
max. heap size:     2.27609 Mbytes
Unsat core:



Property was an inductive invariant! Property checked was: 
(forall (i Int)
  (implies (and (>= i 1) (<= i N))
           (implies (= (q i) 2) (<= (last i) (+ now A)))))


ASSUMPTIONS: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)}))



Properties proved and used as assumption lemmas: 


(forall (i Int)
  (implies (and (>= i 1) (<= i N))
           (implies (= (q i) 2) (<= (last i) (+ now A)))))


Model for basic assumptions: 


A -> 1
N -> 2
g -> 0
B -> 1
now -> 1
g' -> 0
now' -> 1
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
Unsat core:

Term:
(implies (and (and (and (forall (i Int)
                          (implies (and (>= i 1) (<= i N))
                                   (and (and (and (= (last i) A)
                                                  (= (first i) 0))
                                             (= g 0))
                                        (= now 0))))
                        (= now 0))
                   (= g 0))
              (forall (i Int) (or (= (q i) 0))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q i) 2) (<= now (last i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (= now 0)
     (= g 0)
     (forall (x!36 Int)
       (or (not (>= x!36 1))
           (not (>= (+ N (* -1 x!36)) 0))
           (not (or (not (= (last x!36) A)) (not (= (first x!36) 0)))))
       :pat {(last x!36)}
       :pat {(first x!36)})
     (forall (x!38 Int) (= (q x!38) 0) :pat {(q x!38)})
     (>= x!144!146 1)
     (>= (+ N (* -1 x!144!146)) 0)
     (= (q x!144!146) 2)
     (not (>= (last x!144!146) 0))
     (<= g 0)
     (= (q x!144!146) 0)
     (>= (+ A (+ now (* -1 (last x!144!146)))) 0)
     (>= (q x!144!146) 0)
     (<= (q x!144!146) 4)
     (not (or (not (= (last x!144!146) A)) (not (= (first x!144!146) 0)))))


unsat: proved claim
add rows:             106
added eqs:            171
arith conflicts:      9
assert diseq:         11
assert lower:         264
assert upper:         140
conflicts:            40
decisions:            135
del clause:           321
eq adapter:           97
final checks:         74
fixed eqs:            33
max generation:       2
mk clause:            330
offset eqs:           7
pivots:               127
propagations:         141
quant instantiations: 152
restarts:             1
max. heap size:     2.38205 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 0) (= (q' h) 1))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!48!151 1)
     (>= (+ N (* -1 x!48!151)) 0)
     (= (q x!48!151) 0)
     (= (q' x!48!151) 1)
     (= (last x!48!151) (last' x!48!151))
     (= (first x!48!151) (first' x!48!151))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!48!151)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!149!152 1)
     (>= (+ N (* -1 x!149!152)) 0)
     (= (q' x!149!152) 2)
     (not (<= (+ now' (* -1 (last' x!149!152))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!48!151) 0)
     (<= (q x!48!151) 4)
     (>= (q' x!48!151) 0)
     (<= (q' x!48!151) 4)
     (>= (+ A (+ now' (* -1 (last' x!149!152)))) 0)
     (>= (q' x!149!152) 0)
     (<= (q' x!149!152) 4)
     (>= (last' x!48!151) 0)
     (>= (last' x!149!152) 0)
     (>= (last x!48!151) 0)
     (>= (first' x!48!151) 0)
     (>= (first x!48!151) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!48!151) 0)
     (<= (+ (last x!48!151) (* -1 (last' x!48!151))) 0)
     (>= (+ (last x!48!151) (* -1 (last' x!48!151))) 0)
     (<= (q' x!48!151) 1)
     (>= (q' x!48!151) 1)
     (<= (q' x!149!152) 2)
     (>= (q' x!149!152) 2)
     (<= (+ (first x!48!151) (* -1 (first' x!48!151))) 0)
     (>= (+ (first x!48!151) (* -1 (first' x!48!151))) 0))


unsat: proved claim
add rows:             115
added eqs:            192
arith conflicts:      10
assert diseq:         11
assert lower:         298
assert upper:         155
conflicts:            44
decisions:            136
del clause:           342
eq adapter:           108
final checks:         80
fixed eqs:            38
max generation:       2
mk clause:            354
offset eqs:           7
pivots:               139
propagations:         147
quant instantiations: 175
restarts:             1
max. heap size:     2.39858 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!55!153 1)
     (>= (+ N (* -1 x!55!153)) 0)
     (= (q x!55!153) 1)
     (= (q' x!55!153) 1)
     (not (= g 0))
     (= (last x!55!153) (last' x!55!153))
     (= (first x!55!153) (first' x!55!153))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!55!153)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!149!154 1)
     (>= (+ N (* -1 x!149!154)) 0)
     (= (q' x!149!154) 2)
     (not (<= (+ now' (* -1 (last' x!149!154))) 0))
     (not (<= g 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!55!153) 0)
     (<= (q x!55!153) 4)
     (>= (q' x!55!153) 0)
     (<= (q' x!55!153) 4)
     (>= (+ A (+ now' (* -1 (last' x!149!154)))) 0)
     (>= (q' x!149!154) 0)
     (<= (q' x!149!154) 4)
     (>= (last' x!55!153) 0)
     (>= (last' x!149!154) 0)
     (>= (last x!55!153) 0)
     (>= (first' x!55!153) 0)
     (>= (first x!55!153) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!55!153) 1)
     (>= (q x!55!153) 1)
     (<= (+ (last x!55!153) (* -1 (last' x!55!153))) 0)
     (>= (+ (last x!55!153) (* -1 (last' x!55!153))) 0)
     (<= (q' x!55!153) 1)
     (>= (q' x!55!153) 1)
     (<= (q' x!149!154) 2)
     (>= (q' x!149!154) 2)
     (<= (+ (first x!55!153) (* -1 (first' x!55!153))) 0)
     (>= (+ (first x!55!153) (* -1 (first' x!55!153))) 0))


unsat: proved claim
add rows:             127
added eqs:            212
arith conflicts:      11
assert diseq:         12
assert lower:         328
assert upper:         170
conflicts:            46
decisions:            137
del clause:           369
eq adapter:           120
final checks:         80
fixed eqs:            43
max generation:       2
mk clause:            381
offset eqs:           7
pivots:               146
propagations:         154
quant instantiations: 198
restarts:             1
max. heap size:     2.40022 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 2) (= g 0) (= (last' h) (+ now A)))
                 (and (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!60!155 1)
     (>= (+ N (* -1 x!60!155)) 0)
     (= (q x!60!155) 1)
     (= (q' x!60!155) 2)
     (= g 0)
     (= (+ A (+ now (* -1 (last' x!60!155)))) 0)
     (= (first x!60!155) (first' x!60!155))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!60!155)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!149!156 1)
     (>= (+ N (* -1 x!149!156)) 0)
     (= (q' x!149!156) 2)
     (not (<= (+ now' (* -1 (last' x!149!156))) 0))
     (<= g 0)
     (<= (+ A (+ now (* -1 (last' x!60!155)))) 0)
     (>= (+ A (+ now (* -1 (last' x!60!155)))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!60!155) 0)
     (<= (q x!60!155) 4)
     (>= (+ A (+ now' (* -1 (last' x!60!155)))) 0)
     (>= (q' x!60!155) 0)
     (<= (q' x!60!155) 4)
     (>= (+ A (+ now' (* -1 (last' x!149!156)))) 0)
     (>= (q' x!149!156) 0)
     (<= (q' x!149!156) 4)
     (>= (last' x!60!155) 0)
     (>= (last' x!149!156) 0)
     (>= (first' x!60!155) 0)
     (>= (first x!60!155) 0)
     (<= (q x!60!155) 1)
     (>= (q x!60!155) 1)
     (<= (q' x!60!155) 2)
     (>= (q' x!60!155) 2)
     (<= (q' x!149!156) 2)
     (>= (q' x!149!156) 2)
     (<= (+ (first x!60!155) (* -1 (first' x!60!155))) 0)
     (>= (+ (first x!60!155) (* -1 (first' x!60!155))) 0))


unsat: proved claim
add rows:             144
added eqs:            242
arith conflicts:      13
assert diseq:         12
assert lower:         359
assert upper:         188
conflicts:            48
decisions:            138
del clause:           399
eq adapter:           133
final checks:         80
fixed eqs:            51
max generation:       2
mk clause:            411
offset eqs:           10
pivots:               156
propagations:         165
quant instantiations: 220
restarts:             1
max. heap size:     2.4228 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 2)
                      (= (q' h) 3)
                      (<= now (last h))
                      (>= now (last h))
                      (and (= g' h) (= (first' h) (+ now B))))
                 (and (= (last h) (last' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!65!157 1)
     (>= (+ N (* -1 x!65!157)) 0)
     (= (q x!65!157) 2)
     (= (q' x!65!157) 3)
     (<= (+ now (* -1 (last x!65!157))) 0)
     (>= (+ now (* -1 (last x!65!157))) 0)
     (= g' x!65!157)
     (= (+ B (+ now (* -1 (first' x!65!157)))) 0)
     (= (last x!65!157) (last' x!65!157))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!65!157)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!149!158 1)
     (>= (+ N (* -1 x!149!158)) 0)
     (= (q' x!149!158) 2)
     (not (<= (+ now' (* -1 (last' x!149!158))) 0))
     (<= (+ g' (* -1 x!65!157)) 0)
     (>= (+ g' (* -1 x!65!157)) 0)
     (<= (+ B (+ now (* -1 (first' x!65!157)))) 0)
     (>= (+ B (+ now (* -1 (first' x!65!157)))) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (+ A (+ now (* -1 (last x!65!157)))) 0)
     (>= (q x!65!157) 0)
     (<= (q x!65!157) 4)
     (>= (q' x!65!157) 0)
     (<= (q' x!65!157) 4)
     (>= (+ A (+ now' (* -1 (last' x!149!158)))) 0)
     (>= (q' x!149!158) 0)
     (<= (q' x!149!158) 4)
     (>= (last x!65!157) 0)
     (>= (first' x!65!157) 0)
     (>= (last' x!65!157) 0)
     (>= (last' x!149!158) 0)
     (<= (q x!65!157) 2)
     (>= (q x!65!157) 2)
     (= (last' x!65!157) (last x!65!157))
     (<= (+ (last' x!65!157) (* -1 (last x!65!157))) 0)
     (>= (+ (last' x!65!157) (* -1 (last x!65!157))) 0)
     (<= (q' x!65!157) 3)
     (>= (q' x!65!157) 3)
     (<= (q' x!149!158) 2)
     (>= (q' x!149!158) 2)
     (>= (+ A (+ now' (* -1 (last' x!65!157)))) 0))


unsat: proved claim
add rows:             160
added eqs:            266
arith conflicts:      14
assert diseq:         12
assert lower:         390
assert upper:         204
bound prop:           1
conflicts:            50
decisions:            139
del clause:           429
eq adapter:           144
final checks:         80
fixed eqs:            56
max generation:       2
mk clause:            438
offset eqs:           14
pivots:               169
propagations:         173
quant instantiations: 242
restarts:             1
max. heap size:     2.42329 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3)
                      (= (q' h) 1)
                      (and (not (= g h)) (>= now (first h)))
                      (= (first' h) 0))
                 (and (= (last h) (last' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!70!159 1)
     (>= (+ N (* -1 x!70!159)) 0)
     (= (q x!70!159) 3)
     (= (q' x!70!159) 1)
     (not (= g x!70!159))
     (>= (+ now (* -1 (first x!70!159))) 0)
     (= (first' x!70!159) 0)
     (= (last x!70!159) (last' x!70!159))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!70!159)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!149!160 1)
     (>= (+ N (* -1 x!149!160)) 0)
     (= (q' x!149!160) 2)
     (not (<= (+ now' (* -1 (last' x!149!160))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!70!159) 0)
     (<= (q x!70!159) 4)
     (>= (q' x!70!159) 0)
     (<= (q' x!70!159) 4)
     (>= (+ A (+ now' (* -1 (last' x!149!160)))) 0)
     (>= (q' x!149!160) 0)
     (<= (q' x!149!160) 4)
     (>= (first x!70!159) 0)
     (>= (first' x!70!159) 0)
     (>= (last' x!70!159) 0)
     (>= (last' x!149!160) 0)
     (>= (last x!70!159) 0)
     (<= (q x!70!159) 3)
     (>= (q x!70!159) 3)
     (<= (+ (last x!70!159) (* -1 (last' x!70!159))) 0)
     (>= (+ (last x!70!159) (* -1 (last' x!70!159))) 0)
     (<= (q' x!70!159) 1)
     (>= (q' x!70!159) 1)
     (<= (q' x!149!160) 2)
     (>= (q' x!149!160) 2)
     (<= (first' x!70!159) 0))


unsat: proved claim
add rows:             175
added eqs:            284
arith conflicts:      15
assert diseq:         13
assert lower:         419
assert upper:         219
bound prop:           1
conflicts:            52
decisions:            140
del clause:           452
eq adapter:           156
final checks:         80
fixed eqs:            60
max generation:       2
mk clause:            466
offset eqs:           14
pivots:               181
propagations:         179
quant instantiations: 265
restarts:             1
max. heap size:     2.42329 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3) (= (q' h) 4) (and (= g h) (>= now (first h))))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!75!161 1)
     (>= (+ N (* -1 x!75!161)) 0)
     (= (q x!75!161) 3)
     (= (q' x!75!161) 4)
     (= g x!75!161)
     (>= (+ now (* -1 (first x!75!161))) 0)
     (= (last x!75!161) (last' x!75!161))
     (= (first x!75!161) (first' x!75!161))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!75!161)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!149!162 1)
     (>= (+ N (* -1 x!149!162)) 0)
     (= (q' x!149!162) 2)
     (not (<= (+ now' (* -1 (last' x!149!162))) 0))
     (<= (+ g (* -1 x!75!161)) 0)
     (>= (+ g (* -1 x!75!161)) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!75!161) 0)
     (<= (q x!75!161) 4)
     (>= (q' x!75!161) 0)
     (<= (q' x!75!161) 4)
     (>= (+ A (+ now' (* -1 (last' x!149!162)))) 0)
     (>= (q' x!149!162) 0)
     (<= (q' x!149!162) 4)
     (>= (first x!75!161) 0)
     (>= (last' x!75!161) 0)
     (>= (last' x!149!162) 0)
     (>= (last x!75!161) 0)
     (>= (first' x!75!161) 0)
     (<= (q x!75!161) 3)
     (>= (q x!75!161) 3)
     (= (last' x!75!161) (last x!75!161))
     (<= (+ (last' x!75!161) (* -1 (last x!75!161))) 0)
     (>= (+ (last' x!75!161) (* -1 (last x!75!161))) 0)
     (>= (q' x!75!161) 4)
     (<= (q' x!149!162) 2)
     (>= (q' x!149!162) 2)
     (= (first' x!75!161) (first x!75!161))
     (<= (+ (first' x!75!161) (* -1 (first x!75!161))) 0)
     (>= (+ (first' x!75!161) (* -1 (first x!75!161))) 0))


unsat: proved claim
add rows:             190
added eqs:            304
arith conflicts:      16
assert diseq:         13
assert lower:         450
assert upper:         234
bound prop:           1
conflicts:            54
decisions:            141
del clause:           482
eq adapter:           168
final checks:         80
fixed eqs:            61
max generation:       2
mk clause:            494
offset eqs:           14
pivots:               191
propagations:         187
quant instantiations: 288
restarts:             1
max. heap size:     2.42329 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int)
       (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!80!163 1)
     (>= (+ N (* -1 x!80!163)) 0)
     (= (q x!80!163) 4)
     (= (q' x!80!163) 0)
     (= g' 0)
     (= (last x!80!163) (last' x!80!163))
     (= (first x!80!163) (first' x!80!163))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!80!163)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!149!164 1)
     (>= (+ N (* -1 x!149!164)) 0)
     (= (q' x!149!164) 2)
     (not (<= (+ now' (* -1 (last' x!149!164))) 0))
     (<= g' 0)
     (>= (q x!80!163) 0)
     (<= (q x!80!163) 4)
     (>= (q' x!80!163) 0)
     (<= (q' x!80!163) 4)
     (>= (+ A (+ now' (* -1 (last' x!149!164)))) 0)
     (>= (q' x!149!164) 0)
     (<= (q' x!149!164) 4)
     (>= (last' x!80!163) 0)
     (>= (last' x!149!164) 0)
     (>= (last x!80!163) 0)
     (>= (first' x!80!163) 0)
     (>= (first x!80!163) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!80!163) 4)
     (<= (+ (last x!80!163) (* -1 (last' x!80!163))) 0)
     (>= (+ (last x!80!163) (* -1 (last' x!80!163))) 0)
     (<= (q' x!80!163) 0)
     (<= (q' x!149!164) 2)
     (>= (q' x!149!164) 2)
     (<= (+ (first x!80!163) (* -1 (first' x!80!163))) 0)
     (>= (+ (first x!80!163) (* -1 (first' x!80!163))) 0))


unsat: proved claim
add rows:             202
added eqs:            323
arith conflicts:      17
assert diseq:         13
assert lower:         477
assert upper:         248
bound prop:           1
conflicts:            56
decisions:            142
del clause:           503
eq adapter:           179
final checks:         80
fixed eqs:            65
max generation:       2
mk clause:            515
offset eqs:           15
pivots:               200
propagations:         192
quant instantiations: 311
restarts:             1
max. heap size:     2.52388 Mbytes
Unsat core:

Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N))
                         (implies (= (q i) 2) (<= now (last i)))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int)
           (implies (and (>= i 1) (<= i N))
                    (implies (= (q' i) 2) (<= now' (last' i))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (>= x!94!165 0)
     (forall (x!96 Real) (x!95 Int)
       (or (not (>= x!96 0))
           (not (<= (+ x!96 (* -1 x!94!165)) 0))
           (not (>= x!95 1))
           (not (>= (+ N (* -1 x!95)) 0))
           (not (or (not (or (not (= (q x!95) 0))
                             (= (+ now (+ (* -1 now') x!94!165)) 0)))
                    (not (or (not (= (q x!95) 1))
                             (= (+ now (+ (* -1 now') x!94!165)) 0)))
                    (not (or (not (= (q x!95) 2))
                             (not (or (not (<= (+ now
                                                  (+ x!96 (* -1 (last x!95))))
                                               0))
                                      (not (or (not (>= (+ now
                                                           (+ x!96
                                                              (* -1 (last x!95))))
                                                        0))
                                               (= x!94!165 x!96)))
                                      (not (= (+ now (+ (* -1 now') x!94!165))
                                              0))))))
                    (not (or (not (= (q x!95) 3))
                             (= (+ now (+ (* -1 now') x!94!165)) 0)))
                    (not (or (not (= (q x!95) 4))
                             (= (+ now (+ (* -1 now') x!94!165)) 0)))
                    (not (= (q x!95) (q' x!95)))
                    (not (= (last x!95) (last' x!95)))
                    (not (= (first x!95) (first' x!95)))
                    (not (= g g'))))))
     (>= x!149!166 1)
     (>= (+ N (* -1 x!149!166)) 0)
     (= (q' x!149!166) 2)
     (not (<= (+ now' (* -1 (last' x!149!166))) 0))
     (>= (+ A (+ now' (* -1 (last' x!149!166)))) 0)
     (>= (q' x!149!166) 0)
     (<= (q' x!149!166) 4)
     (>= (last' x!149!166) 0)
     (<= (q' x!149!166) 2)
     (>= (q' x!149!166) 2))


unsat: proved claim
add rows:             211
added eqs:            334
arith conflicts:      18
assert diseq:         13
assert lower:         493
assert upper:         256
bound prop:           1
conflicts:            57
decisions:            142
del clause:           516
eq adapter:           185
final checks:         81
fixed eqs:            67
max generation:       2
mk clause:            558
offset eqs:           15
pivots:               207
propagations:         210
quant instantiations: 323
restarts:             2
max. heap size:     2.64801 Mbytes
Unsat core:



Property was an inductive invariant! Property checked was: 
(forall (i Int)
  (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))


ASSUMPTIONS: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)}))



Properties proved and used as assumption lemmas: 


(forall (i Int)
  (implies (and (>= i 1) (<= i N))
           (implies (= (q i) 2) (<= (last i) (+ now A)))))


(forall (i Int)
  (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))


Model for basic assumptions: 


A -> 1
N -> 2
g -> 0
B -> 1
now -> 1
g' -> 0
now' -> 1
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
Unsat core:

Term:
(implies (and (and (and (forall (i Int)
                          (implies (and (>= i 1) (<= i N))
                                   (and (and (and (= (last i) A)
                                                  (= (first i) 0))
                                             (= g 0))
                                        (= now 0))))
                        (= now 0))
                   (= g 0))
              (forall (i Int) (or (= (q i) 0))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (= now 0)
     (= g 0)
     (forall (x!36 Int)
       (or (not (>= x!36 1))
           (not (>= (+ N (* -1 x!36)) 0))
           (not (or (not (= (last x!36) A)) (not (= (first x!36) 0)))))
       :pat {(last x!36)}
       :pat {(first x!36)})
     (forall (x!38 Int) (= (q x!38) 0) :pat {(q x!38)})
     (>= x!0!216 1)
     (>= (+ N (* -1 x!0!216)) 0)
     (not (>= (last x!0!216) 0))
     (<= g 0)
     (not (or (not (= (last x!0!216) A)) (not (= (first x!0!216) 0)))))


unsat: proved claim
add rows:             212
added eqs:            336
arith conflicts:      18
assert diseq:         13
assert lower:         495
assert upper:         258
bound prop:           1
conflicts:            58
decisions:            142
del clause:           558
eq adapter:           187
final checks:         83
fixed eqs:            67
max generation:       2
mk clause:            569
offset eqs:           16
pivots:               211
propagations:         211
quant instantiations: 327
restarts:             2
max. heap size:     2.69755 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 0) (= (q' h) 1))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!48!221 1)
     (>= (+ N (* -1 x!48!221)) 0)
     (= (q x!48!221) 0)
     (= (q' x!48!221) 1)
     (= (last x!48!221) (last' x!48!221))
     (= (first x!48!221) (first' x!48!221))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!48!221)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!222 1)
     (>= (+ N (* -1 x!219!222)) 0)
     (not (<= (+ now' (* -1 (last' x!219!222))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!48!221) 0)
     (<= (q x!48!221) 4)
     (>= (q' x!48!221) 0)
     (<= (q' x!48!221) 4)
     (>= (last' x!48!221) 0)
     (not (= (q' x!219!222) 2))
     (>= (last' x!219!222) 0)
     (<= (+ now (* -1 (last x!48!221))) 0)
     (>= (last x!48!221) 0)
     (>= (first' x!48!221) 0)
     (>= (first x!48!221) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!48!221) 0)
     (<= (+ (last x!48!221) (* -1 (last' x!48!221))) 0)
     (>= (+ (last x!48!221) (* -1 (last' x!48!221))) 0)
     (<= (q' x!48!221) 1)
     (>= (q' x!48!221) 1)
     (<= (+ (first x!48!221) (* -1 (first' x!48!221))) 0)
     (>= (+ (first x!48!221) (* -1 (first' x!48!221))) 0)
     (>= (q' x!219!222) 0)
     (<= (q' x!219!222) 4)
     (<= (+ now' (* -1 (last' x!48!221))) 0))


unsat: proved claim
add rows:             223
added eqs:            357
arith conflicts:      19
assert diseq:         14
assert lower:         526
assert upper:         276
bound prop:           2
conflicts:            62
decisions:            144
del clause:           583
eq adapter:           198
final checks:         89
fixed eqs:            73
max generation:       2
mk clause:            596
offset eqs:           17
pivots:               226
propagations:         219
quant instantiations: 351
restarts:             2
max. heap size:     2.87998 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!55!223 1)
     (>= (+ N (* -1 x!55!223)) 0)
     (= (q x!55!223) 1)
     (= (q' x!55!223) 1)
     (not (= g 0))
     (= (last x!55!223) (last' x!55!223))
     (= (first x!55!223) (first' x!55!223))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!55!223)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!224 1)
     (>= (+ N (* -1 x!219!224)) 0)
     (not (<= (+ now' (* -1 (last' x!219!224))) 0))
     (not (<= g 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!55!223) 0)
     (<= (q x!55!223) 4)
     (>= (q' x!55!223) 0)
     (<= (q' x!55!223) 4)
     (>= (last' x!55!223) 0)
     (not (= (q' x!219!224) 2))
     (>= (last' x!219!224) 0)
     (<= (+ now (* -1 (last x!55!223))) 0)
     (>= (last x!55!223) 0)
     (>= (first' x!55!223) 0)
     (>= (first x!55!223) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q x!55!223) 1)
     (>= (q x!55!223) 1)
     (<= (+ (last x!55!223) (* -1 (last' x!55!223))) 0)
     (>= (+ (last x!55!223) (* -1 (last' x!55!223))) 0)
     (<= (q' x!55!223) 1)
     (>= (q' x!55!223) 1)
     (<= (+ (first x!55!223) (* -1 (first' x!55!223))) 0)
     (>= (+ (first x!55!223) (* -1 (first' x!55!223))) 0)
     (>= (q' x!219!224) 0)
     (<= (q' x!219!224) 4)
     (<= (+ now' (* -1 (last' x!55!223))) 0))


unsat: proved claim
add rows:             238
added eqs:            379
arith conflicts:      20
assert diseq:         16
assert lower:         553
assert upper:         294
bound prop:           3
conflicts:            64
decisions:            146
del clause:           613
eq adapter:           210
final checks:         89
fixed eqs:            79
max generation:       2
mk clause:            626
offset eqs:           18
pivots:               238
propagations:         228
quant instantiations: 375
restarts:             2
max. heap size:     2.87998 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 2) (= g 0) (= (last' h) (+ now A)))
                 (and (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!60!225 1)
     (>= (+ N (* -1 x!60!225)) 0)
     (= (q x!60!225) 1)
     (= (q' x!60!225) 2)
     (= g 0)
     (= (+ A (+ now (* -1 (last' x!60!225)))) 0)
     (= (first x!60!225) (first' x!60!225))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!60!225)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!226 1)
     (>= (+ N (* -1 x!219!226)) 0)
     (not (<= (+ now' (* -1 (last' x!219!226))) 0))
     (<= g 0)
     (<= (+ A (+ now (* -1 (last' x!60!225)))) 0)
     (>= (+ A (+ now (* -1 (last' x!60!225)))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!60!225) 0)
     (<= (q x!60!225) 4)
     (<= (+ now' (* -1 (last' x!60!225))) 0)
     (>= (+ A (+ now' (* -1 (last' x!60!225)))) 0)
     (>= (q' x!60!225) 0)
     (<= (q' x!60!225) 4)
     (>= (last' x!60!225) 0)
     (not (= (q' x!219!226) 2))
     (>= (last' x!219!226) 0)
     (>= (first' x!60!225) 0)
     (>= (first x!60!225) 0)
     (<= (q x!60!225) 1)
     (>= (q x!60!225) 1)
     (<= (q' x!60!225) 2)
     (>= (q' x!60!225) 2)
     (<= (+ (first x!60!225) (* -1 (first' x!60!225))) 0)
     (>= (+ (first x!60!225) (* -1 (first' x!60!225))) 0)
     (>= (q' x!219!226) 0)
     (<= (q' x!219!226) 4))


unsat: proved claim
add rows:             255
added eqs:            403
arith conflicts:      21
assert diseq:         17
assert lower:         579
assert upper:         312
bound prop:           3
conflicts:            66
decisions:            148
del clause:           643
eq adapter:           222
final checks:         89
fixed eqs:            86
max generation:       2
mk clause:            656
offset eqs:           21
pivots:               250
propagations:         239
quant instantiations: 397
restarts:             2
max. heap size:     2.87998 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 2)
                      (= (q' h) 3)
                      (<= now (last h))
                      (>= now (last h))
                      (and (= g' h) (= (first' h) (+ now B))))
                 (and (= (last h) (last' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!65!227 1)
     (>= (+ N (* -1 x!65!227)) 0)
     (= (q x!65!227) 2)
     (= (q' x!65!227) 3)
     (<= (+ now (* -1 (last x!65!227))) 0)
     (>= (+ now (* -1 (last x!65!227))) 0)
     (= g' x!65!227)
     (= (+ B (+ now (* -1 (first' x!65!227)))) 0)
     (= (last x!65!227) (last' x!65!227))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!65!227)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!228 1)
     (>= (+ N (* -1 x!219!228)) 0)
     (not (<= (+ now' (* -1 (last' x!219!228))) 0))
     (<= (+ g' (* -1 x!65!227)) 0)
     (>= (+ g' (* -1 x!65!227)) 0)
     (<= (+ B (+ now (* -1 (first' x!65!227)))) 0)
     (>= (+ B (+ now (* -1 (first' x!65!227)))) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (+ A (+ now (* -1 (last x!65!227)))) 0)
     (>= (q x!65!227) 0)
     (<= (q x!65!227) 4)
     (>= (q' x!65!227) 0)
     (<= (q' x!65!227) 4)
     (>= (last x!65!227) 0)
     (>= (first' x!65!227) 0)
     (>= (last' x!65!227) 0)
     (not (= (q' x!219!228) 2))
     (>= (last' x!219!228) 0)
     (<= (q x!65!227) 2)
     (>= (q x!65!227) 2)
     (= (last' x!65!227) (last x!65!227))
     (<= (+ (last' x!65!227) (* -1 (last x!65!227))) 0)
     (>= (+ (last' x!65!227) (* -1 (last x!65!227))) 0)
     (<= (q' x!65!227) 3)
     (>= (q' x!65!227) 3)
     (>= (q' x!219!228) 0)
     (<= (q' x!219!228) 4)
     (<= (+ now' (* -1 (last' x!65!227))) 0)
     (>= (+ A (+ now' (* -1 (last' x!65!227)))) 0))


unsat: proved claim
add rows:             270
added eqs:            429
arith conflicts:      22
assert diseq:         18
assert lower:         607
assert upper:         330
bound prop:           5
conflicts:            68
decisions:            150
del clause:           675
eq adapter:           233
final checks:         89
fixed eqs:            93
max generation:       2
mk clause:            686
offset eqs:           25
pivots:               263
propagations:         249
quant instantiations: 420
restarts:             2
max. heap size:     2.87998 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3)
                      (= (q' h) 1)
                      (and (not (= g h)) (>= now (first h)))
                      (= (first' h) 0))
                 (and (= (last h) (last' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!70!229 1)
     (>= (+ N (* -1 x!70!229)) 0)
     (= (q x!70!229) 3)
     (= (q' x!70!229) 1)
     (not (= g x!70!229))
     (>= (+ now (* -1 (first x!70!229))) 0)
     (= (first' x!70!229) 0)
     (= (last x!70!229) (last' x!70!229))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!70!229)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!230 1)
     (>= (+ N (* -1 x!219!230)) 0)
     (not (<= (+ now' (* -1 (last' x!219!230))) 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!70!229) 0)
     (<= (q x!70!229) 4)
     (>= (q' x!70!229) 0)
     (<= (q' x!70!229) 4)
     (>= (first x!70!229) 0)
     (>= (first' x!70!229) 0)
     (>= (last' x!70!229) 0)
     (not (= (q' x!219!230) 2))
     (>= (last' x!219!230) 0)
     (<= (+ now (* -1 (last x!70!229))) 0)
     (>= (last x!70!229) 0)
     (<= (q x!70!229) 3)
     (>= (q x!70!229) 3)
     (= (last' x!70!229) (last x!70!229))
     (<= (+ (last' x!70!229) (* -1 (last x!70!229))) 0)
     (>= (+ (last' x!70!229) (* -1 (last x!70!229))) 0)
     (<= (q' x!70!229) 1)
     (>= (q' x!70!229) 1)
     (<= (first' x!70!229) 0)
     (>= (q' x!219!230) 0)
     (<= (q' x!219!230) 4)
     (<= (+ now' (* -1 (last' x!70!229))) 0))


unsat: proved claim
add rows:             288
added eqs:            450
arith conflicts:      23
assert diseq:         20
assert lower:         633
assert upper:         348
bound prop:           6
conflicts:            70
decisions:            152
del clause:           702
eq adapter:           245
final checks:         89
fixed eqs:            98
max generation:       2
mk clause:            717
offset eqs:           26
pivots:               277
propagations:         257
quant instantiations: 444
restarts:             2
max. heap size:     2.87998 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3) (= (q' h) 4) (and (= g h) (>= now (first h))))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!75!231 1)
     (>= (+ N (* -1 x!75!231)) 0)
     (= (q x!75!231) 3)
     (= (q' x!75!231) 4)
     (= g x!75!231)
     (>= (+ now (* -1 (first x!75!231))) 0)
     (= (last x!75!231) (last' x!75!231))
     (= (first x!75!231) (first' x!75!231))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!75!231)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!232 1)
     (>= (+ N (* -1 x!219!232)) 0)
     (not (<= (+ now' (* -1 (last' x!219!232))) 0))
     (<= (+ g (* -1 x!75!231)) 0)
     (>= (+ g (* -1 x!75!231)) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!75!231) 0)
     (<= (q x!75!231) 4)
     (>= (q' x!75!231) 0)
     (<= (q' x!75!231) 4)
     (>= (first x!75!231) 0)
     (>= (last' x!75!231) 0)
     (not (= (q' x!219!232) 2))
     (>= (last' x!219!232) 0)
     (<= (+ now (* -1 (last x!75!231))) 0)
     (>= (last x!75!231) 0)
     (>= (first' x!75!231) 0)
     (<= (q x!75!231) 3)
     (>= (q x!75!231) 3)
     (<= (+ (last x!75!231) (* -1 (last' x!75!231))) 0)
     (>= (+ (last x!75!231) (* -1 (last' x!75!231))) 0)
     (>= (q' x!75!231) 4)
     (<= (+ (first x!75!231) (* -1 (first' x!75!231))) 0)
     (>= (+ (first x!75!231) (* -1 (first' x!75!231))) 0)
     (>= (q' x!219!232) 0)
     (<= (q' x!219!232) 4)
     (<= (+ now' (* -1 (last' x!75!231))) 0))


unsat: proved claim
add rows:             307
added eqs:            470
arith conflicts:      24
assert diseq:         21
assert lower:         661
assert upper:         366
bound prop:           7
conflicts:            72
decisions:            154
del clause:           735
eq adapter:           257
final checks:         89
fixed eqs:            100
max generation:       2
mk clause:            748
offset eqs:           27
pivots:               291
propagations:         267
quant instantiations: 468
restarts:             2
max. heap size:     2.87998 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!80!233 1)
     (>= (+ N (* -1 x!80!233)) 0)
     (= (q x!80!233) 4)
     (= (q' x!80!233) 0)
     (= g' 0)
     (= (last x!80!233) (last' x!80!233))
     (= (first x!80!233) (first' x!80!233))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!80!233)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!219!234 1)
     (>= (+ N (* -1 x!219!234)) 0)
     (not (<= (+ now' (* -1 (last' x!219!234))) 0))
     (<= g' 0)
     (>= (q x!80!233) 0)
     (<= (q x!80!233) 4)
     (>= (q' x!80!233) 0)
     (<= (q' x!80!233) 4)
     (>= (last' x!80!233) 0)
     (not (= (q' x!219!234) 2))
     (>= (last' x!219!234) 0)
     (<= (+ now (* -1 (last x!80!233))) 0)
     (>= (last x!80!233) 0)
     (>= (first' x!80!233) 0)
     (>= (first x!80!233) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (>= (q x!80!233) 4)
     (<= (+ (last x!80!233) (* -1 (last' x!80!233))) 0)
     (>= (+ (last x!80!233) (* -1 (last' x!80!233))) 0)
     (<= (q' x!80!233) 0)
     (<= (+ (first x!80!233) (* -1 (first' x!80!233))) 0)
     (>= (+ (first x!80!233) (* -1 (first' x!80!233))) 0)
     (>= (q' x!219!234) 0)
     (<= (q' x!219!234) 4)
     (<= (+ now' (* -1 (last' x!80!233))) 0))


unsat: proved claim
add rows:             323
added eqs:            491
arith conflicts:      25
assert diseq:         22
assert lower:         685
assert upper:         383
bound prop:           8
conflicts:            74
decisions:            156
del clause:           759
eq adapter:           268
final checks:         89
fixed eqs:            105
max generation:       2
mk clause:            772
offset eqs:           29
pivots:               303
propagations:         274
quant instantiations: 492
restarts:             2
max. heap size:     2.87998 Mbytes
Unsat core:

Term:
(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!217 Int)
       (or (not (>= x!217 1))
           (not (>= (+ N (* -1 x!217)) 0))
           (<= (+ now (* -1 (last x!217))) 0))
       :pat {(last x!217)})
     (>= x!94!235 0)
     (forall (x!96 Real) (x!95 Int)
       (or (not (>= x!96 0))
           (not (<= (+ x!96 (* -1 x!94!235)) 0))
           (not (>= x!95 1))
           (not (>= (+ N (* -1 x!95)) 0))
           (not (or (not (or (not (= (q x!95) 0))
                             (= (+ now (+ (* -1 now') x!94!235)) 0)))
                    (not (or (not (= (q x!95) 1))
                             (= (+ now (+ (* -1 now') x!94!235)) 0)))
                    (not (or (not (= (q x!95) 2))
                             (not (or (not (<= (+ now
                                                  (+ x!96 (* -1 (last x!95))))
                                               0))
                                      (not (or (not (>= (+ now
                                                           (+ x!96
                                                              (* -1 (last x!95))))
                                                        0))
                                               (= x!94!235 x!96)))
                                      (not (= (+ now (+ (* -1 now') x!94!235))
                                              0))))))
                    (not (or (not (= (q x!95) 3))
                             (= (+ now (+ (* -1 now') x!94!235)) 0)))
                    (not (or (not (= (q x!95) 4))
                             (= (+ now (+ (* -1 now') x!94!235)) 0)))
                    (not (= (q x!95) (q' x!95)))
                    (not (= (last x!95) (last' x!95)))
                    (not (= (first x!95) (first' x!95)))
                    (not (= g g'))))))
     (>= x!219!236 1)
     (>= (+ N (* -1 x!219!236)) 0)
     (not (<= (+ now' (* -1 (last' x!219!236))) 0))
     (not (= (q' x!219!236) 2))
     (>= (last' x!219!236) 0)
     (>= (q' x!219!236) 0)
     (<= (q' x!219!236) 4))


sat: disproved claim
A -> 1
N -> 2
g -> 0
x!94!235 -> 1
x!219!236 -> 1
now -> 0
g' -> 0
now' -> 1
B -> 1
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
add rows:             332
added eqs:            504
arith conflicts:      25
assert diseq:         24
assert lower:         700
assert upper:         397
bound prop:           10
conflicts:            74
decisions:            163
del clause:           803
eq adapter:           275
final checks:         91
fixed eqs:            109
max generation:       2
mk clause:            820
offset eqs:           29
pivots:               313
propagations:         293
quant instantiations: 503
restarts:             3
max. heap size:     2.87998 Mbytes


Property was NOT an inductive invariant! Property checked was: 
(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))


Property was NOT inductive! Property checked was: 
(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))
Term:
(implies (and (and (and (forall (i Int)
                          (implies (and (>= i 1) (<= i N))
                                   (and (and (and (= (last i) A)
                                                  (= (first i) 0))
                                             (= g 0))
                                        (= now 0))))
                        (= now 0))
                   (= g 0))
              (forall (i Int) (or (= (q i) 0))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                             (> (first i) (last j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)}))


unsat: proved claim
add rows:             336
added eqs:            504
arith conflicts:      25
assert diseq:         24
assert lower:         700
assert upper:         397
bound prop:           10
conflicts:            75
decisions:            163
del clause:           820
eq adapter:           275
final checks:         91
fixed eqs:            109
max generation:       2
mk clause:            820
offset eqs:           29
pivots:               319
propagations:         293
quant instantiations: 503
restarts:             3
max. heap size:     2.87998 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                         (> (first i) (last j)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 0) (= (q' h) 1))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!48!285 1)
     (>= (+ N (* -1 x!48!285)) 0)
     (= (q x!48!285) 0)
     (= (q' x!48!285) 1)
     (= (last x!48!285) (last' x!48!285))
     (= (first x!48!285) (first' x!48!285))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!48!285)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= g' 1)
     (>= x!282!286 1)
     (>= (+ N (* -1 x!282!286)) 0)
     (= (q' g') 3)
     (= (q' x!282!286) 2)
     (<= (+ (first' g') (* -1 (last' x!282!286))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!48!285) 0)
     (<= (q x!48!285) 4)
     (>= (q' x!48!285) 0)
     (<= (q' x!48!285) 4)
     (>= (q' g') 0)
     (<= (q' g') 4)
     (<= (+ now' (* -1 (last' x!282!286))) 0)
     (>= (+ A (+ now' (* -1 (last' x!282!286)))) 0)
     (>= (q' x!282!286) 0)
     (<= (q' x!282!286) 4)
     (>= (last' x!48!285) 0)
     (>= (last' x!282!286) 0)
     (>= (last x!48!285) 0)
     (>= (first' x!48!285) 0)
     (>= (first' g') 0)
     (>= (first x!48!285) 0)
     (<= (q x!48!285) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!48!285) (* -1 (last' x!48!285))) 0)
     (>= (+ (last x!48!285) (* -1 (last' x!48!285))) 0)
     (<= (q' x!48!285) 1)
     (>= (q' x!48!285) 1)
     (<= (q' g') 3)
     (>= (q' g') 3)
     (<= (q' x!282!286) 2)
     (>= (q' x!282!286) 2)
     (<= (+ (first x!48!285) (* -1 (first' x!48!285))) 0)
     (>= (+ (first x!48!285) (* -1 (first' x!48!285))) 0))


unsat: proved claim
add rows:             374
added eqs:            592
arith conflicts:      27
assert diseq:         38
assert lower:         780
assert upper:         455
bound prop:           10
conflicts:            89
decisions:            197
del clause:           882
eq adapter:           320
final checks:         99
fixed eqs:            125
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            911
offset eqs:           29
pivots:               343
propagations:         354
quant instantiations: 574
restarts:             3
max. heap size:     2.96042 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                         (> (first i) (last j)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!55!287 1)
     (>= (+ N (* -1 x!55!287)) 0)
     (= (q x!55!287) 1)
     (= (q' x!55!287) 1)
     (not (= g 0))
     (= (last x!55!287) (last' x!55!287))
     (= (first x!55!287) (first' x!55!287))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!55!287)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= g' 1)
     (>= x!282!288 1)
     (>= (+ N (* -1 x!282!288)) 0)
     (= (q' g') 3)
     (= (q' x!282!288) 2)
     (<= (+ (first' g') (* -1 (last' x!282!288))) 0)
     (not (<= g 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!55!287) 0)
     (<= (q x!55!287) 4)
     (>= (q' x!55!287) 0)
     (<= (q' x!55!287) 4)
     (>= (q' g') 0)
     (<= (q' g') 4)
     (<= (+ now' (* -1 (last' x!282!288))) 0)
     (>= (+ A (+ now' (* -1 (last' x!282!288)))) 0)
     (>= (q' x!282!288) 0)
     (<= (q' x!282!288) 4)
     (>= (last' x!55!287) 0)
     (>= (last' x!282!288) 0)
     (>= (last x!55!287) 0)
     (>= (first' x!55!287) 0)
     (>= (first' g') 0)
     (>= (first x!55!287) 0)
     (<= (q x!55!287) 1)
     (>= (q x!55!287) 1)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!55!287) (* -1 (last' x!55!287))) 0)
     (>= (+ (last x!55!287) (* -1 (last' x!55!287))) 0)
     (<= (q' x!55!287) 1)
     (>= (q' x!55!287) 1)
     (<= (q' g') 3)
     (>= (q' g') 3)
     (<= (q' x!282!288) 2)
     (>= (q' x!282!288) 2)
     (<= (+ (first x!55!287) (* -1 (first' x!55!287))) 0)
     (>= (+ (first x!55!287) (* -1 (first' x!55!287))) 0))


unsat: proved claim
add rows:             403
added eqs:            660
arith conflicts:      29
assert diseq:         50
assert lower:         845
assert upper:         502
bound prop:           10
conflicts:            94
decisions:            213
del clause:           954
eq adapter:           353
final checks:         99
fixed eqs:            139
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            977
offset eqs:           29
pivots:               356
propagations:         391
quant instantiations: 644
restarts:             3
max. heap size:     3.12127 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                         (> (first i) (last j)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 2) (= g 0) (= (last' h) (+ now A)))
                 (and (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!60!289 1)
     (>= (+ N (* -1 x!60!289)) 0)
     (= (q x!60!289) 1)
     (= (q' x!60!289) 2)
     (= g 0)
     (= (+ A (+ now (* -1 (last' x!60!289)))) 0)
     (= (first x!60!289) (first' x!60!289))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!60!289)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= g' 1)
     (>= x!282!290 1)
     (>= (+ N (* -1 x!282!290)) 0)
     (= (q' g') 3)
     (= (q' x!282!290) 2)
     (<= (+ (first' g') (* -1 (last' x!282!290))) 0)
     (<= g 0)
     (<= (+ A (+ now (* -1 (last' x!60!289)))) 0)
     (>= (+ A (+ now (* -1 (last' x!60!289)))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0))


unsat: proved claim
add rows:             405
added eqs:            669
arith conflicts:      30
assert diseq:         50
assert lower:         852
assert upper:         506
bound prop:           10
conflicts:            95
decisions:            213
del clause:           977
eq adapter:           356
final checks:         99
fixed eqs:            140
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            987
offset eqs:           29
pivots:               360
propagations:         396
quant instantiations: 644
restarts:             3
max. heap size:     3.18747 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                         (> (first i) (last j)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 2)
                      (= (q' h) 3)
                      (<= now (last h))
                      (>= now (last h))
                      (and (= g' h) (= (first' h) (+ now B))))
                 (and (= (last h) (last' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!65!291 1)
     (>= (+ N (* -1 x!65!291)) 0)
     (= (q x!65!291) 2)
     (= (q' x!65!291) 3)
     (<= (+ now (* -1 (last x!65!291))) 0)
     (>= (+ now (* -1 (last x!65!291))) 0)
     (= g' x!65!291)
     (= (+ B (+ now (* -1 (first' x!65!291)))) 0)
     (= (last x!65!291) (last' x!65!291))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!65!291)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= g' 1)
     (>= x!282!292 1)
     (>= (+ N (* -1 x!282!292)) 0)
     (= (q' g') 3)
     (= (q' x!282!292) 2)
     (<= (+ (first' g') (* -1 (last' x!282!292))) 0)
     (<= (+ g' (* -1 x!65!291)) 0)
     (>= (+ g' (* -1 x!65!291)) 0)
     (<= (+ B (+ now (* -1 (first' x!65!291)))) 0)
     (>= (+ B (+ now (* -1 (first' x!65!291)))) 0)
     (= (first' g') (first' x!65!291))
     (<= (+ (first' g') (* -1 (first' x!65!291))) 0)
     (>= (+ (first' g') (* -1 (first' x!65!291))) 0)
     (>= (+ A (+ now (* -1 (last x!65!291)))) 0)
     (>= (q x!65!291) 0)
     (<= (q x!65!291) 4)
     (>= (q' x!65!291) 0)
     (<= (q' x!65!291) 4)
     (<= (+ now' (* -1 (last' x!282!292))) 0)
     (>= (+ A (+ now' (* -1 (last' x!282!292)))) 0)
     (>= (q' x!282!292) 0)
     (<= (q' x!282!292) 4)
     (>= (last x!65!291) 0)
     (>= (first' x!65!291) 0)
     (>= (last' x!65!291) 0)
     (>= (last' x!282!292) 0)
     (<= (q x!65!291) 2)
     (>= (q x!65!291) 2)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (= (last' x!65!291) (last x!65!291))
     (<= (+ (last' x!65!291) (* -1 (last x!65!291))) 0)
     (>= (+ (last' x!65!291) (* -1 (last x!65!291))) 0)
     (<= (q' x!65!291) 3)
     (>= (q' x!65!291) 3)
     (<= (q' x!282!292) 2)
     (>= (q' x!282!292) 2))


sat: disproved claim
A -> 1
N -> 2
g -> 0
x!65!291 -> 2
now -> 0
g' -> 2
now' -> 0
x!282!292 -> 1
B -> 1
last' -> {
  #unspecified
}
last'!327 -> {
  1 -> 1
  else -> #unspecified
}
last!330 -> {
  1 -> 1
  else -> #unspecified
}
first' -> {
  #unspecified
}
first -> {
  #unspecified
}
k!326 -> {
  #unspecified
}
last -> {
  #unspecified
}
q'!328 -> {
  1 -> 2
  else -> #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
first'!329 -> {
  1 -> 0
  else -> #unspecified
}
add rows:             448
added eqs:            710
arith conflicts:      30
assert diseq:         57
assert lower:         900
assert upper:         543
bound prop:           12
conflicts:            95
decisions:            244
del clause:           1021
eq adapter:           378
final checks:         101
fixed eqs:            153
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1063
offset eqs:           32
pivots:               377
propagations:         422
quant instantiations: 684
restarts:             4
max. heap size:     3.41031 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                         (> (first i) (last j)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3)
                      (= (q' h) 1)
                      (and (not (= g h)) (>= now (first h)))
                      (= (first' h) 0))
                 (and (= (last h) (last' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))


A -> 1
N -> 2
g -> 0
x!65!291 -> 2
now -> 0
g' -> 2
now' -> 0
x!282!292 -> 1
B -> 1
last' -> {
  #unspecified
}
last'!327 -> {
  1 -> 1
  else -> #unspecified
}
last!330 -> {
  1 -> 1
  else -> #unspecified
}
first' -> {
  #unspecified
}
first -> {
  #unspecified
}
k!326 -> {
  #unspecified
}
last -> {
  #unspecified
}
q'!328 -> {
  1 -> 2
  else -> #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
first'!329 -> {
  1 -> 0
  else -> #unspecified
}

<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!70!345 1)
     (>= (+ N (* -1 x!70!345)) 0)
     (= (q x!70!345) 3)
     (= (q' x!70!345) 1)
     (not (= g x!70!345))
     (>= (+ now (* -1 (first x!70!345))) 0)
     (= (first' x!70!345) 0)
     (= (last x!70!345) (last' x!70!345))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!70!345)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= g' 1)
     (>= x!282!346 1)
     (>= (+ N (* -1 x!282!346)) 0)
     (= (q' g') 3)
     (= (q' x!282!346) 2)
     (<= (+ (first' g') (* -1 (last' x!282!346))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!70!345) 0)
     (<= (q x!70!345) 4)
     (>= (q' x!70!345) 0)
     (<= (q' x!70!345) 4)
     (>= (q' g') 0)
     (<= (q' g') 4)
     (<= (+ now' (* -1 (last' x!282!346))) 0)
     (>= (+ A (+ now' (* -1 (last' x!282!346)))) 0)
     (>= (q' x!282!346) 0)
     (<= (q' x!282!346) 4)
     (>= (first x!70!345) 0)
     (>= (first' x!70!345) 0)
     (>= (first' g') 0)
     (>= (last' x!70!345) 0)
     (>= (last' x!282!346) 0)
     (>= (last x!70!345) 0)
     (not (= g' x!70!345))
     (<= (q x!70!345) 3)
     (>= (q x!70!345) 3)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (= (last' x!70!345) (last x!70!345))
     (<= (+ (last' x!70!345) (* -1 (last x!70!345))) 0)
     (>= (+ (last' x!70!345) (* -1 (last x!70!345))) 0)
     (<= (q' x!70!345) 1)
     (>= (q' x!70!345) 1)
     (<= (q' g') 3)
     (>= (q' g') 3)
     (<= (q' x!282!346) 2)
     (>= (q' x!282!346) 2)
     (<= (first' x!70!345) 0)
     (not (or (not (= (q g') (q' g')))
              (not (= (last g') (last' g')))
              (not (= (first g') (first' g')))))
     (= (q g') (q' g'))
     (= (last g') (last' g'))
     (= (first g') (first' g'))
     (= (q g) 3)
     (= (first g) (first' g'))
     (<= (+ (first g) (* -1 (first' g'))) 0)
     (>= (+ (first g) (* -1 (first' g'))) 0)
     (>= (first g') 0)
     (>= (last' g') 0)
     (>= (last g') 0)
     (>= (q g') 0)
     (<= (q g') 4)
     (= (first g) (first g'))
     (<= (+ (first g) (* -1 (first g'))) 0)
     (>= (+ (first g) (* -1 (first g'))) 0)
     (<= (+ (last g') (* -1 (last' g'))) 0)
     (>= (+ (last g') (* -1 (last' g'))) 0)
     (= (q g') 3)
     (<= (q g') 3)
     (>= (q g') 3))


unsat: proved claim
add rows:             490
added eqs:            762
arith conflicts:      32
assert diseq:         68
assert lower:         961
assert upper:         581
bound prop:           14
conflicts:            100
decisions:            263
del clause:           1094
eq adapter:           407
final checks:         101
fixed eqs:            163
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1121
offset eqs:           33
pivots:               399
propagations:         449
quant instantiations: 741
restarts:             4
max. heap size:     3.41031 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                         (> (first i) (last j)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3) (= (q' h) 4) (and (= g h) (>= now (first h))))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!75!347 1)
     (>= (+ N (* -1 x!75!347)) 0)
     (= (q x!75!347) 3)
     (= (q' x!75!347) 4)
     (= g x!75!347)
     (>= (+ now (* -1 (first x!75!347))) 0)
     (= (last x!75!347) (last' x!75!347))
     (= (first x!75!347) (first' x!75!347))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!75!347)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= g' 1)
     (>= x!282!348 1)
     (>= (+ N (* -1 x!282!348)) 0)
     (= (q' g') 3)
     (= (q' x!282!348) 2)
     (<= (+ (first' g') (* -1 (last' x!282!348))) 0)
     (<= (+ g (* -1 x!75!347)) 0)
     (>= (+ g (* -1 x!75!347)) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0))


unsat: proved claim
add rows:             504
added eqs:            772
arith conflicts:      32
assert diseq:         68
assert lower:         961
assert upper:         581
bound prop:           14
conflicts:            101
decisions:            263
del clause:           1121
eq adapter:           409
final checks:         101
fixed eqs:            163
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1129
offset eqs:           33
pivots:               406
propagations:         453
quant instantiations: 741
restarts:             4
max. heap size:     3.41031 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                         (> (first i) (last j)))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!80!349 1)
     (>= (+ N (* -1 x!80!349)) 0)
     (= (q x!80!349) 4)
     (= (q' x!80!349) 0)
     (= g' 0)
     (= (last x!80!349) (last' x!80!349))
     (= (first x!80!349) (first' x!80!349))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!80!349)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= g' 1)
     (>= x!282!350 1)
     (>= (+ N (* -1 x!282!350)) 0)
     (= (q' g') 3)
     (= (q' x!282!350) 2)
     (<= (+ (first' g') (* -1 (last' x!282!350))) 0)
     (<= g' 0))


unsat: proved claim
add rows:             504
added eqs:            772
arith conflicts:      32
assert diseq:         68
assert lower:         961
assert upper:         581
bound prop:           14
conflicts:            102
decisions:            263
del clause:           1129
eq adapter:           410
final checks:         101
fixed eqs:            163
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1132
offset eqs:           33
pivots:               406
propagations:         454
quant instantiations: 741
restarts:             4
max. heap size:     3.41574 Mbytes
Unsat core:

Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!278 Int)
       (or (not (>= g 1))
           (not (>= (+ N (* -1 g)) 0))
           (not (>= x!278 1))
           (not (>= (+ N (* -1 x!278)) 0))
           (not (= (q g) 3))
           (not (= (q x!278) 2))
           (not (>= (+ (last x!278) (* -1 (first g))) 0)))
       :pat {(q x!278)}
       :pat {(last x!278)})
     (>= x!94!351 0)
     (forall (x!96 Real) (x!95 Int)
       (or (not (>= x!96 0))
           (not (<= (+ x!96 (* -1 x!94!351)) 0))
           (not (>= x!95 1))
           (not (>= (+ N (* -1 x!95)) 0))
           (not (or (not (or (not (= (q x!95) 0))
                             (= (+ now (+ (* -1 now') x!94!351)) 0)))
                    (not (or (not (= (q x!95) 1))
                             (= (+ now (+ (* -1 now') x!94!351)) 0)))
                    (not (or (not (= (q x!95) 2))
                             (not (or (not (<= (+ now
                                                  (+ x!96 (* -1 (last x!95))))
                                               0))
                                      (not (or (not (>= (+ now
                                                           (+ x!96
                                                              (* -1 (last x!95))))
                                                        0))
                                               (= x!94!351 x!96)))
                                      (not (= (+ now (+ (* -1 now') x!94!351))
                                              0))))))
                    (not (or (not (= (q x!95) 3))
                             (= (+ now (+ (* -1 now') x!94!351)) 0)))
                    (not (or (not (= (q x!95) 4))
                             (= (+ now (+ (* -1 now') x!94!351)) 0)))
                    (not (= (q x!95) (q' x!95)))
                    (not (= (last x!95) (last' x!95)))
                    (not (= (first x!95) (first' x!95)))
                    (not (= g g'))))))
     (>= g' 1)
     (>= x!282!352 1)
     (>= (+ N (* -1 x!282!352)) 0)
     (= (q' g') 3)
     (= (q' x!282!352) 2)
     (<= (+ (first' g') (* -1 (last' x!282!352))) 0)
     (>= (q' g') 0)
     (<= (q' g') 4)
     (<= (+ now' (* -1 (last' x!282!352))) 0)
     (>= (+ A (+ now' (* -1 (last' x!282!352)))) 0)
     (>= (q' x!282!352) 0)
     (<= (q' x!282!352) 4)
     (>= (first' g') 0)
     (>= (last' x!282!352) 0)
     (<= (q' g') 3)
     (>= (q' g') 3)
     (<= (q' x!282!352) 2)
     (>= (q' x!282!352) 2))


unsat: proved claim
add rows:             540
added eqs:            845
arith conflicts:      34
assert diseq:         117
assert lower:         1073
assert upper:         635
bound prop:           18
conflicts:            109
decisions:            371
del clause:           1294
eq adapter:           468
final checks:         107
fixed eqs:            188
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1435
offset eqs:           34
pivots:               423
propagations:         579
quant instantiations: 800
restarts:             7
max. heap size:     3.61901 Mbytes
Unsat core:



Property was NOT an inductive invariant! Property checked was: 
(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                    (> (first i) (last j)))))


Property was NOT inductive! Property checked was: 
(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                    (> (first i) (last j)))))
Term:
(implies (and (and (and (forall (i Int)
                          (implies (and (>= i 1) (<= i N))
                                   (and (and (and (= (last i) A)
                                                  (= (first i) 0))
                                             (= g 0))
                                        (= now 0))))
                        (= now 0))
                   (= g 0))
              (forall (i Int) (or (= (q i) 0))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q i) 4) (and (= g i) (not (= (q j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (= now 0)
     (= g 0)
     (forall (x!36 Int)
       (or (not (>= x!36 1))
           (not (>= (+ N (* -1 x!36)) 0))
           (not (or (not (= (last x!36) A)) (not (= (first x!36) 0)))))
       :pat {(last x!36)}
       :pat {(first x!36)})
     (forall (x!38 Int) (= (q x!38) 0) :pat {(q x!38)})
     (>= x!429!433 1)
     (>= (+ N (* -1 x!429!433)) 0)
     (>= x!430!434 1)
     (>= (+ N (* -1 x!430!434)) 0)
     (= (q x!429!433) 4)
     (not (<= x!429!433 0))
     (>= x!429!433 0)
     (not (= x!429!433 0))
     (<= g 0)
     (= (q x!429!433) 0)
     (>= (q x!429!433) 0)
     (<= (q x!429!433) 4))


unsat: proved claim
add rows:             567
added eqs:            856
arith conflicts:      34
assert diseq:         119
assert lower:         1087
assert upper:         638
bound prop:           18
conflicts:            111
decisions:            377
del clause:           1443
eq adapter:           473
final checks:         112
fixed eqs:            190
interface eqs:        7
max generation:       3
minimized lits:       1
mk clause:            1447
offset eqs:           34
pivots:               441
propagations:         582
quant instantiations: 805
restarts:             7
max. heap size:     3.71739 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 0) (= (q' h) 1))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!436 Int) (x!435 Int)
       (or (not (>= x!435 1))
           (not (>= (+ N (* -1 x!435)) 0))
           (not (>= x!436 1))
           (not (>= (+ N (* -1 x!436)) 0))
           (not (= (q x!435) 4))
           (not (or (not (= g x!435)) (= (q x!436) 2))))
       :pat {(q x!435) (q x!436)})
     (>= x!48!443 1)
     (>= (+ N (* -1 x!48!443)) 0)
     (= (q x!48!443) 0)
     (= (q' x!48!443) 1)
     (= (last x!48!443) (last' x!48!443))
     (= (first x!48!443) (first' x!48!443))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!48!443)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!439!444 1)
     (>= (+ N (* -1 x!439!444)) 0)
     (>= x!440!445 1)
     (>= (+ N (* -1 x!440!445)) 0)
     (= (q' x!439!444) 4)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!48!443) 0)
     (<= (q x!48!443) 4)
     (>= (q' x!48!443) 0)
     (<= (q' x!48!443) 4)
     (>= (q' x!439!444) 0)
     (<= (q' x!439!444) 4)
     (>= (last' x!48!443) 0)
     (>= (last x!48!443) 0)
     (>= (first' x!48!443) 0)
     (>= (first x!48!443) 0)
     (<= (q x!48!443) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!48!443) (* -1 (last' x!48!443))) 0)
     (>= (+ (last x!48!443) (* -1 (last' x!48!443))) 0)
     (<= (q' x!48!443) 1)
     (>= (q' x!48!443) 1)
     (>= (q' x!439!444) 4)
     (<= (+ (first x!48!443) (* -1 (first' x!48!443))) 0)
     (>= (+ (first x!48!443) (* -1 (first' x!48!443))) 0))


unsat: proved claim
add rows:             602
added eqs:            911
arith conflicts:      36
assert diseq:         136
assert lower:         1150
assert upper:         679
bound prop:           20
conflicts:            118
decisions:            408
del clause:           1496
eq adapter:           504
final checks:         122
fixed eqs:            200
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            1542
offset eqs:           37
pivots:               456
propagations:         630
quant instantiations: 855
restarts:             7
max. heap size:     3.8152 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!436 Int) (x!435 Int)
       (or (not (>= x!435 1))
           (not (>= (+ N (* -1 x!435)) 0))
           (not (>= x!436 1))
           (not (>= (+ N (* -1 x!436)) 0))
           (not (= (q x!435) 4))
           (not (or (not (= g x!435)) (= (q x!436) 2))))
       :pat {(q x!435) (q x!436)})
     (>= x!55!446 1)
     (>= (+ N (* -1 x!55!446)) 0)
     (= (q x!55!446) 1)
     (= (q' x!55!446) 1)
     (not (= g 0))
     (= (last x!55!446) (last' x!55!446))
     (= (first x!55!446) (first' x!55!446))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!55!446)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!439!447 1)
     (>= (+ N (* -1 x!439!447)) 0)
     (>= x!440!448 1)
     (>= (+ N (* -1 x!440!448)) 0)
     (= (q' x!439!447) 4)
     (not (<= g 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!55!446) 0)
     (<= (q x!55!446) 4)
     (>= (q' x!55!446) 0)
     (<= (q' x!55!446) 4)
     (>= (q' x!439!447) 0)
     (<= (q' x!439!447) 4)
     (>= (last' x!55!446) 0)
     (>= (last x!55!446) 0)
     (>= (first' x!55!446) 0)
     (>= (first x!55!446) 0)
     (<= (q x!55!446) 1)
     (>= (q x!55!446) 1)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!55!446) (* -1 (last' x!55!446))) 0)
     (>= (+ (last x!55!446) (* -1 (last' x!55!446))) 0)
     (<= (q' x!55!446) 1)
     (>= (q' x!55!446) 1)
     (>= (q' x!439!447) 4)
     (<= (+ (first x!55!446) (* -1 (first' x!55!446))) 0)
     (>= (+ (first x!55!446) (* -1 (first' x!55!446))) 0))


unsat: proved claim
add rows:             627
added eqs:            973
arith conflicts:      38
assert diseq:         159
assert lower:         1221
assert upper:         726
bound prop:           20
conflicts:            124
decisions:            440
del clause:           1609
eq adapter:           540
final checks:         122
fixed eqs:            214
interface eqs:        11
max generation:       3
minimized lits:       2
mk clause:            1642
offset eqs:           37
pivots:               464
propagations:         690
quant instantiations: 928
restarts:             7
max. heap size:     3.8152 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 2) (= g 0) (= (last' h) (+ now A)))
                 (and (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!436 Int) (x!435 Int)
       (or (not (>= x!435 1))
           (not (>= (+ N (* -1 x!435)) 0))
           (not (>= x!436 1))
           (not (>= (+ N (* -1 x!436)) 0))
           (not (= (q x!435) 4))
           (not (or (not (= g x!435)) (= (q x!436) 2))))
       :pat {(q x!435) (q x!436)})
     (>= x!60!449 1)
     (>= (+ N (* -1 x!60!449)) 0)
     (= (q x!60!449) 1)
     (= (q' x!60!449) 2)
     (= g 0)
     (= (+ A (+ now (* -1 (last' x!60!449)))) 0)
     (= (first x!60!449) (first' x!60!449))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!60!449)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!439!450 1)
     (>= (+ N (* -1 x!439!450)) 0)
     (>= x!440!451 1)
     (>= (+ N (* -1 x!440!451)) 0)
     (= (q' x!439!450) 4)
     (<= g 0)
     (<= (+ A (+ now (* -1 (last' x!60!449)))) 0)
     (>= (+ A (+ now (* -1 (last' x!60!449)))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (<= (+ g' (* -1 x!439!450)) 0)
     (not (>= (+ g' (* -1 x!439!450)) 0))
     (>= (q x!60!449) 0)
     (<= (q x!60!449) 4)
     (<= (+ now' (* -1 (last' x!60!449))) 0)
     (>= (+ A (+ now' (* -1 (last' x!60!449)))) 0)
     (>= (q' x!60!449) 0)
     (<= (q' x!60!449) 4)
     (>= (q' x!439!450) 0)
     (<= (q' x!439!450) 4)
     (>= (last' x!60!449) 0)
     (>= (first' x!60!449) 0)
     (>= (first x!60!449) 0)
     (not (= g' x!439!450))
     (<= (q x!60!449) 1)
     (>= (q x!60!449) 1)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q' x!60!449) 2)
     (>= (q' x!60!449) 2)
     (>= (q' x!439!450) 4)
     (<= (+ (first x!60!449) (* -1 (first' x!60!449))) 0)
     (>= (+ (first x!60!449) (* -1 (first' x!60!449))) 0)
     (<= (+ g (* -1 x!60!449)) 0)
     (not (>= (+ g (* -1 x!60!449)) 0))
     (not (= g x!60!449))
     (or (not (= g x!60!449)) (= (q x!60!449) 2))
     (not (= (q x!60!449) 4))
     (not (>= (q x!60!449) 4)))


unsat: proved claim
add rows:             633
added eqs:            1000
arith conflicts:      38
assert diseq:         165
assert lower:         1245
assert upper:         744
bound prop:           26
conflicts:            127
decisions:            446
del clause:           1683
eq adapter:           556
final checks:         122
fixed eqs:            217
interface eqs:        11
max generation:       3
minimized lits:       2
mk clause:            1702
offset eqs:           40
pivots:               468
propagations:         714
quant instantiations: 961
restarts:             7
max. heap size:     3.8152 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 2)
                      (= (q' h) 3)
                      (<= now (last h))
                      (>= now (last h))
                      (and (= g' h) (= (first' h) (+ now B))))
                 (and (= (last h) (last' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!436 Int) (x!435 Int)
       (or (not (>= x!435 1))
           (not (>= (+ N (* -1 x!435)) 0))
           (not (>= x!436 1))
           (not (>= (+ N (* -1 x!436)) 0))
           (not (= (q x!435) 4))
           (not (or (not (= g x!435)) (= (q x!436) 2))))
       :pat {(q x!435) (q x!436)})
     (>= x!65!452 1)
     (>= (+ N (* -1 x!65!452)) 0)
     (= (q x!65!452) 2)
     (= (q' x!65!452) 3)
     (<= (+ now (* -1 (last x!65!452))) 0)
     (>= (+ now (* -1 (last x!65!452))) 0)
     (= g' x!65!452)
     (= (+ B (+ now (* -1 (first' x!65!452)))) 0)
     (= (last x!65!452) (last' x!65!452))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!65!452)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!439!453 1)
     (>= (+ N (* -1 x!439!453)) 0)
     (>= x!440!454 1)
     (>= (+ N (* -1 x!440!454)) 0)
     (= (q' x!439!453) 4)
     (<= (+ g' (* -1 x!65!452)) 0)
     (>= (+ g' (* -1 x!65!452)) 0)
     (<= (+ B (+ now (* -1 (first' x!65!452)))) 0)
     (>= (+ B (+ now (* -1 (first' x!65!452)))) 0)
     (or (not (= g x!65!452)) (= (q x!65!452) 2))
     (not (= (q x!65!452) 4))
     (>= (+ A (+ now (* -1 (last x!65!452)))) 0)
     (>= (q x!65!452) 0)
     (<= (q x!65!452) 4)
     (>= (q' x!65!452) 0)
     (<= (q' x!65!452) 4)
     (>= (q' x!439!453) 0)
     (<= (q' x!439!453) 4)
     (>= (last x!65!452) 0)
     (>= (first' x!65!452) 0)
     (>= (last' x!65!452) 0)
     (<= (q x!65!452) 2)
     (>= (q x!65!452) 2)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!65!452) (* -1 (last' x!65!452))) 0)
     (>= (+ (last x!65!452) (* -1 (last' x!65!452))) 0)
     (<= (q' x!65!452) 3)
     (>= (q' x!65!452) 3)
     (>= (q' x!439!453) 4)
     (not (>= (q x!65!452) 4)))


unsat: proved claim
add rows:             636
added eqs:            1021
arith conflicts:      38
assert diseq:         166
assert lower:         1266
assert upper:         755
bound prop:           26
conflicts:            129
decisions:            447
del clause:           1723
eq adapter:           568
final checks:         122
fixed eqs:            220
interface eqs:        11
max generation:       3
minimized lits:       2
mk clause:            1743
offset eqs:           41
pivots:               472
propagations:         723
quant instantiations: 984
restarts:             7
max. heap size:     3.8152 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3)
                      (= (q' h) 1)
                      (and (not (= g h)) (>= now (first h)))
                      (= (first' h) 0))
                 (and (= (last h) (last' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!436 Int) (x!435 Int)
       (or (not (>= x!435 1))
           (not (>= (+ N (* -1 x!435)) 0))
           (not (>= x!436 1))
           (not (>= (+ N (* -1 x!436)) 0))
           (not (= (q x!435) 4))
           (not (or (not (= g x!435)) (= (q x!436) 2))))
       :pat {(q x!435) (q x!436)})
     (>= x!70!455 1)
     (>= (+ N (* -1 x!70!455)) 0)
     (= (q x!70!455) 3)
     (= (q' x!70!455) 1)
     (not (= g x!70!455))
     (>= (+ now (* -1 (first x!70!455))) 0)
     (= (first' x!70!455) 0)
     (= (last x!70!455) (last' x!70!455))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!70!455)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!439!456 1)
     (>= (+ N (* -1 x!439!456)) 0)
     (>= x!440!457 1)
     (>= (+ N (* -1 x!440!457)) 0)
     (= (q' x!439!456) 4)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (or (not (= g x!70!455)) (= (q x!70!455) 2))
     (not (= (q x!70!455) 4))
     (>= (q x!70!455) 0)
     (<= (q x!70!455) 4)
     (>= (q' x!70!455) 0)
     (<= (q' x!70!455) 4)
     (>= (q' x!439!456) 0)
     (<= (q' x!439!456) 4)
     (>= (first x!70!455) 0)
     (>= (first' x!70!455) 0)
     (>= (last' x!70!455) 0)
     (>= (last x!70!455) 0)
     (<= (q x!70!455) 3)
     (>= (q x!70!455) 3)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!70!455) (* -1 (last' x!70!455))) 0)
     (>= (+ (last x!70!455) (* -1 (last' x!70!455))) 0)
     (<= (q' x!70!455) 1)
     (>= (q' x!70!455) 1)
     (>= (q' x!439!456) 4)
     (<= (first' x!70!455) 0)
     (not (>= (q x!70!455) 4)))


unsat: proved claim
add rows:             654
added eqs:            1058
arith conflicts:      39
assert diseq:         176
assert lower:         1316
assert upper:         783
bound prop:           28
conflicts:            132
decisions:            456
del clause:           1779
eq adapter:           593
final checks:         122
fixed eqs:            229
interface eqs:        11
max generation:       3
minimized lits:       2
mk clause:            1808
offset eqs:           41
pivots:               478
propagations:         748
quant instantiations: 1024
restarts:             7
max. heap size:     3.91582 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3) (= (q' h) 4) (and (= g h) (>= now (first h))))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!436 Int) (x!435 Int)
       (or (not (>= x!435 1))
           (not (>= (+ N (* -1 x!435)) 0))
           (not (>= x!436 1))
           (not (>= (+ N (* -1 x!436)) 0))
           (not (= (q x!435) 4))
           (not (or (not (= g x!435)) (= (q x!436) 2))))
       :pat {(q x!435) (q x!436)})
     (>= x!75!458 1)
     (>= (+ N (* -1 x!75!458)) 0)
     (= (q x!75!458) 3)
     (= (q' x!75!458) 4)
     (= g x!75!458)
     (>= (+ now (* -1 (first x!75!458))) 0)
     (= (last x!75!458) (last' x!75!458))
     (= (first x!75!458) (first' x!75!458))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!75!458)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!439!459 1)
     (>= (+ N (* -1 x!439!459)) 0)
     (>= x!440!460 1)
     (>= (+ N (* -1 x!440!460)) 0)
     (= (q' x!439!459) 4)
     (<= (+ g (* -1 x!75!458)) 0)
     (>= (+ g (* -1 x!75!458)) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!75!458) 0)
     (<= (q x!75!458) 4)
     (>= (q' x!75!458) 0)
     (<= (q' x!75!458) 4)
     (>= (q' x!439!459) 0)
     (<= (q' x!439!459) 4)
     (>= (first x!75!458) 0)
     (>= (last' x!75!458) 0)
     (>= (last x!75!458) 0)
     (>= (first' x!75!458) 0)
     (<= (q x!75!458) 3)
     (>= (q x!75!458) 3)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!75!458) (* -1 (last' x!75!458))) 0)
     (>= (+ (last x!75!458) (* -1 (last' x!75!458))) 0)
     (>= (q' x!75!458) 4)
     (>= (q' x!439!459) 4)
     (<= (+ (first x!75!458) (* -1 (first' x!75!458))) 0)
     (>= (+ (first x!75!458) (* -1 (first' x!75!458))) 0))


sat: disproved claim
A -> 1
N -> 4
g -> 1
now -> 0
x!439!459 -> 1
g' -> 1
now' -> 0
x!440!460 -> 2
B -> 1
x!75!458 -> 1
last' -> {
  #unspecified
}
q!487 -> {
  2 -> 2
  4 -> 0
  else -> #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
k!485 -> {
  #unspecified
}
q -> {
  #unspecified
}
q'!486 -> {
  2 -> 2
  4 -> 0
  else -> #unspecified
}
add rows:             689
added eqs:            1116
arith conflicts:      39
assert diseq:         199
assert lower:         1385
assert upper:         824
bound prop:           36
conflicts:            134
decisions:            487
del clause:           1878
eq adapter:           632
final checks:         124
fixed eqs:            234
interface eqs:        11
max generation:       3
minimized lits:       2
mk clause:            1916
offset eqs:           43
pivots:               493
propagations:         794
quant instantiations: 1081
restarts:             8
max. heap size:     4.40667 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))


A -> 1
N -> 4
g -> 1
now -> 0
x!439!459 -> 1
g' -> 1
now' -> 0
x!440!460 -> 2
B -> 1
x!75!458 -> 1
last' -> {
  #unspecified
}
q!487 -> {
  2 -> 2
  4 -> 0
  else -> #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
k!485 -> {
  #unspecified
}
q -> {
  #unspecified
}
q'!486 -> {
  2 -> 2
  4 -> 0
  else -> #unspecified
}

<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!436 Int) (x!435 Int)
       (or (not (>= x!435 1))
           (not (>= (+ N (* -1 x!435)) 0))
           (not (>= x!436 1))
           (not (>= (+ N (* -1 x!436)) 0))
           (not (= (q x!435) 4))
           (not (or (not (= g x!435)) (= (q x!436) 2))))
       :pat {(q x!435) (q x!436)})
     (>= x!80!503 1)
     (>= (+ N (* -1 x!80!503)) 0)
     (= (q x!80!503) 4)
     (= (q' x!80!503) 0)
     (= g' 0)
     (= (last x!80!503) (last' x!80!503))
     (= (first x!80!503) (first' x!80!503))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!80!503)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!439!504 1)
     (>= (+ N (* -1 x!439!504)) 0)
     (>= x!440!505 1)
     (>= (+ N (* -1 x!440!505)) 0)
     (= (q' x!439!504) 4)
     (<= g' 0)
     (<= (+ g' (* -1 x!439!504)) 0)
     (not (>= (+ g' (* -1 x!439!504)) 0))
     (not (or (not (= g x!80!503)) (= (q x!80!503) 2)))
     (>= (q x!80!503) 0)
     (<= (q x!80!503) 4)
     (>= (q' x!80!503) 0)
     (<= (q' x!80!503) 4)
     (>= (q' x!439!504) 0)
     (<= (q' x!439!504) 4)
     (>= (last' x!80!503) 0)
     (>= (last x!80!503) 0)
     (>= (first' x!80!503) 0)
     (>= (first x!80!503) 0)
     (not (= g' x!439!504))
     (= g x!80!503)
     (not (= (q x!80!503) 2))
     (<= (+ g (* -1 x!80!503)) 0)
     (>= (+ g (* -1 x!80!503)) 0)
     (not (= (q' x!439!504) 2))
     (>= (q x!80!503) 4)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!80!503) (* -1 (last' x!80!503))) 0)
     (>= (+ (last x!80!503) (* -1 (last' x!80!503))) 0)
     (<= (q' x!80!503) 0)
     (>= (q' x!439!504) 4)
     (<= (+ (first x!80!503) (* -1 (first' x!80!503))) 0)
     (>= (+ (first x!80!503) (* -1 (first' x!80!503))) 0)
     (not (<= (q x!80!503) 2))
     (>= (q x!80!503) 2)
     (not (<= (q' x!439!504) 2))
     (>= (q' x!439!504) 2))


unsat: proved claim
add rows:             714
added eqs:            1143
arith conflicts:      39
assert diseq:         205
assert lower:         1408
assert upper:         835
bound prop:           38
conflicts:            136
decisions:            490
del clause:           1950
eq adapter:           646
final checks:         124
fixed eqs:            237
interface eqs:        11
max generation:       3
minimized lits:       2
mk clause:            1965
offset eqs:           44
pivots:               506
propagations:         811
quant instantiations: 1115
restarts:             8
max. heap size:     4.40667 Mbytes
Unsat core:

Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!436 Int) (x!435 Int)
       (or (not (>= x!435 1))
           (not (>= (+ N (* -1 x!435)) 0))
           (not (>= x!436 1))
           (not (>= (+ N (* -1 x!436)) 0))
           (not (= (q x!435) 4))
           (not (or (not (= g x!435)) (= (q x!436) 2))))
       :pat {(q x!435) (q x!436)})
     (>= x!94!506 0)
     (forall (x!96 Real) (x!95 Int)
       (or (not (>= x!96 0))
           (not (<= (+ x!96 (* -1 x!94!506)) 0))
           (not (>= x!95 1))
           (not (>= (+ N (* -1 x!95)) 0))
           (not (or (not (or (not (= (q x!95) 0))
                             (= (+ now (+ (* -1 now') x!94!506)) 0)))
                    (not (or (not (= (q x!95) 1))
                             (= (+ now (+ (* -1 now') x!94!506)) 0)))
                    (not (or (not (= (q x!95) 2))
                             (not (or (not (<= (+ now
                                                  (+ x!96 (* -1 (last x!95))))
                                               0))
                                      (not (or (not (>= (+ now
                                                           (+ x!96
                                                              (* -1 (last x!95))))
                                                        0))
                                               (= x!94!506 x!96)))
                                      (not (= (+ now (+ (* -1 now') x!94!506))
                                              0))))))
                    (not (or (not (= (q x!95) 3))
                             (= (+ now (+ (* -1 now') x!94!506)) 0)))
                    (not (or (not (= (q x!95) 4))
                             (= (+ now (+ (* -1 now') x!94!506)) 0)))
                    (not (= (q x!95) (q' x!95)))
                    (not (= (last x!95) (last' x!95)))
                    (not (= (first x!95) (first' x!95)))
                    (not (= g g'))))))
     (>= x!439!507 1)
     (>= (+ N (* -1 x!439!507)) 0)
     (>= x!440!508 1)
     (>= (+ N (* -1 x!440!508)) 0)
     (= (q' x!439!507) 4)
     (>= (q' x!439!507) 0)
     (<= (q' x!439!507) 4)
     (>= (q' x!439!507) 4))


unsat: proved claim
add rows:             742
added eqs:            1180
arith conflicts:      40
assert diseq:         216
assert lower:         1452
assert upper:         860
bound prop:           41
conflicts:            137
decisions:            499
del clause:           2079
eq adapter:           669
final checks:         127
fixed eqs:            246
interface eqs:        12
max generation:       3
minimized lits:       2
mk clause:            2115
offset eqs:           44
pivots:               515
propagations:         861
quant instantiations: 1143
restarts:             10
max. heap size:     4.40667 Mbytes
Unsat core:



Property was NOT an inductive invariant! Property checked was: 
(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))


Property was NOT inductive! Property checked was: 
(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
Term:
(implies (and (and (and (forall (i Int)
                          (implies (and (>= i 1) (<= i N))
                                   (and (and (and (= (last i) A)
                                                  (= (first i) 0))
                                             (= g 0))
                                        (= now 0))))
                        (= now 0))
                   (= g 0))
              (forall (i Int) (or (= (q i) 0))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q i) 4)) (not (= (q j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (= now 0)
     (= g 0)
     (forall (x!36 Int)
       (or (not (>= x!36 1))
           (not (>= (+ N (* -1 x!36)) 0))
           (not (or (not (= (last x!36) A)) (not (= (first x!36) 0)))))
       :pat {(last x!36)}
       :pat {(first x!36)})
     (forall (x!38 Int) (= (q x!38) 0) :pat {(q x!38)})
     (>= x!553!557 1)
     (>= (+ N (* -1 x!553!557)) 0)
     (>= x!554!558 1)
     (>= (+ N (* -1 x!554!558)) 0)
     (not (= x!553!557 x!554!558))
     (= (q x!553!557) 4)
     (= (q x!554!558) 4)
     (<= g 0)
     (= (q x!553!557) 0)
     (>= (q x!553!557) 0)
     (<= (q x!553!557) 4)
     (= (q x!554!558) 0)
     (>= (q x!554!558) 0)
     (<= (q x!554!558) 4))


unsat: proved claim
add rows:             757
added eqs:            1187
arith conflicts:      40
assert diseq:         218
assert lower:         1460
assert upper:         865
bound prop:           41
conflicts:            139
decisions:            501
del clause:           2119
eq adapter:           672
final checks:         130
fixed eqs:            246
interface eqs:        12
max generation:       3
minimized lits:       2
mk clause:            2129
offset eqs:           45
pivots:               528
propagations:         864
quant instantiations: 1153
restarts:             10
max. heap size:     4.58588 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 0) (= (q' h) 1))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 0) (= (q' h) 1))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!554 Int) (x!553 Int)
       (or (not (>= x!553 1))
           (not (>= (+ N (* -1 x!553)) 0))
           (not (>= x!554 1))
           (not (>= (+ N (* -1 x!554)) 0))
           (= x!553 x!554)
           (not (= (q x!553) 4))
           (not (= (q x!554) 4)))
       :pat {(q x!553) (q x!554)})
     (>= x!48!563 1)
     (>= (+ N (* -1 x!48!563)) 0)
     (= (q x!48!563) 0)
     (= (q' x!48!563) 1)
     (= (last x!48!563) (last' x!48!563))
     (= (first x!48!563) (first' x!48!563))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!48!563)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!559!564 1)
     (>= (+ N (* -1 x!559!564)) 0)
     (>= x!560!565 1)
     (>= (+ N (* -1 x!560!565)) 0)
     (not (= x!559!564 x!560!565))
     (= (q' x!559!564) 4)
     (= (q' x!560!565) 4)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!48!563) 0)
     (<= (q x!48!563) 4)
     (>= (q' x!48!563) 0)
     (<= (q' x!48!563) 4)
     (>= (q' x!559!564) 0)
     (<= (q' x!559!564) 4)
     (>= (q' x!560!565) 0)
     (<= (q' x!560!565) 4)
     (>= (last' x!48!563) 0)
     (>= (last x!48!563) 0)
     (>= (first' x!48!563) 0)
     (>= (first x!48!563) 0)
     (<= (q x!48!563) 0)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!48!563) (* -1 (last' x!48!563))) 0)
     (>= (+ (last x!48!563) (* -1 (last' x!48!563))) 0)
     (<= (q' x!48!563) 1)
     (>= (q' x!48!563) 1)
     (>= (q' x!559!564) 4)
     (>= (q' x!560!565) 4)
     (<= (+ (first x!48!563) (* -1 (first' x!48!563))) 0)
     (>= (+ (first x!48!563) (* -1 (first' x!48!563))) 0))


unsat: proved claim
add rows:             764
added eqs:            1224
arith conflicts:      40
assert diseq:         226
assert lower:         1499
assert upper:         883
bound prop:           41
conflicts:            142
decisions:            506
del clause:           2147
eq adapter:           694
final checks:         133
fixed eqs:            249
interface eqs:        12
max generation:       3
minimized lits:       2
mk clause:            2182
offset eqs:           45
pivots:               535
propagations:         880
quant instantiations: 1203
restarts:             10
max. heap size:     4.72574 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1) (= (q' h) 1) (not (= g 0)))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!554 Int) (x!553 Int)
       (or (not (>= x!553 1))
           (not (>= (+ N (* -1 x!553)) 0))
           (not (>= x!554 1))
           (not (>= (+ N (* -1 x!554)) 0))
           (= x!553 x!554)
           (not (= (q x!553) 4))
           (not (= (q x!554) 4)))
       :pat {(q x!553) (q x!554)})
     (>= x!55!566 1)
     (>= (+ N (* -1 x!55!566)) 0)
     (= (q x!55!566) 1)
     (= (q' x!55!566) 1)
     (not (= g 0))
     (= (last x!55!566) (last' x!55!566))
     (= (first x!55!566) (first' x!55!566))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!55!566)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!559!567 1)
     (>= (+ N (* -1 x!559!567)) 0)
     (>= x!560!568 1)
     (>= (+ N (* -1 x!560!568)) 0)
     (not (= x!559!567 x!560!568))
     (= (q' x!559!567) 4)
     (= (q' x!560!568) 4)
     (not (<= g 0))
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (not (= x!560!568 x!559!567))
     (>= (q x!55!566) 0)
     (<= (q x!55!566) 4)
     (>= (q' x!55!566) 0)
     (<= (q' x!55!566) 4)
     (>= (q' x!559!567) 0)
     (<= (q' x!559!567) 4)
     (>= (q' x!560!568) 0)
     (<= (q' x!560!568) 4)
     (>= (last' x!55!566) 0)
     (>= (last x!55!566) 0)
     (>= (first' x!55!566) 0)
     (>= (first x!55!566) 0)
     (<= (q x!55!566) 1)
     (>= (q x!55!566) 1)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!55!566) (* -1 (last' x!55!566))) 0)
     (>= (+ (last x!55!566) (* -1 (last' x!55!566))) 0)
     (<= (q' x!55!566) 1)
     (>= (q' x!55!566) 1)
     (>= (q' x!559!567) 4)
     (>= (q' x!560!568) 4)
     (<= (+ (first x!55!566) (* -1 (first' x!55!566))) 0)
     (>= (+ (first x!55!566) (* -1 (first' x!55!566))) 0))


unsat: proved claim
add rows:             765
added eqs:            1259
arith conflicts:      40
assert diseq:         235
assert lower:         1536
assert upper:         897
bound prop:           41
conflicts:            144
decisions:            509
del clause:           2199
eq adapter:           716
final checks:         133
fixed eqs:            252
interface eqs:        12
max generation:       3
minimized lits:       2
mk clause:            2233
offset eqs:           45
pivots:               536
propagations:         895
quant instantiations: 1253
restarts:             10
max. heap size:     4.72574 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 1) (= (q' h) 2) (= g 0) (= (last' h) (+ now A)))
                 (and (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 1)
                               (= (q' h) 2)
                               (= g 0)
                               (= (last' h) (+ now A)))
                          (and (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!554 Int) (x!553 Int)
       (or (not (>= x!553 1))
           (not (>= (+ N (* -1 x!553)) 0))
           (not (>= x!554 1))
           (not (>= (+ N (* -1 x!554)) 0))
           (= x!553 x!554)
           (not (= (q x!553) 4))
           (not (= (q x!554) 4)))
       :pat {(q x!553) (q x!554)})
     (>= x!60!569 1)
     (>= (+ N (* -1 x!60!569)) 0)
     (= (q x!60!569) 1)
     (= (q' x!60!569) 2)
     (= g 0)
     (= (+ A (+ now (* -1 (last' x!60!569)))) 0)
     (= (first x!60!569) (first' x!60!569))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!60!569)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!559!570 1)
     (>= (+ N (* -1 x!559!570)) 0)
     (>= x!560!571 1)
     (>= (+ N (* -1 x!560!571)) 0)
     (not (= x!559!570 x!560!571))
     (= (q' x!559!570) 4)
     (= (q' x!560!571) 4)
     (<= g 0)
     (<= (+ A (+ now (* -1 (last' x!60!569)))) 0)
     (>= (+ A (+ now (* -1 (last' x!60!569)))) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (not (= x!560!571 x!559!570))
     (>= (q x!60!569) 0)
     (<= (q x!60!569) 4)
     (<= (+ now' (* -1 (last' x!60!569))) 0)
     (>= (+ A (+ now' (* -1 (last' x!60!569)))) 0)
     (>= (q' x!60!569) 0)
     (<= (q' x!60!569) 4)
     (>= (q' x!559!570) 0)
     (<= (q' x!559!570) 4)
     (>= (q' x!560!571) 0)
     (<= (q' x!560!571) 4)
     (>= (last' x!60!569) 0)
     (>= (first' x!60!569) 0)
     (>= (first x!60!569) 0)
     (<= (q x!60!569) 1)
     (>= (q x!60!569) 1)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (q' x!60!569) 2)
     (>= (q' x!60!569) 2)
     (>= (q' x!559!570) 4)
     (>= (q' x!560!571) 4)
     (<= (+ (first x!60!569) (* -1 (first' x!60!569))) 0)
     (>= (+ (first x!60!569) (* -1 (first' x!60!569))) 0))


unsat: proved claim
add rows:             768
added eqs:            1297
arith conflicts:      40
assert diseq:         243
assert lower:         1572
assert upper:         913
bound prop:           41
conflicts:            146
decisions:            512
del clause:           2253
eq adapter:           738
final checks:         133
fixed eqs:            255
interface eqs:        12
max generation:       3
minimized lits:       2
mk clause:            2285
offset eqs:           48
pivots:               538
propagations:         912
quant instantiations: 1302
restarts:             10
max. heap size:     4.72574 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 2)
                      (= (q' h) 3)
                      (<= now (last h))
                      (>= now (last h))
                      (and (= g' h) (= (first' h) (+ now B))))
                 (and (= (last h) (last' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!554 Int) (x!553 Int)
       (or (not (>= x!553 1))
           (not (>= (+ N (* -1 x!553)) 0))
           (not (>= x!554 1))
           (not (>= (+ N (* -1 x!554)) 0))
           (= x!553 x!554)
           (not (= (q x!553) 4))
           (not (= (q x!554) 4)))
       :pat {(q x!553) (q x!554)})
     (>= x!65!572 1)
     (>= (+ N (* -1 x!65!572)) 0)
     (= (q x!65!572) 2)
     (= (q' x!65!572) 3)
     (<= (+ now (* -1 (last x!65!572))) 0)
     (>= (+ now (* -1 (last x!65!572))) 0)
     (= g' x!65!572)
     (= (+ B (+ now (* -1 (first' x!65!572)))) 0)
     (= (last x!65!572) (last' x!65!572))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!65!572)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!559!573 1)
     (>= (+ N (* -1 x!559!573)) 0)
     (>= x!560!574 1)
     (>= (+ N (* -1 x!560!574)) 0)
     (not (= x!559!573 x!560!574))
     (= (q' x!559!573) 4)
     (= (q' x!560!574) 4)
     (<= (+ g' (* -1 x!65!572)) 0)
     (>= (+ g' (* -1 x!65!572)) 0)
     (<= (+ B (+ now (* -1 (first' x!65!572)))) 0)
     (>= (+ B (+ now (* -1 (first' x!65!572)))) 0)
     (>= (+ A (+ now (* -1 (last x!65!572)))) 0)
     (>= (q x!65!572) 0)
     (<= (q x!65!572) 4)
     (>= (q' x!65!572) 0)
     (<= (q' x!65!572) 4)
     (>= (q' x!559!573) 0)
     (<= (q' x!559!573) 4)
     (>= (q' x!560!574) 0)
     (<= (q' x!560!574) 4)
     (>= (last x!65!572) 0)
     (>= (first' x!65!572) 0)
     (>= (last' x!65!572) 0)
     (<= (q x!65!572) 2)
     (>= (q x!65!572) 2)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!65!572) (* -1 (last' x!65!572))) 0)
     (>= (+ (last x!65!572) (* -1 (last' x!65!572))) 0)
     (<= (q' x!65!572) 3)
     (>= (q' x!65!572) 3)
     (>= (q' x!559!573) 4)
     (>= (q' x!560!574) 4))


unsat: proved claim
add rows:             770
added eqs:            1334
arith conflicts:      40
assert diseq:         249
assert lower:         1609
assert upper:         927
bound prop:           41
conflicts:            148
decisions:            515
del clause:           2303
eq adapter:           758
final checks:         133
fixed eqs:            258
interface eqs:        12
max generation:       3
minimized lits:       2
mk clause:            2336
offset eqs:           49
pivots:               542
propagations:         928
quant instantiations: 1351
restarts:             10
max. heap size:     4.72574 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3)
                      (= (q' h) 1)
                      (and (not (= g h)) (>= now (first h)))
                      (= (first' h) 0))
                 (and (= (last h) (last' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 1)
                               (and (not (= g h)) (>= now (first h)))
                               (= (first' h) 0))
                          (and (= (last h) (last' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!554 Int) (x!553 Int)
       (or (not (>= x!553 1))
           (not (>= (+ N (* -1 x!553)) 0))
           (not (>= x!554 1))
           (not (>= (+ N (* -1 x!554)) 0))
           (= x!553 x!554)
           (not (= (q x!553) 4))
           (not (= (q x!554) 4)))
       :pat {(q x!553) (q x!554)})
     (>= x!70!575 1)
     (>= (+ N (* -1 x!70!575)) 0)
     (= (q x!70!575) 3)
     (= (q' x!70!575) 1)
     (not (= g x!70!575))
     (>= (+ now (* -1 (first x!70!575))) 0)
     (= (first' x!70!575) 0)
     (= (last x!70!575) (last' x!70!575))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!70!575)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!559!576 1)
     (>= (+ N (* -1 x!559!576)) 0)
     (>= x!560!577 1)
     (>= (+ N (* -1 x!560!577)) 0)
     (not (= x!559!576 x!560!577))
     (= (q' x!559!576) 4)
     (= (q' x!560!577) 4)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (>= (q x!70!575) 0)
     (<= (q x!70!575) 4)
     (>= (q' x!70!575) 0)
     (<= (q' x!70!575) 4)
     (>= (q' x!559!576) 0)
     (<= (q' x!559!576) 4)
     (>= (q' x!560!577) 0)
     (<= (q' x!560!577) 4)
     (>= (first x!70!575) 0)
     (>= (first' x!70!575) 0)
     (>= (last' x!70!575) 0)
     (>= (last x!70!575) 0)
     (<= (q x!70!575) 3)
     (>= (q x!70!575) 3)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!70!575) (* -1 (last' x!70!575))) 0)
     (>= (+ (last x!70!575) (* -1 (last' x!70!575))) 0)
     (<= (q' x!70!575) 1)
     (>= (q' x!70!575) 1)
     (>= (q' x!559!576) 4)
     (>= (q' x!560!577) 4)
     (<= (first' x!70!575) 0))


unsat: proved claim
add rows:             772
added eqs:            1368
arith conflicts:      40
assert diseq:         257
assert lower:         1645
assert upper:         941
bound prop:           41
conflicts:            150
decisions:            518
del clause:           2352
eq adapter:           780
final checks:         133
fixed eqs:            260
interface eqs:        12
max generation:       3
minimized lits:       2
mk clause:            2389
offset eqs:           49
pivots:               545
propagations:         942
quant instantiations: 1401
restarts:             10
max. heap size:     4.72574 Mbytes
Unsat core:


<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 3) (= (q' h) 4) (and (= g h) (>= now (first h))))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= g g')
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))



<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!554 Int) (x!553 Int)
       (or (not (>= x!553 1))
           (not (>= (+ N (* -1 x!553)) 0))
           (not (>= x!554 1))
           (not (>= (+ N (* -1 x!554)) 0))
           (= x!553 x!554)
           (not (= (q x!553) 4))
           (not (= (q x!554) 4)))
       :pat {(q x!553) (q x!554)})
     (>= x!75!578 1)
     (>= (+ N (* -1 x!75!578)) 0)
     (= (q x!75!578) 3)
     (= (q' x!75!578) 4)
     (= g x!75!578)
     (>= (+ now (* -1 (first x!75!578))) 0)
     (= (last x!75!578) (last' x!75!578))
     (= (first x!75!578) (first' x!75!578))
     (= g g')
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!75!578)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!559!579 1)
     (>= (+ N (* -1 x!559!579)) 0)
     (>= x!560!580 1)
     (>= (+ N (* -1 x!560!580)) 0)
     (not (= x!559!579 x!560!580))
     (= (q' x!559!579) 4)
     (= (q' x!560!580) 4)
     (<= (+ g (* -1 x!75!578)) 0)
     (>= (+ g (* -1 x!75!578)) 0)
     (<= (+ g (* -1 g')) 0)
     (>= (+ g (* -1 g')) 0)
     (not (= x!560!580 x!559!579))
     (>= (q x!75!578) 0)
     (<= (q x!75!578) 4)
     (>= (q' x!75!578) 0)
     (<= (q' x!75!578) 4)
     (>= (q' x!559!579) 0)
     (<= (q' x!559!579) 4)
     (>= (q' x!560!580) 0)
     (<= (q' x!560!580) 4)
     (>= (first x!75!578) 0)
     (>= (last' x!75!578) 0)
     (>= (last x!75!578) 0)
     (>= (first' x!75!578) 0)
     (<= (q x!75!578) 3)
     (>= (q x!75!578) 3)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!75!578) (* -1 (last' x!75!578))) 0)
     (>= (+ (last x!75!578) (* -1 (last' x!75!578))) 0)
     (>= (q' x!75!578) 4)
     (>= (q' x!559!579) 4)
     (>= (q' x!560!580) 4)
     (<= (+ (first x!75!578) (* -1 (first' x!75!578))) 0)
     (>= (+ (first x!75!578) (* -1 (first' x!75!578))) 0))


sat: disproved claim
A -> 1
N -> 5
g -> 1
now -> 0
g' -> 1
x!75!578 -> 1
now' -> 0
x!559!579 -> 1
x!560!580 -> 3
B -> 1
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
k!651 -> {
  #unspecified
}
q' -> {
  #unspecified
}
q'!652 -> {
  5 -> 0
  4 -> 3
  2 -> 0
  else -> #unspecified
}
q -> {
  #unspecified
}
q!653 -> {
  3 -> 4
  5 -> 0
  2 -> 0
  else -> #unspecified
}
add rows:             1037
added eqs:            1674
arith conflicts:      44
assert diseq:         353
assert lower:         1935
assert upper:         1148
bound prop:           67
conflicts:            157
decisions:            739
del clause:           2741
eq adapter:           932
final checks:         139
fixed eqs:            317
gcd tests:            14
interface eqs:        14
max generation:       3
minimized lits:       2
mk clause:            3036
offset eqs:           92
pivots:               633
propagations:         1247
quant instantiations: 1697
restarts:             13
max. heap size:     4.82924 Mbytes

<><><><><> GUARDED MODEL START


(and (forall (i Int) (j Int)
       (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))
     (exists (h Int)
       (and (and (>= h 1) (<= h N))
            (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                 (and (= (last h) (last' h))
                      (= (first h) (first' h))
                      (= now now')
                      (forall (j Int)
                        (implies (and (and (>= j 1) (<= j N)) (distinct j h))
                                 (and (= (q j) (q' j))
                                      (= (last j) (last' j))
                                      (= (first j) (first' j))))))))))


A -> 1
N -> 5
g -> 1
now -> 0
g' -> 1
x!75!578 -> 1
now' -> 0
x!559!579 -> 1
x!560!580 -> 3
B -> 1
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
k!651 -> {
  #unspecified
}
q' -> {
  #unspecified
}
q'!652 -> {
  5 -> 0
  4 -> 3
  2 -> 0
  else -> #unspecified
}
q -> {
  #unspecified
}
q!653 -> {
  3 -> 4
  5 -> 0
  2 -> 0
  else -> #unspecified
}

<><><><><> GUARDED MODEL END



<><><><><> INDUCTIVE INVARIANT START


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))



<><><><><> INDUCTIVE INVARIANT END


Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 4) (= (q' h) 0) (= g' 0))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!554 Int) (x!553 Int)
       (or (not (>= x!553 1))
           (not (>= (+ N (* -1 x!553)) 0))
           (not (>= x!554 1))
           (not (>= (+ N (* -1 x!554)) 0))
           (= x!553 x!554)
           (not (= (q x!553) 4))
           (not (= (q x!554) 4)))
       :pat {(q x!553) (q x!554)})
     (>= x!80!669 1)
     (>= (+ N (* -1 x!80!669)) 0)
     (= (q x!80!669) 4)
     (= (q' x!80!669) 0)
     (= g' 0)
     (= (last x!80!669) (last' x!80!669))
     (= (first x!80!669) (first' x!80!669))
     (= now now')
     (forall (x!46 Int)
       (or (not (>= x!46 1))
           (not (>= (+ N (* -1 x!46)) 0))
           (= x!46 x!80!669)
           (not (or (not (= (q x!46) (q' x!46)))
                    (not (= (last x!46) (last' x!46)))
                    (not (= (first x!46) (first' x!46))))))
       :pat {(q x!46)}
       :pat {(q' x!46)}
       :pat {(last x!46)}
       :pat {(last' x!46)}
       :pat {(first x!46)}
       :pat {(first' x!46)})
     (>= x!559!670 1)
     (>= (+ N (* -1 x!559!670)) 0)
     (>= x!560!671 1)
     (>= (+ N (* -1 x!560!671)) 0)
     (not (= x!559!670 x!560!671))
     (= (q' x!559!670) 4)
     (= (q' x!560!671) 4)
     (<= g' 0)
     (>= (q x!80!669) 0)
     (<= (q x!80!669) 4)
     (>= (q' x!80!669) 0)
     (<= (q' x!80!669) 4)
     (>= (q' x!559!670) 0)
     (<= (q' x!559!670) 4)
     (>= (q' x!560!671) 0)
     (<= (q' x!560!671) 4)
     (>= (last' x!80!669) 0)
     (>= (last x!80!669) 0)
     (>= (first' x!80!669) 0)
     (>= (first x!80!669) 0)
     (>= (q x!80!669) 4)
     (<= (+ now (* -1 now')) 0)
     (>= (+ now (* -1 now')) 0)
     (<= (+ (last x!80!669) (* -1 (last' x!80!669))) 0)
     (>= (+ (last x!80!669) (* -1 (last' x!80!669))) 0)
     (<= (q' x!80!669) 0)
     (>= (q' x!559!670) 4)
     (>= (q' x!560!671) 4)
     (<= (+ (first x!80!669) (* -1 (first' x!80!669))) 0)
     (>= (+ (first x!80!669) (* -1 (first' x!80!669))) 0))


unsat: proved claim
add rows:             1082
added eqs:            1699
arith conflicts:      44
assert diseq:         359
assert lower:         1961
assert upper:         1157
bound prop:           67
conflicts:            159
decisions:            742
del clause:           3045
eq adapter:           946
final checks:         139
fixed eqs:            319
gcd tests:            14
interface eqs:        14
max generation:       3
minimized lits:       2
mk clause:            3075
offset eqs:           92
pivots:               666
propagations:         1258
quant instantiations: 1741
restarts:             13
max. heap size:     4.82924 Mbytes
Unsat core:

Term:
(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


Attempting to prove the following: 
(and (not (<= A 0))
     (not (<= B 0))
     (>= (+ A (* -1 B)) 0)
     (>= N 2)
     (<= N 9)
     (forall (x!0 Int)
       (or (not (>= x!0 1)) (not (>= (+ N (* -1 x!0)) 0)) (>= (last x!0) 0))
       :pat {(last x!0)})
     (forall (x!2 Int)
       (or (not (>= x!2 1)) (not (>= (+ N (* -1 x!2)) 0)) (>= (last' x!2) 0))
       :pat {(last' x!2)})
     (forall (x!4 Int)
       (or (not (>= x!4 1)) (not (>= (+ N (* -1 x!4)) 0)) (>= (first x!4) 0))
       :pat {(first x!4)})
     (forall (x!6 Int)
       (or (not (>= x!6 1)) (not (>= (+ N (* -1 x!6)) 0)) (>= (first' x!6) 0))
       :pat {(first' x!6)})
     (forall (x!8 Int) (>= (q x!8) 0) :pat {(q x!8)})
     (forall (x!8 Int) (<= (q x!8) 4) :pat {(q x!8)})
     (forall (x!10 Int) (>= (q' x!10) 0) :pat {(q' x!10)})
     (forall (x!10 Int) (<= (q' x!10) 4) :pat {(q' x!10)})
     (>= g 0)
     (>= (+ N (* -1 g)) 0)
     (>= g' 0)
     (>= (+ N (* -1 g')) 0)
     (forall (x!43 Int)
       (or (not (>= x!43 1))
           (not (>= (+ N (* -1 x!43)) 0))
           (not (= (q x!43) 2))
           (>= (+ A (+ now (* -1 (last x!43)))) 0))
       :pat {(q x!43)}
       :pat {(last x!43)})
     (forall (x!51 Int)
       (or (not (>= x!51 1))
           (not (>= (+ N (* -1 x!51)) 0))
           (not (= (q' x!51) 2))
           (>= (+ A (+ now' (* -1 (last' x!51)))) 0))
       :pat {(q' x!51)}
       :pat {(last' x!51)})
     (forall (x!147 Int)
       (or (not (>= x!147 1))
           (not (>= (+ N (* -1 x!147)) 0))
           (not (= (q x!147) 2))
           (<= (+ now (* -1 (last x!147))) 0))
       :pat {(q x!147)}
       :pat {(last x!147)})
     (forall (x!149 Int)
       (or (not (>= x!149 1))
           (not (>= (+ N (* -1 x!149)) 0))
           (not (= (q' x!149) 2))
           (<= (+ now' (* -1 (last' x!149))) 0))
       :pat {(q' x!149)}
       :pat {(last' x!149)})
     (forall (x!554 Int) (x!553 Int)
       (or (not (>= x!553 1))
           (not (>= (+ N (* -1 x!553)) 0))
           (not (>= x!554 1))
           (not (>= (+ N (* -1 x!554)) 0))
           (= x!553 x!554)
           (not (= (q x!553) 4))
           (not (= (q x!554) 4)))
       :pat {(q x!553) (q x!554)})
     (>= x!94!672 0)
     (forall (x!96 Real) (x!95 Int)
       (or (not (>= x!96 0))
           (not (<= (+ x!96 (* -1 x!94!672)) 0))
           (not (>= x!95 1))
           (not (>= (+ N (* -1 x!95)) 0))
           (not (or (not (or (not (= (q x!95) 0))
                             (= (+ now (+ (* -1 now') x!94!672)) 0)))
                    (not (or (not (= (q x!95) 1))
                             (= (+ now (+ (* -1 now') x!94!672)) 0)))
                    (not (or (not (= (q x!95) 2))
                             (not (or (not (<= (+ now
                                                  (+ x!96 (* -1 (last x!95))))
                                               0))
                                      (not (or (not (>= (+ now
                                                           (+ x!96
                                                              (* -1 (last x!95))))
                                                        0))
                                               (= x!94!672 x!96)))
                                      (not (= (+ now (+ (* -1 now') x!94!672))
                                              0))))))
                    (not (or (not (= (q x!95) 3))
                             (= (+ now (+ (* -1 now') x!94!672)) 0)))
                    (not (or (not (= (q x!95) 4))
                             (= (+ now (+ (* -1 now') x!94!672)) 0)))
                    (not (= (q x!95) (q' x!95)))
                    (not (= (last x!95) (last' x!95)))
                    (not (= (first x!95) (first' x!95)))
                    (not (= g g'))))))
     (>= x!559!673 1)
     (>= (+ N (* -1 x!559!673)) 0)
     (>= x!560!674 1)
     (>= (+ N (* -1 x!560!674)) 0)
     (not (= x!559!673 x!560!674))
     (= (q' x!559!673) 4)
     (= (q' x!560!674) 4)
     (>= (q' x!559!673) 0)
     (<= (q' x!559!673) 4)
     (>= (q' x!560!674) 0)
     (<= (q' x!560!674) 4)
     (>= (q' x!559!673) 4)
     (>= (q' x!560!674) 4))


unsat: proved claim
add rows:             1092
added eqs:            1719
arith conflicts:      44
assert diseq:         369
assert lower:         1996
assert upper:         1170
bound prop:           67
conflicts:            160
decisions:            760
del clause:           3127
eq adapter:           969
final checks:         141
fixed eqs:            323
gcd tests:            14
interface eqs:        14
max generation:       3
minimized lits:       2
mk clause:            3208
offset eqs:           93
pivots:               671
propagations:         1289
quant instantiations: 1763
restarts:             15
max. heap size:     4.82924 Mbytes
Unsat core:



Property was NOT an inductive invariant! Property checked was: 
(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))


Property was NOT inductive! Property checked was: 
(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))


DISPROVED INVARIANTS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

PROPERTY DISPROVED =====================================================================

(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))


Time: 0.2429048

REASONS (counterexample / trace):

Counterexample model:

A -> 1
N -> 2
g -> 0
x!94!235 -> 1
x!219!236 -> 1
now -> 0
g' -> 0
now' -> 1
B -> 1
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}



Inductive invariant claim:


(implies (and (forall (i Int)
                (implies (and (>= i 1) (<= i N)) (<= now (last i))))
              (exists (t_1 Real)
                (and (>= t_1 0)
                     (forall (t_2 Real)
                       (implies (and (>= t_2 0) (<= t_2 t_1))
                                (forall (h Int)
                                  (implies (and (>= h 1) (<= h N))
                                           (and (and (implies (= (q h) 0)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 1)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 2)
                                                              (and (<= (+ now
                                                                          t_2)
                                                                       (last h))
                                                                   (implies (>= (+ now
                                                                                   t_2)
                                                                                (last h))
                                                                            (= t_1
                                                                               t_2))
                                                                   (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 3)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1))))
                                                     (implies (= (q h) 4)
                                                              (and (= now'
                                                                      (+ now
                                                                         t_1)))))
                                                (and (= (q h) (q' h))
                                                     (= (last h) (last' h))
                                                     (= (first h) (first' h))
                                                     (= g g'))))))))))
         (forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now' (last' i)))))


END PROPERTY DISPROVED =====================================================================




PROPERTY DISPROVED =====================================================================

(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                    (> (first i) (last j)))))


Time: 0.3761527

REASONS (counterexample / trace):

Counterexample model:

A -> 1
N -> 2
g -> 0
x!65!291 -> 2
now -> 0
g' -> 2
now' -> 0
x!282!292 -> 1
B -> 1
last' -> {
  #unspecified
}
last'!327 -> {
  1 -> 1
  else -> #unspecified
}
last!330 -> {
  1 -> 1
  else -> #unspecified
}
first' -> {
  #unspecified
}
first -> {
  #unspecified
}
k!326 -> {
  #unspecified
}
last -> {
  #unspecified
}
q'!328 -> {
  1 -> 2
  else -> #unspecified
}
q' -> {
  #unspecified
}
q -> {
  #unspecified
}
first'!329 -> {
  1 -> 0
  else -> #unspecified
}



Inductive invariant claim:


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                                  (> (first i) (last j)))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 2)
                               (= (q' h) 3)
                               (<= now (last h))
                               (>= now (last h))
                               (and (= g' h) (= (first' h) (+ now B))))
                          (and (= (last h) (last' h))
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (and (and (= (q' i) 3) (= (q' j) 2)) (= g' i))
                             (> (first' i) (last' j))))))


END PROPERTY DISPROVED =====================================================================




PROPERTY DISPROVED =====================================================================

(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))


Time: 0.3597057

REASONS (counterexample / trace):

Counterexample model:

A -> 1
N -> 4
g -> 1
now -> 0
x!439!459 -> 1
g' -> 1
now' -> 0
x!440!460 -> 2
B -> 1
x!75!458 -> 1
last' -> {
  #unspecified
}
q!487 -> {
  2 -> 2
  4 -> 0
  else -> #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
q' -> {
  #unspecified
}
k!485 -> {
  #unspecified
}
q -> {
  #unspecified
}
q'!486 -> {
  2 -> 2
  4 -> 0
  else -> #unspecified
}



Inductive invariant claim:


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (= (q' i) 4) (and (= g' i) (not (= (q' j) 2)))))))


END PROPERTY DISPROVED =====================================================================




PROPERTY DISPROVED =====================================================================

(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))


Time: 0.6857287

REASONS (counterexample / trace):

Counterexample model:

A -> 1
N -> 5
g -> 1
now -> 0
g' -> 1
x!75!578 -> 1
now' -> 0
x!559!579 -> 1
x!560!580 -> 3
B -> 1
last' -> {
  #unspecified
}
first -> {
  #unspecified
}
first' -> {
  #unspecified
}
last -> {
  #unspecified
}
k!651 -> {
  #unspecified
}
q' -> {
  #unspecified
}
q'!652 -> {
  5 -> 0
  4 -> 3
  2 -> 0
  else -> #unspecified
}
q -> {
  #unspecified
}
q!653 -> {
  3 -> 4
  5 -> 0
  2 -> 0
  else -> #unspecified
}



Inductive invariant claim:


(implies (and (forall (i Int) (j Int)
                (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                         (implies (not (= i j))
                                  (or (not (= (q i) 4)) (not (= (q j) 4))))))
              (exists (h Int)
                (and (and (>= h 1) (<= h N))
                     (and (and (= (q h) 3)
                               (= (q' h) 4)
                               (and (= g h) (>= now (first h))))
                          (and (= (last h) (last' h))
                               (= (first h) (first' h))
                               (= g g')
                               (= now now')
                               (forall (j Int)
                                 (implies (and (and (>= j 1) (<= j N))
                                               (distinct j h))
                                          (and (= (q j) (q' j))
                                               (= (last j) (last' j))
                                               (= (first j) (first' j))))))))))
         (forall (i Int) (j Int)
           (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
                    (implies (not (= i j))
                             (or (not (= (q' i) 4)) (not (= (q' j) 4)))))))


END PROPERTY DISPROVED =====================================================================




DISPROVED INVARIANTS SUMMARY WITH STATISTICS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))

Time: 0.2429048


Statistics: 

add rows:             223
added eqs:            357
arith conflicts:      19
assert diseq:         14
assert lower:         526
assert upper:         276
bound prop:           2
conflicts:            62
decisions:            144
del clause:           583
eq adapter:           198
final checks:         89
fixed eqs:            73
max generation:       2
mk clause:            596
offset eqs:           17
pivots:               226
propagations:         219
quant instantiations: 351
restarts:             2
max. heap size:     2.87998 Mbytes



add rows:             238
added eqs:            379
arith conflicts:      20
assert diseq:         16
assert lower:         553
assert upper:         294
bound prop:           3
conflicts:            64
decisions:            146
del clause:           613
eq adapter:           210
final checks:         89
fixed eqs:            79
max generation:       2
mk clause:            626
offset eqs:           18
pivots:               238
propagations:         228
quant instantiations: 375
restarts:             2
max. heap size:     2.87998 Mbytes



add rows:             255
added eqs:            403
arith conflicts:      21
assert diseq:         17
assert lower:         579
assert upper:         312
bound prop:           3
conflicts:            66
decisions:            148
del clause:           643
eq adapter:           222
final checks:         89
fixed eqs:            86
max generation:       2
mk clause:            656
offset eqs:           21
pivots:               250
propagations:         239
quant instantiations: 397
restarts:             2
max. heap size:     2.87998 Mbytes



add rows:             270
added eqs:            429
arith conflicts:      22
assert diseq:         18
assert lower:         607
assert upper:         330
bound prop:           5
conflicts:            68
decisions:            150
del clause:           675
eq adapter:           233
final checks:         89
fixed eqs:            93
max generation:       2
mk clause:            686
offset eqs:           25
pivots:               263
propagations:         249
quant instantiations: 420
restarts:             2
max. heap size:     2.87998 Mbytes



add rows:             288
added eqs:            450
arith conflicts:      23
assert diseq:         20
assert lower:         633
assert upper:         348
bound prop:           6
conflicts:            70
decisions:            152
del clause:           702
eq adapter:           245
final checks:         89
fixed eqs:            98
max generation:       2
mk clause:            717
offset eqs:           26
pivots:               277
propagations:         257
quant instantiations: 444
restarts:             2
max. heap size:     2.87998 Mbytes



add rows:             307
added eqs:            470
arith conflicts:      24
assert diseq:         21
assert lower:         661
assert upper:         366
bound prop:           7
conflicts:            72
decisions:            154
del clause:           735
eq adapter:           257
final checks:         89
fixed eqs:            100
max generation:       2
mk clause:            748
offset eqs:           27
pivots:               291
propagations:         267
quant instantiations: 468
restarts:             2
max. heap size:     2.87998 Mbytes



add rows:             323
added eqs:            491
arith conflicts:      25
assert diseq:         22
assert lower:         685
assert upper:         383
bound prop:           8
conflicts:            74
decisions:            156
del clause:           759
eq adapter:           268
final checks:         89
fixed eqs:            105
max generation:       2
mk clause:            772
offset eqs:           29
pivots:               303
propagations:         274
quant instantiations: 492
restarts:             2
max. heap size:     2.87998 Mbytes



add rows:             332
added eqs:            504
arith conflicts:      25
assert diseq:         24
assert lower:         700
assert upper:         397
bound prop:           10
conflicts:            74
decisions:            163
del clause:           803
eq adapter:           275
final checks:         91
fixed eqs:            109
max generation:       2
mk clause:            820
offset eqs:           29
pivots:               313
propagations:         293
quant instantiations: 503
restarts:             3
max. heap size:     2.87998 Mbytes



(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                    (> (first i) (last j)))))

Time: 0.3761527


Statistics: 

add rows:             374
added eqs:            592
arith conflicts:      27
assert diseq:         38
assert lower:         780
assert upper:         455
bound prop:           10
conflicts:            89
decisions:            197
del clause:           882
eq adapter:           320
final checks:         99
fixed eqs:            125
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            911
offset eqs:           29
pivots:               343
propagations:         354
quant instantiations: 574
restarts:             3
max. heap size:     2.96042 Mbytes



add rows:             403
added eqs:            660
arith conflicts:      29
assert diseq:         50
assert lower:         845
assert upper:         502
bound prop:           10
conflicts:            94
decisions:            213
del clause:           954
eq adapter:           353
final checks:         99
fixed eqs:            139
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            977
offset eqs:           29
pivots:               356
propagations:         391
quant instantiations: 644
restarts:             3
max. heap size:     3.12127 Mbytes



add rows:             405
added eqs:            669
arith conflicts:      30
assert diseq:         50
assert lower:         852
assert upper:         506
bound prop:           10
conflicts:            95
decisions:            213
del clause:           977
eq adapter:           356
final checks:         99
fixed eqs:            140
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            987
offset eqs:           29
pivots:               360
propagations:         396
quant instantiations: 644
restarts:             3
max. heap size:     3.18747 Mbytes



add rows:             448
added eqs:            710
arith conflicts:      30
assert diseq:         57
assert lower:         900
assert upper:         543
bound prop:           12
conflicts:            95
decisions:            244
del clause:           1021
eq adapter:           378
final checks:         101
fixed eqs:            153
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1063
offset eqs:           32
pivots:               377
propagations:         422
quant instantiations: 684
restarts:             4
max. heap size:     3.41031 Mbytes



add rows:             490
added eqs:            762
arith conflicts:      32
assert diseq:         68
assert lower:         961
assert upper:         581
bound prop:           14
conflicts:            100
decisions:            263
del clause:           1094
eq adapter:           407
final checks:         101
fixed eqs:            163
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1121
offset eqs:           33
pivots:               399
propagations:         449
quant instantiations: 741
restarts:             4
max. heap size:     3.41031 Mbytes



add rows:             504
added eqs:            772
arith conflicts:      32
assert diseq:         68
assert lower:         961
assert upper:         581
bound prop:           14
conflicts:            101
decisions:            263
del clause:           1121
eq adapter:           409
final checks:         101
fixed eqs:            163
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1129
offset eqs:           33
pivots:               406
propagations:         453
quant instantiations: 741
restarts:             4
max. heap size:     3.41031 Mbytes



add rows:             504
added eqs:            772
arith conflicts:      32
assert diseq:         68
assert lower:         961
assert upper:         581
bound prop:           14
conflicts:            102
decisions:            263
del clause:           1129
eq adapter:           410
final checks:         101
fixed eqs:            163
interface eqs:        2
max generation:       2
minimized lits:       1
mk clause:            1132
offset eqs:           33
pivots:               406
propagations:         454
quant instantiations: 741
restarts:             4
max. heap size:     3.41574 Mbytes



add rows:             540
added eqs:            845
arith conflicts:      34
assert diseq:         117
assert lower:         1073
assert upper:         635
bound prop:           18
conflicts:            109
decisions:            371
del clause:           1294
eq adapter:           468
final checks:         107
fixed eqs:            188
interface eqs:        5
max generation:       3
minimized lits:       1
mk clause:            1435
offset eqs:           34
pivots:               423
propagations:         579
quant instantiations: 800
restarts:             7
max. heap size:     3.61901 Mbytes



(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))

Time: 0.3597057


Statistics: 

add rows:             602
added eqs:            911
arith conflicts:      36
assert diseq:         136
assert lower:         1150
assert upper:         679
bound prop:           20
conflicts:            118
decisions:            408
del clause:           1496
eq adapter:           504
final checks:         122
fixed eqs:            200
interface eqs:        11
max generation:       3
minimized lits:       1
mk clause:            1542
offset eqs:           37
pivots:               456
propagations:         630
quant instantiations: 855
restarts:             7
max. heap size:     3.8152 Mbytes



add rows:             627
added eqs:            973
arith conflicts:      38
assert diseq:         159
assert lower:         1221
assert upper:         726
bound prop:           20
conflicts:            124
decisions:            440
del clause:           1609
eq adapter:           540
final checks:         122
fixed eqs:            214
interface eqs:        11
max generation:       3
minimized lits:       2
mk clause:            1642
offset eqs:           37
pivots:               464
propagations:         690
quant instantiations: 928
restarts:             7
max. heap size:     3.8152 Mbytes



add rows:             633
added eqs:            1000
arith conflicts:      38
assert diseq:         165
assert lower:         1245
assert upper:         744
bound prop:           26
conflicts:            127
decisions:            446
del clause:           1683
eq adapter:           556
final checks:         122
fixed eqs:            217
interface eqs:        11
max generation:       3
minimized lits:       2
mk clause:            1702
offset eqs:           40
pivots:               468
propagations:         714
quant instantiations: 961
restarts:             7
max. heap size:     3.8152 Mbytes



add rows:             636
added eqs:            1021
arith conflicts:      38
assert diseq:         166
assert lower:         1266
assert upper:         755
bound prop:           26
conflicts:            129
decisions:            447
del clause:           1723
eq adapter:           568
final checks:         122
fixed eqs:            220
interface eqs:        11
max generation:       3
minimized lits:       2
mk clause:            1743
offset eqs:           41
pivots:               472
propagations:         723
quant instantiations: 984
restarts:             7
max. heap size:     3.8152 Mbytes



add rows:             654
added eqs:            1058
arith conflicts:      39
assert diseq:         176
assert lower:         1316
assert upper:         783
bound prop:           28
conflicts:            132
decisions:            456
del clause:           1779
eq adapter:           593
final checks:         122
fixed eqs:            229
interface eqs:        11
max generation:       3
minimized lits:       2
mk clause:            1808
offset eqs:           41
pivots:               478
propagations:         748
quant instantiations: 1024
restarts:             7
max. heap size:     3.91582 Mbytes



add rows:             689
added eqs:            1116
arith conflicts:      39
assert diseq:         199
assert lower:         1385
assert upper:         824
bound prop:           36
conflicts:            134
decisions:            487
del clause:           1878
eq adapter:           632
final checks:         124
fixed eqs:            234
interface eqs:        11
max generation:       3
minimized lits:       2
mk clause:            1916
offset eqs:           43
pivots:               493
propagations:         794
quant instantiations: 1081
restarts:             8
max. heap size:     4.40667 Mbytes



add rows:             714
added eqs:            1143
arith conflicts:      39
assert diseq:         205
assert lower:         1408
assert upper:         835
bound prop:           38
conflicts:            136
decisions:            490
del clause:           1950
eq adapter:           646
final checks:         124
fixed eqs:            237
interface eqs:        11
max generation:       3
minimized lits:       2
mk clause:            1965
offset eqs:           44
pivots:               506
propagations:         811
quant instantiations: 1115
restarts:             8
max. heap size:     4.40667 Mbytes



add rows:             742
added eqs:            1180
arith conflicts:      40
assert diseq:         216
assert lower:         1452
assert upper:         860
bound prop:           41
conflicts:            137
decisions:            499
del clause:           2079
eq adapter:           669
final checks:         127
fixed eqs:            246
interface eqs:        12
max generation:       3
minimized lits:       2
mk clause:            2115
offset eqs:           44
pivots:               515
propagations:         861
quant instantiations: 1143
restarts:             10
max. heap size:     4.40667 Mbytes



(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))

Time: 0.6857287


Statistics: 

add rows:             764
added eqs:            1224
arith conflicts:      40
assert diseq:         226
assert lower:         1499
assert upper:         883
bound prop:           41
conflicts:            142
decisions:            506
del clause:           2147
eq adapter:           694
final checks:         133
fixed eqs:            249
interface eqs:        12
max generation:       3
minimized lits:       2
mk clause:            2182
offset eqs:           45
pivots:               535
propagations:         880
quant instantiations: 1203
restarts:             10
max. heap size:     4.72574 Mbytes



add rows:             765
added eqs:            1259
arith conflicts:      40
assert diseq:         235
assert lower:         1536
assert upper:         897
bound prop:           41
conflicts:            144
decisions:            509
del clause:           2199
eq adapter:           716
final checks:         133
fixed eqs:            252
interface eqs:        12
max generation:       3
minimized lits:       2
mk clause:            2233
offset eqs:           45
pivots:               536
propagations:         895
quant instantiations: 1253
restarts:             10
max. heap size:     4.72574 Mbytes



add rows:             768
added eqs:            1297
arith conflicts:      40
assert diseq:         243
assert lower:         1572
assert upper:         913
bound prop:           41
conflicts:            146
decisions:            512
del clause:           2253
eq adapter:           738
final checks:         133
fixed eqs:            255
interface eqs:        12
max generation:       3
minimized lits:       2
mk clause:            2285
offset eqs:           48
pivots:               538
propagations:         912
quant instantiations: 1302
restarts:             10
max. heap size:     4.72574 Mbytes



add rows:             770
added eqs:            1334
arith conflicts:      40
assert diseq:         249
assert lower:         1609
assert upper:         927
bound prop:           41
conflicts:            148
decisions:            515
del clause:           2303
eq adapter:           758
final checks:         133
fixed eqs:            258
interface eqs:        12
max generation:       3
minimized lits:       2
mk clause:            2336
offset eqs:           49
pivots:               542
propagations:         928
quant instantiations: 1351
restarts:             10
max. heap size:     4.72574 Mbytes



add rows:             772
added eqs:            1368
arith conflicts:      40
assert diseq:         257
assert lower:         1645
assert upper:         941
bound prop:           41
conflicts:            150
decisions:            518
del clause:           2352
eq adapter:           780
final checks:         133
fixed eqs:            260
interface eqs:        12
max generation:       3
minimized lits:       2
mk clause:            2389
offset eqs:           49
pivots:               545
propagations:         942
quant instantiations: 1401
restarts:             10
max. heap size:     4.72574 Mbytes



add rows:             1037
added eqs:            1674
arith conflicts:      44
assert diseq:         353
assert lower:         1935
assert upper:         1148
bound prop:           67
conflicts:            157
decisions:            739
del clause:           2741
eq adapter:           932
final checks:         139
fixed eqs:            317
gcd tests:            14
interface eqs:        14
max generation:       3
minimized lits:       2
mk clause:            3036
offset eqs:           92
pivots:               633
propagations:         1247
quant instantiations: 1697
restarts:             13
max. heap size:     4.82924 Mbytes



add rows:             1082
added eqs:            1699
arith conflicts:      44
assert diseq:         359
assert lower:         1961
assert upper:         1157
bound prop:           67
conflicts:            159
decisions:            742
del clause:           3045
eq adapter:           946
final checks:         139
fixed eqs:            319
gcd tests:            14
interface eqs:        14
max generation:       3
minimized lits:       2
mk clause:            3075
offset eqs:           92
pivots:               666
propagations:         1258
quant instantiations: 1741
restarts:             13
max. heap size:     4.82924 Mbytes



add rows:             1092
added eqs:            1719
arith conflicts:      44
assert diseq:         369
assert lower:         1996
assert upper:         1170
bound prop:           67
conflicts:            160
decisions:            760
del clause:           3127
eq adapter:           969
final checks:         141
fixed eqs:            323
gcd tests:            14
interface eqs:        14
max generation:       3
minimized lits:       2
mk clause:            3208
offset eqs:           93
pivots:               671
propagations:         1289
quant instantiations: 1763
restarts:             15
max. heap size:     4.82924 Mbytes




PROVED INVARIANTS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

(forall (i Int)
  (implies (and (>= i 1) (<= i N))
           (implies (= (q i) 2) (<= (last i) (+ now A)))))

Time: 0.375849


Statistics: 

add rows:             9
added eqs:            26
arith conflicts:      1
assert lower:         58
assert upper:         27
conflicts:            16
decisions:            21
del clause:           24
eq adapter:           13
final checks:         41
fixed eqs:            5
max generation:       2
mk clause:            34
offset eqs:           1
pivots:               33
propagations:         13
quant instantiations: 24
max. heap size:     1.53561 Mbytes



add rows:             20
added eqs:            46
arith conflicts:      2
assert diseq:         1
assert lower:         88
assert upper:         42
conflicts:            19
decisions:            28
del clause:           50
eq adapter:           25
final checks:         44
fixed eqs:            10
max generation:       2
mk clause:            60
offset eqs:           1
pivots:               41
propagations:         20
quant instantiations: 43
max. heap size:     1.69643 Mbytes



add rows:             39
added eqs:            75
arith conflicts:      4
assert diseq:         1
assert lower:         118
assert upper:         60
conflicts:            22
decisions:            35
del clause:           79
eq adapter:           38
final checks:         47
fixed eqs:            17
max generation:       2
mk clause:            90
offset eqs:           4
pivots:               55
propagations:         31
quant instantiations: 61
max. heap size:     1.73557 Mbytes



add rows:             50
added eqs:            95
arith conflicts:      5
assert diseq:         1
assert lower:         148
assert upper:         76
conflicts:            25
decisions:            42
del clause:           107
eq adapter:           49
final checks:         50
fixed eqs:            22
max generation:       2
mk clause:            116
offset eqs:           5
pivots:               68
propagations:         39
quant instantiations: 79
max. heap size:     1.77381 Mbytes



add rows:             64
added eqs:            113
arith conflicts:      6
assert diseq:         2
assert lower:         177
assert upper:         91
conflicts:            28
decisions:            49
del clause:           131
eq adapter:           61
final checks:         53
fixed eqs:            26
max generation:       2
mk clause:            143
offset eqs:           5
pivots:               79
propagations:         45
quant instantiations: 98
max. heap size:     1.84961 Mbytes



add rows:             80
added eqs:            132
arith conflicts:      7
assert diseq:         2
assert lower:         208
assert upper:         106
conflicts:            31
decisions:            56
del clause:           160
eq adapter:           73
final checks:         56
fixed eqs:            27
max generation:       2
mk clause:            170
offset eqs:           5
pivots:               90
propagations:         53
quant instantiations: 117
max. heap size:     1.91758 Mbytes



add rows:             91
added eqs:            152
arith conflicts:      8
assert diseq:         2
assert lower:         235
assert upper:         120
conflicts:            34
decisions:            63
del clause:           180
eq adapter:           84
final checks:         59
fixed eqs:            31
max generation:       2
mk clause:            190
offset eqs:           6
pivots:               100
propagations:         58
quant instantiations: 136
max. heap size:     1.92684 Mbytes



add rows:             101
added eqs:            167
arith conflicts:      9
assert diseq:         11
assert lower:         260
assert upper:         137
conflicts:            38
decisions:            135
del clause:           279
eq adapter:           95
final checks:         69
fixed eqs:            33
max generation:       2
mk clause:            321
offset eqs:           6
pivots:               121
propagations:         140
quant instantiations: 146
restarts:             1
max. heap size:     2.27609 Mbytes



(forall (i Int)
  (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))

Time: 0.2379655


Statistics: 

add rows:             115
added eqs:            192
arith conflicts:      10
assert diseq:         11
assert lower:         298
assert upper:         155
conflicts:            44
decisions:            136
del clause:           342
eq adapter:           108
final checks:         80
fixed eqs:            38
max generation:       2
mk clause:            354
offset eqs:           7
pivots:               139
propagations:         147
quant instantiations: 175
restarts:             1
max. heap size:     2.39858 Mbytes



add rows:             127
added eqs:            212
arith conflicts:      11
assert diseq:         12
assert lower:         328
assert upper:         170
conflicts:            46
decisions:            137
del clause:           369
eq adapter:           120
final checks:         80
fixed eqs:            43
max generation:       2
mk clause:            381
offset eqs:           7
pivots:               146
propagations:         154
quant instantiations: 198
restarts:             1
max. heap size:     2.40022 Mbytes



add rows:             144
added eqs:            242
arith conflicts:      13
assert diseq:         12
assert lower:         359
assert upper:         188
conflicts:            48
decisions:            138
del clause:           399
eq adapter:           133
final checks:         80
fixed eqs:            51
max generation:       2
mk clause:            411
offset eqs:           10
pivots:               156
propagations:         165
quant instantiations: 220
restarts:             1
max. heap size:     2.4228 Mbytes



add rows:             160
added eqs:            266
arith conflicts:      14
assert diseq:         12
assert lower:         390
assert upper:         204
bound prop:           1
conflicts:            50
decisions:            139
del clause:           429
eq adapter:           144
final checks:         80
fixed eqs:            56
max generation:       2
mk clause:            438
offset eqs:           14
pivots:               169
propagations:         173
quant instantiations: 242
restarts:             1
max. heap size:     2.42329 Mbytes



add rows:             175
added eqs:            284
arith conflicts:      15
assert diseq:         13
assert lower:         419
assert upper:         219
bound prop:           1
conflicts:            52
decisions:            140
del clause:           452
eq adapter:           156
final checks:         80
fixed eqs:            60
max generation:       2
mk clause:            466
offset eqs:           14
pivots:               181
propagations:         179
quant instantiations: 265
restarts:             1
max. heap size:     2.42329 Mbytes



add rows:             190
added eqs:            304
arith conflicts:      16
assert diseq:         13
assert lower:         450
assert upper:         234
bound prop:           1
conflicts:            54
decisions:            141
del clause:           482
eq adapter:           168
final checks:         80
fixed eqs:            61
max generation:       2
mk clause:            494
offset eqs:           14
pivots:               191
propagations:         187
quant instantiations: 288
restarts:             1
max. heap size:     2.42329 Mbytes



add rows:             202
added eqs:            323
arith conflicts:      17
assert diseq:         13
assert lower:         477
assert upper:         248
bound prop:           1
conflicts:            56
decisions:            142
del clause:           503
eq adapter:           179
final checks:         80
fixed eqs:            65
max generation:       2
mk clause:            515
offset eqs:           15
pivots:               200
propagations:         192
quant instantiations: 311
restarts:             1
max. heap size:     2.52388 Mbytes



add rows:             211
added eqs:            334
arith conflicts:      18
assert diseq:         13
assert lower:         493
assert upper:         256
bound prop:           1
conflicts:            57
decisions:            142
del clause:           516
eq adapter:           185
final checks:         81
fixed eqs:            67
max generation:       2
mk clause:            558
offset eqs:           15
pivots:               207
propagations:         210
quant instantiations: 323
restarts:             2
max. heap size:     2.64801 Mbytes




PROVED INDUCTIVE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

DISPROVED INVARIANTS SUMMARY WITH SHORT RUNTIME >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

(forall (i Int) (implies (and (>= i 1) (<= i N)) (<= now (last i))))

Time: 0.2429048


(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (and (and (= (q i) 3) (= (q j) 2)) (= g i))
                    (> (first i) (last j)))))

Time: 0.3761527


(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (= (q i) 4) (and (= g i) (not (= (q j) 2))))))

Time: 0.3597057


(forall (i Int) (j Int)
  (implies (and (>= i 1) (<= i N) (>= j 1) (<= j N))
           (implies (not (= i j)) (or (not (= (q i) 4)) (not (= (q j) 4))))))

Time: 0.6857287



PROVED INVARIANTS >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

(forall (i Int)
  (implies (and (>= i 1) (<= i N))
           (implies (= (q i) 2) (<= (last i) (+ now A)))))

Time: 0.375849


(forall (i Int)
  (implies (and (>= i 1) (<= i N)) (implies (= (q i) 2) (<= now (last i)))))

Time: 0.2379655



PROVED INDUCTIVE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

